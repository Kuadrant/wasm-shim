// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `envoy/type/v3/http_status.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct HttpStatus {
    // message fields
    pub code: StatusCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HttpStatus {
    fn default() -> &'a HttpStatus {
        <HttpStatus as ::protobuf::Message>::default_instance()
    }
}

impl HttpStatus {
    pub fn new() -> HttpStatus {
        ::std::default::Default::default()
    }

    // .envoy.type.v3.StatusCode code = 1;


    pub fn get_code(&self) -> StatusCode {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = StatusCode::Empty;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: StatusCode) {
        self.code = v;
    }
}

impl ::protobuf::Message for HttpStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != StatusCode::Empty {
            my_size += ::protobuf::rt::enum_size(1, self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != StatusCode::Empty {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.code))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HttpStatus {
        HttpStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StatusCode>>(
                "code",
                |m: &HttpStatus| { &m.code },
                |m: &mut HttpStatus| { &mut m.code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HttpStatus>(
                "HttpStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HttpStatus {
        static instance: ::protobuf::rt::LazyV2<HttpStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HttpStatus::new)
    }
}

impl ::protobuf::Clear for HttpStatus {
    fn clear(&mut self) {
        self.code = StatusCode::Empty;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HttpStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HttpStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StatusCode {
    Empty = 0,
    Continue = 100,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    AlreadyReported = 208,
    IMUsed = 226,
    MultipleChoices = 300,
    MovedPermanently = 301,
    Found = 302,
    SeeOther = 303,
    NotModified = 304,
    UseProxy = 305,
    TemporaryRedirect = 307,
    PermanentRedirect = 308,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthenticationRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    PayloadTooLarge = 413,
    URITooLong = 414,
    UnsupportedMediaType = 415,
    RangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    MisdirectedRequest = 421,
    UnprocessableEntity = 422,
    Locked = 423,
    FailedDependency = 424,
    UpgradeRequired = 426,
    PreconditionRequired = 428,
    TooManyRequests = 429,
    RequestHeaderFieldsTooLarge = 431,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HTTPVersionNotSupported = 505,
    VariantAlsoNegotiates = 506,
    InsufficientStorage = 507,
    LoopDetected = 508,
    NotExtended = 510,
    NetworkAuthenticationRequired = 511,
}

impl ::protobuf::ProtobufEnum for StatusCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StatusCode> {
        match value {
            0 => ::std::option::Option::Some(StatusCode::Empty),
            100 => ::std::option::Option::Some(StatusCode::Continue),
            200 => ::std::option::Option::Some(StatusCode::OK),
            201 => ::std::option::Option::Some(StatusCode::Created),
            202 => ::std::option::Option::Some(StatusCode::Accepted),
            203 => ::std::option::Option::Some(StatusCode::NonAuthoritativeInformation),
            204 => ::std::option::Option::Some(StatusCode::NoContent),
            205 => ::std::option::Option::Some(StatusCode::ResetContent),
            206 => ::std::option::Option::Some(StatusCode::PartialContent),
            207 => ::std::option::Option::Some(StatusCode::MultiStatus),
            208 => ::std::option::Option::Some(StatusCode::AlreadyReported),
            226 => ::std::option::Option::Some(StatusCode::IMUsed),
            300 => ::std::option::Option::Some(StatusCode::MultipleChoices),
            301 => ::std::option::Option::Some(StatusCode::MovedPermanently),
            302 => ::std::option::Option::Some(StatusCode::Found),
            303 => ::std::option::Option::Some(StatusCode::SeeOther),
            304 => ::std::option::Option::Some(StatusCode::NotModified),
            305 => ::std::option::Option::Some(StatusCode::UseProxy),
            307 => ::std::option::Option::Some(StatusCode::TemporaryRedirect),
            308 => ::std::option::Option::Some(StatusCode::PermanentRedirect),
            400 => ::std::option::Option::Some(StatusCode::BadRequest),
            401 => ::std::option::Option::Some(StatusCode::Unauthorized),
            402 => ::std::option::Option::Some(StatusCode::PaymentRequired),
            403 => ::std::option::Option::Some(StatusCode::Forbidden),
            404 => ::std::option::Option::Some(StatusCode::NotFound),
            405 => ::std::option::Option::Some(StatusCode::MethodNotAllowed),
            406 => ::std::option::Option::Some(StatusCode::NotAcceptable),
            407 => ::std::option::Option::Some(StatusCode::ProxyAuthenticationRequired),
            408 => ::std::option::Option::Some(StatusCode::RequestTimeout),
            409 => ::std::option::Option::Some(StatusCode::Conflict),
            410 => ::std::option::Option::Some(StatusCode::Gone),
            411 => ::std::option::Option::Some(StatusCode::LengthRequired),
            412 => ::std::option::Option::Some(StatusCode::PreconditionFailed),
            413 => ::std::option::Option::Some(StatusCode::PayloadTooLarge),
            414 => ::std::option::Option::Some(StatusCode::URITooLong),
            415 => ::std::option::Option::Some(StatusCode::UnsupportedMediaType),
            416 => ::std::option::Option::Some(StatusCode::RangeNotSatisfiable),
            417 => ::std::option::Option::Some(StatusCode::ExpectationFailed),
            421 => ::std::option::Option::Some(StatusCode::MisdirectedRequest),
            422 => ::std::option::Option::Some(StatusCode::UnprocessableEntity),
            423 => ::std::option::Option::Some(StatusCode::Locked),
            424 => ::std::option::Option::Some(StatusCode::FailedDependency),
            426 => ::std::option::Option::Some(StatusCode::UpgradeRequired),
            428 => ::std::option::Option::Some(StatusCode::PreconditionRequired),
            429 => ::std::option::Option::Some(StatusCode::TooManyRequests),
            431 => ::std::option::Option::Some(StatusCode::RequestHeaderFieldsTooLarge),
            500 => ::std::option::Option::Some(StatusCode::InternalServerError),
            501 => ::std::option::Option::Some(StatusCode::NotImplemented),
            502 => ::std::option::Option::Some(StatusCode::BadGateway),
            503 => ::std::option::Option::Some(StatusCode::ServiceUnavailable),
            504 => ::std::option::Option::Some(StatusCode::GatewayTimeout),
            505 => ::std::option::Option::Some(StatusCode::HTTPVersionNotSupported),
            506 => ::std::option::Option::Some(StatusCode::VariantAlsoNegotiates),
            507 => ::std::option::Option::Some(StatusCode::InsufficientStorage),
            508 => ::std::option::Option::Some(StatusCode::LoopDetected),
            510 => ::std::option::Option::Some(StatusCode::NotExtended),
            511 => ::std::option::Option::Some(StatusCode::NetworkAuthenticationRequired),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StatusCode] = &[
            StatusCode::Empty,
            StatusCode::Continue,
            StatusCode::OK,
            StatusCode::Created,
            StatusCode::Accepted,
            StatusCode::NonAuthoritativeInformation,
            StatusCode::NoContent,
            StatusCode::ResetContent,
            StatusCode::PartialContent,
            StatusCode::MultiStatus,
            StatusCode::AlreadyReported,
            StatusCode::IMUsed,
            StatusCode::MultipleChoices,
            StatusCode::MovedPermanently,
            StatusCode::Found,
            StatusCode::SeeOther,
            StatusCode::NotModified,
            StatusCode::UseProxy,
            StatusCode::TemporaryRedirect,
            StatusCode::PermanentRedirect,
            StatusCode::BadRequest,
            StatusCode::Unauthorized,
            StatusCode::PaymentRequired,
            StatusCode::Forbidden,
            StatusCode::NotFound,
            StatusCode::MethodNotAllowed,
            StatusCode::NotAcceptable,
            StatusCode::ProxyAuthenticationRequired,
            StatusCode::RequestTimeout,
            StatusCode::Conflict,
            StatusCode::Gone,
            StatusCode::LengthRequired,
            StatusCode::PreconditionFailed,
            StatusCode::PayloadTooLarge,
            StatusCode::URITooLong,
            StatusCode::UnsupportedMediaType,
            StatusCode::RangeNotSatisfiable,
            StatusCode::ExpectationFailed,
            StatusCode::MisdirectedRequest,
            StatusCode::UnprocessableEntity,
            StatusCode::Locked,
            StatusCode::FailedDependency,
            StatusCode::UpgradeRequired,
            StatusCode::PreconditionRequired,
            StatusCode::TooManyRequests,
            StatusCode::RequestHeaderFieldsTooLarge,
            StatusCode::InternalServerError,
            StatusCode::NotImplemented,
            StatusCode::BadGateway,
            StatusCode::ServiceUnavailable,
            StatusCode::GatewayTimeout,
            StatusCode::HTTPVersionNotSupported,
            StatusCode::VariantAlsoNegotiates,
            StatusCode::InsufficientStorage,
            StatusCode::LoopDetected,
            StatusCode::NotExtended,
            StatusCode::NetworkAuthenticationRequired,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<StatusCode>("StatusCode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for StatusCode {
}

impl ::std::default::Default for StatusCode {
    fn default() -> Self {
        StatusCode::Empty
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1fenvoy/type/v3/http_status.proto\x12\renvoy.type.v3\x1a\x1dudpa/ann\
    otations/status.proto\x1a!udpa/annotations/versioning.proto\x1a\x17valid\
    ate/validate.proto\"e\n\nHttpStatus\x129\n\x04code\x18\x01\x20\x01(\x0e2\
    \x19.envoy.type.v3.StatusCodeR\x04codeB\n\xfaB\x07\x82\x01\x04\x10\x01\
    \x20\0:\x1c\x9a\xc5\x88\x1e\x17\n\x15envoy.type.HttpStatus*\xb5\t\n\nSta\
    tusCode\x12\t\n\x05Empty\x10\0\x12\x0c\n\x08Continue\x10d\x12\x07\n\x02O\
    K\x10\xc8\x01\x12\x0c\n\x07Created\x10\xc9\x01\x12\r\n\x08Accepted\x10\
    \xca\x01\x12\x20\n\x1bNonAuthoritativeInformation\x10\xcb\x01\x12\x0e\n\
    \tNoContent\x10\xcc\x01\x12\x11\n\x0cResetContent\x10\xcd\x01\x12\x13\n\
    \x0ePartialContent\x10\xce\x01\x12\x10\n\x0bMultiStatus\x10\xcf\x01\x12\
    \x14\n\x0fAlreadyReported\x10\xd0\x01\x12\x0b\n\x06IMUsed\x10\xe2\x01\
    \x12\x14\n\x0fMultipleChoices\x10\xac\x02\x12\x15\n\x10MovedPermanently\
    \x10\xad\x02\x12\n\n\x05Found\x10\xae\x02\x12\r\n\x08SeeOther\x10\xaf\
    \x02\x12\x10\n\x0bNotModified\x10\xb0\x02\x12\r\n\x08UseProxy\x10\xb1\
    \x02\x12\x16\n\x11TemporaryRedirect\x10\xb3\x02\x12\x16\n\x11PermanentRe\
    direct\x10\xb4\x02\x12\x0f\n\nBadRequest\x10\x90\x03\x12\x11\n\x0cUnauth\
    orized\x10\x91\x03\x12\x14\n\x0fPaymentRequired\x10\x92\x03\x12\x0e\n\tF\
    orbidden\x10\x93\x03\x12\r\n\x08NotFound\x10\x94\x03\x12\x15\n\x10Method\
    NotAllowed\x10\x95\x03\x12\x12\n\rNotAcceptable\x10\x96\x03\x12\x20\n\
    \x1bProxyAuthenticationRequired\x10\x97\x03\x12\x13\n\x0eRequestTimeout\
    \x10\x98\x03\x12\r\n\x08Conflict\x10\x99\x03\x12\t\n\x04Gone\x10\x9a\x03\
    \x12\x13\n\x0eLengthRequired\x10\x9b\x03\x12\x17\n\x12PreconditionFailed\
    \x10\x9c\x03\x12\x14\n\x0fPayloadTooLarge\x10\x9d\x03\x12\x0f\n\nURITooL\
    ong\x10\x9e\x03\x12\x19\n\x14UnsupportedMediaType\x10\x9f\x03\x12\x18\n\
    \x13RangeNotSatisfiable\x10\xa0\x03\x12\x16\n\x11ExpectationFailed\x10\
    \xa1\x03\x12\x17\n\x12MisdirectedRequest\x10\xa5\x03\x12\x18\n\x13Unproc\
    essableEntity\x10\xa6\x03\x12\x0b\n\x06Locked\x10\xa7\x03\x12\x15\n\x10F\
    ailedDependency\x10\xa8\x03\x12\x14\n\x0fUpgradeRequired\x10\xaa\x03\x12\
    \x19\n\x14PreconditionRequired\x10\xac\x03\x12\x14\n\x0fTooManyRequests\
    \x10\xad\x03\x12\x20\n\x1bRequestHeaderFieldsTooLarge\x10\xaf\x03\x12\
    \x18\n\x13InternalServerError\x10\xf4\x03\x12\x13\n\x0eNotImplemented\
    \x10\xf5\x03\x12\x0f\n\nBadGateway\x10\xf6\x03\x12\x17\n\x12ServiceUnava\
    ilable\x10\xf7\x03\x12\x13\n\x0eGatewayTimeout\x10\xf8\x03\x12\x1c\n\x17\
    HTTPVersionNotSupported\x10\xf9\x03\x12\x1a\n\x15VariantAlsoNegotiates\
    \x10\xfa\x03\x12\x18\n\x13InsufficientStorage\x10\xfb\x03\x12\x11\n\x0cL\
    oopDetected\x10\xfc\x03\x12\x10\n\x0bNotExtended\x10\xfe\x03\x12\"\n\x1d\
    NetworkAuthenticationRequired\x10\xff\x03B8\n\x1bio.envoyproxy.envoy.typ\
    e.v3B\x0fHttpStatusProtoP\x01\xba\x80\xc8\xd1\x06\x02\x10\x02b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
