// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `envoy/config/route/v3/route_components.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VirtualHost {
    // message fields
    pub name: ::std::string::String,
    pub domains: ::protobuf::RepeatedField<::std::string::String>,
    pub routes: ::protobuf::RepeatedField<Route>,
    pub matcher: ::protobuf::SingularPtrField<super::matcher::Matcher>,
    pub require_tls: VirtualHost_TlsRequirementType,
    pub virtual_clusters: ::protobuf::RepeatedField<VirtualCluster>,
    pub rate_limits: ::protobuf::RepeatedField<RateLimit>,
    pub request_headers_to_add: ::protobuf::RepeatedField<super::base::HeaderValueOption>,
    pub request_headers_to_remove: ::protobuf::RepeatedField<::std::string::String>,
    pub response_headers_to_add: ::protobuf::RepeatedField<super::base::HeaderValueOption>,
    pub response_headers_to_remove: ::protobuf::RepeatedField<::std::string::String>,
    pub cors: ::protobuf::SingularPtrField<CorsPolicy>,
    pub typed_per_filter_config: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>,
    pub include_request_attempt_count: bool,
    pub include_attempt_count_in_response: bool,
    pub retry_policy: ::protobuf::SingularPtrField<RetryPolicy>,
    pub retry_policy_typed_config: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub hedge_policy: ::protobuf::SingularPtrField<HedgePolicy>,
    pub per_request_buffer_limit_bytes: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualHost {
    fn default() -> &'a VirtualHost {
        <VirtualHost as ::protobuf::Message>::default_instance()
    }
}

impl VirtualHost {
    pub fn new() -> VirtualHost {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated string domains = 2;


    pub fn get_domains(&self) -> &[::std::string::String] {
        &self.domains
    }
    pub fn clear_domains(&mut self) {
        self.domains.clear();
    }

    // Param is passed by value, moved
    pub fn set_domains(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.domains = v;
    }

    // Mutable pointer to the field.
    pub fn mut_domains(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.domains
    }

    // Take field
    pub fn take_domains(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.domains, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.config.route.v3.Route routes = 3;


    pub fn get_routes(&self) -> &[Route] {
        &self.routes
    }
    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::protobuf::RepeatedField<Route>) {
        self.routes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routes(&mut self) -> &mut ::protobuf::RepeatedField<Route> {
        &mut self.routes
    }

    // Take field
    pub fn take_routes(&mut self) -> ::protobuf::RepeatedField<Route> {
        ::std::mem::replace(&mut self.routes, ::protobuf::RepeatedField::new())
    }

    // .xds.type.matcher.v3.Matcher matcher = 21;


    pub fn get_matcher(&self) -> &super::matcher::Matcher {
        self.matcher.as_ref().unwrap_or_else(|| <super::matcher::Matcher as ::protobuf::Message>::default_instance())
    }
    pub fn clear_matcher(&mut self) {
        self.matcher.clear();
    }

    pub fn has_matcher(&self) -> bool {
        self.matcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matcher(&mut self, v: super::matcher::Matcher) {
        self.matcher = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matcher(&mut self) -> &mut super::matcher::Matcher {
        if self.matcher.is_none() {
            self.matcher.set_default();
        }
        self.matcher.as_mut().unwrap()
    }

    // Take field
    pub fn take_matcher(&mut self) -> super::matcher::Matcher {
        self.matcher.take().unwrap_or_else(|| super::matcher::Matcher::new())
    }

    // .envoy.config.route.v3.VirtualHost.TlsRequirementType require_tls = 4;


    pub fn get_require_tls(&self) -> VirtualHost_TlsRequirementType {
        self.require_tls
    }
    pub fn clear_require_tls(&mut self) {
        self.require_tls = VirtualHost_TlsRequirementType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_require_tls(&mut self, v: VirtualHost_TlsRequirementType) {
        self.require_tls = v;
    }

    // repeated .envoy.config.route.v3.VirtualCluster virtual_clusters = 5;


    pub fn get_virtual_clusters(&self) -> &[VirtualCluster] {
        &self.virtual_clusters
    }
    pub fn clear_virtual_clusters(&mut self) {
        self.virtual_clusters.clear();
    }

    // Param is passed by value, moved
    pub fn set_virtual_clusters(&mut self, v: ::protobuf::RepeatedField<VirtualCluster>) {
        self.virtual_clusters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_virtual_clusters(&mut self) -> &mut ::protobuf::RepeatedField<VirtualCluster> {
        &mut self.virtual_clusters
    }

    // Take field
    pub fn take_virtual_clusters(&mut self) -> ::protobuf::RepeatedField<VirtualCluster> {
        ::std::mem::replace(&mut self.virtual_clusters, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.config.route.v3.RateLimit rate_limits = 6;


    pub fn get_rate_limits(&self) -> &[RateLimit] {
        &self.rate_limits
    }
    pub fn clear_rate_limits(&mut self) {
        self.rate_limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_rate_limits(&mut self, v: ::protobuf::RepeatedField<RateLimit>) {
        self.rate_limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rate_limits(&mut self) -> &mut ::protobuf::RepeatedField<RateLimit> {
        &mut self.rate_limits
    }

    // Take field
    pub fn take_rate_limits(&mut self) -> ::protobuf::RepeatedField<RateLimit> {
        ::std::mem::replace(&mut self.rate_limits, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 7;


    pub fn get_request_headers_to_add(&self) -> &[super::base::HeaderValueOption] {
        &self.request_headers_to_add
    }
    pub fn clear_request_headers_to_add(&mut self) {
        self.request_headers_to_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_headers_to_add(&mut self, v: ::protobuf::RepeatedField<super::base::HeaderValueOption>) {
        self.request_headers_to_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers_to_add(&mut self) -> &mut ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        &mut self.request_headers_to_add
    }

    // Take field
    pub fn take_request_headers_to_add(&mut self) -> ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        ::std::mem::replace(&mut self.request_headers_to_add, ::protobuf::RepeatedField::new())
    }

    // repeated string request_headers_to_remove = 13;


    pub fn get_request_headers_to_remove(&self) -> &[::std::string::String] {
        &self.request_headers_to_remove
    }
    pub fn clear_request_headers_to_remove(&mut self) {
        self.request_headers_to_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_headers_to_remove(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.request_headers_to_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers_to_remove(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.request_headers_to_remove
    }

    // Take field
    pub fn take_request_headers_to_remove(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.request_headers_to_remove, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.config.core.v3.HeaderValueOption response_headers_to_add = 10;


    pub fn get_response_headers_to_add(&self) -> &[super::base::HeaderValueOption] {
        &self.response_headers_to_add
    }
    pub fn clear_response_headers_to_add(&mut self) {
        self.response_headers_to_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_headers_to_add(&mut self, v: ::protobuf::RepeatedField<super::base::HeaderValueOption>) {
        self.response_headers_to_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response_headers_to_add(&mut self) -> &mut ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        &mut self.response_headers_to_add
    }

    // Take field
    pub fn take_response_headers_to_add(&mut self) -> ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        ::std::mem::replace(&mut self.response_headers_to_add, ::protobuf::RepeatedField::new())
    }

    // repeated string response_headers_to_remove = 11;


    pub fn get_response_headers_to_remove(&self) -> &[::std::string::String] {
        &self.response_headers_to_remove
    }
    pub fn clear_response_headers_to_remove(&mut self) {
        self.response_headers_to_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_headers_to_remove(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.response_headers_to_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response_headers_to_remove(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.response_headers_to_remove
    }

    // Take field
    pub fn take_response_headers_to_remove(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.response_headers_to_remove, ::protobuf::RepeatedField::new())
    }

    // .envoy.config.route.v3.CorsPolicy cors = 8;


    pub fn get_cors(&self) -> &CorsPolicy {
        self.cors.as_ref().unwrap_or_else(|| <CorsPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cors(&mut self) {
        self.cors.clear();
    }

    pub fn has_cors(&self) -> bool {
        self.cors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cors(&mut self, v: CorsPolicy) {
        self.cors = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cors(&mut self) -> &mut CorsPolicy {
        if self.cors.is_none() {
            self.cors.set_default();
        }
        self.cors.as_mut().unwrap()
    }

    // Take field
    pub fn take_cors(&mut self) -> CorsPolicy {
        self.cors.take().unwrap_or_else(|| CorsPolicy::new())
    }

    // repeated .envoy.config.route.v3.VirtualHost.TypedPerFilterConfigEntry typed_per_filter_config = 15;


    pub fn get_typed_per_filter_config(&self) -> &::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &self.typed_per_filter_config
    }
    pub fn clear_typed_per_filter_config(&mut self) {
        self.typed_per_filter_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_typed_per_filter_config(&mut self, v: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>) {
        self.typed_per_filter_config = v;
    }

    // Mutable pointer to the field.
    pub fn mut_typed_per_filter_config(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &mut self.typed_per_filter_config
    }

    // Take field
    pub fn take_typed_per_filter_config(&mut self) -> ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.typed_per_filter_config, ::std::collections::HashMap::new())
    }

    // bool include_request_attempt_count = 14;


    pub fn get_include_request_attempt_count(&self) -> bool {
        self.include_request_attempt_count
    }
    pub fn clear_include_request_attempt_count(&mut self) {
        self.include_request_attempt_count = false;
    }

    // Param is passed by value, moved
    pub fn set_include_request_attempt_count(&mut self, v: bool) {
        self.include_request_attempt_count = v;
    }

    // bool include_attempt_count_in_response = 19;


    pub fn get_include_attempt_count_in_response(&self) -> bool {
        self.include_attempt_count_in_response
    }
    pub fn clear_include_attempt_count_in_response(&mut self) {
        self.include_attempt_count_in_response = false;
    }

    // Param is passed by value, moved
    pub fn set_include_attempt_count_in_response(&mut self, v: bool) {
        self.include_attempt_count_in_response = v;
    }

    // .envoy.config.route.v3.RetryPolicy retry_policy = 16;


    pub fn get_retry_policy(&self) -> &RetryPolicy {
        self.retry_policy.as_ref().unwrap_or_else(|| <RetryPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_policy(&mut self) {
        self.retry_policy.clear();
    }

    pub fn has_retry_policy(&self) -> bool {
        self.retry_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_policy(&mut self, v: RetryPolicy) {
        self.retry_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_policy(&mut self) -> &mut RetryPolicy {
        if self.retry_policy.is_none() {
            self.retry_policy.set_default();
        }
        self.retry_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_policy(&mut self) -> RetryPolicy {
        self.retry_policy.take().unwrap_or_else(|| RetryPolicy::new())
    }

    // .google.protobuf.Any retry_policy_typed_config = 20;


    pub fn get_retry_policy_typed_config(&self) -> &::protobuf::well_known_types::Any {
        self.retry_policy_typed_config.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_policy_typed_config(&mut self) {
        self.retry_policy_typed_config.clear();
    }

    pub fn has_retry_policy_typed_config(&self) -> bool {
        self.retry_policy_typed_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_policy_typed_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.retry_policy_typed_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_policy_typed_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.retry_policy_typed_config.is_none() {
            self.retry_policy_typed_config.set_default();
        }
        self.retry_policy_typed_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_policy_typed_config(&mut self) -> ::protobuf::well_known_types::Any {
        self.retry_policy_typed_config.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .envoy.config.route.v3.HedgePolicy hedge_policy = 17;


    pub fn get_hedge_policy(&self) -> &HedgePolicy {
        self.hedge_policy.as_ref().unwrap_or_else(|| <HedgePolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hedge_policy(&mut self) {
        self.hedge_policy.clear();
    }

    pub fn has_hedge_policy(&self) -> bool {
        self.hedge_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hedge_policy(&mut self, v: HedgePolicy) {
        self.hedge_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hedge_policy(&mut self) -> &mut HedgePolicy {
        if self.hedge_policy.is_none() {
            self.hedge_policy.set_default();
        }
        self.hedge_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_hedge_policy(&mut self) -> HedgePolicy {
        self.hedge_policy.take().unwrap_or_else(|| HedgePolicy::new())
    }

    // .google.protobuf.UInt32Value per_request_buffer_limit_bytes = 18;


    pub fn get_per_request_buffer_limit_bytes(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.per_request_buffer_limit_bytes.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_per_request_buffer_limit_bytes(&mut self) {
        self.per_request_buffer_limit_bytes.clear();
    }

    pub fn has_per_request_buffer_limit_bytes(&self) -> bool {
        self.per_request_buffer_limit_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_per_request_buffer_limit_bytes(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.per_request_buffer_limit_bytes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_per_request_buffer_limit_bytes(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.per_request_buffer_limit_bytes.is_none() {
            self.per_request_buffer_limit_bytes.set_default();
        }
        self.per_request_buffer_limit_bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_per_request_buffer_limit_bytes(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.per_request_buffer_limit_bytes.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }
}

impl ::protobuf::Message for VirtualHost {
    fn is_initialized(&self) -> bool {
        for v in &self.routes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.matcher {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.virtual_clusters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rate_limits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request_headers_to_add {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.response_headers_to_add {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_policy_typed_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hedge_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.per_request_buffer_limit_bytes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.domains)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.routes)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.matcher)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.require_tls, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.virtual_clusters)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rate_limits)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.request_headers_to_add)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.request_headers_to_remove)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.response_headers_to_add)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.response_headers_to_remove)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cors)?;
                },
                15 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(wire_type, is, &mut self.typed_per_filter_config)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_request_attempt_count = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_attempt_count_in_response = tmp;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_policy)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_policy_typed_config)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hedge_policy)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.per_request_buffer_limit_bytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.domains {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.matcher.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.require_tls != VirtualHost_TlsRequirementType::NONE {
            my_size += ::protobuf::rt::enum_size(4, self.require_tls);
        }
        for value in &self.virtual_clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.rate_limits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.request_headers_to_add {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.request_headers_to_remove {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        for value in &self.response_headers_to_add {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.response_headers_to_remove {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if let Some(ref v) = self.cors.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(15, &self.typed_per_filter_config);
        if self.include_request_attempt_count != false {
            my_size += 2;
        }
        if self.include_attempt_count_in_response != false {
            my_size += 3;
        }
        if let Some(ref v) = self.retry_policy.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.retry_policy_typed_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hedge_policy.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.per_request_buffer_limit_bytes.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.domains {
            os.write_string(2, &v)?;
        };
        for v in &self.routes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.matcher.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.require_tls != VirtualHost_TlsRequirementType::NONE {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.require_tls))?;
        }
        for v in &self.virtual_clusters {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.rate_limits {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.request_headers_to_add {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.request_headers_to_remove {
            os.write_string(13, &v)?;
        };
        for v in &self.response_headers_to_add {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.response_headers_to_remove {
            os.write_string(11, &v)?;
        };
        if let Some(ref v) = self.cors.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(15, &self.typed_per_filter_config, os)?;
        if self.include_request_attempt_count != false {
            os.write_bool(14, self.include_request_attempt_count)?;
        }
        if self.include_attempt_count_in_response != false {
            os.write_bool(19, self.include_attempt_count_in_response)?;
        }
        if let Some(ref v) = self.retry_policy.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.retry_policy_typed_config.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hedge_policy.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.per_request_buffer_limit_bytes.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualHost {
        VirtualHost::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &VirtualHost| { &m.name },
                |m: &mut VirtualHost| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "domains",
                |m: &VirtualHost| { &m.domains },
                |m: &mut VirtualHost| { &mut m.domains },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Route>>(
                "routes",
                |m: &VirtualHost| { &m.routes },
                |m: &mut VirtualHost| { &mut m.routes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::matcher::Matcher>>(
                "matcher",
                |m: &VirtualHost| { &m.matcher },
                |m: &mut VirtualHost| { &mut m.matcher },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VirtualHost_TlsRequirementType>>(
                "require_tls",
                |m: &VirtualHost| { &m.require_tls },
                |m: &mut VirtualHost| { &mut m.require_tls },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualCluster>>(
                "virtual_clusters",
                |m: &VirtualHost| { &m.virtual_clusters },
                |m: &mut VirtualHost| { &mut m.virtual_clusters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateLimit>>(
                "rate_limits",
                |m: &VirtualHost| { &m.rate_limits },
                |m: &mut VirtualHost| { &mut m.rate_limits },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderValueOption>>(
                "request_headers_to_add",
                |m: &VirtualHost| { &m.request_headers_to_add },
                |m: &mut VirtualHost| { &mut m.request_headers_to_add },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "request_headers_to_remove",
                |m: &VirtualHost| { &m.request_headers_to_remove },
                |m: &mut VirtualHost| { &mut m.request_headers_to_remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderValueOption>>(
                "response_headers_to_add",
                |m: &VirtualHost| { &m.response_headers_to_add },
                |m: &mut VirtualHost| { &mut m.response_headers_to_add },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "response_headers_to_remove",
                |m: &VirtualHost| { &m.response_headers_to_remove },
                |m: &mut VirtualHost| { &mut m.response_headers_to_remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CorsPolicy>>(
                "cors",
                |m: &VirtualHost| { &m.cors },
                |m: &mut VirtualHost| { &mut m.cors },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "typed_per_filter_config",
                |m: &VirtualHost| { &m.typed_per_filter_config },
                |m: &mut VirtualHost| { &mut m.typed_per_filter_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_request_attempt_count",
                |m: &VirtualHost| { &m.include_request_attempt_count },
                |m: &mut VirtualHost| { &mut m.include_request_attempt_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_attempt_count_in_response",
                |m: &VirtualHost| { &m.include_attempt_count_in_response },
                |m: &mut VirtualHost| { &mut m.include_attempt_count_in_response },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RetryPolicy>>(
                "retry_policy",
                |m: &VirtualHost| { &m.retry_policy },
                |m: &mut VirtualHost| { &mut m.retry_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "retry_policy_typed_config",
                |m: &VirtualHost| { &m.retry_policy_typed_config },
                |m: &mut VirtualHost| { &mut m.retry_policy_typed_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HedgePolicy>>(
                "hedge_policy",
                |m: &VirtualHost| { &m.hedge_policy },
                |m: &mut VirtualHost| { &mut m.hedge_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "per_request_buffer_limit_bytes",
                |m: &VirtualHost| { &m.per_request_buffer_limit_bytes },
                |m: &mut VirtualHost| { &mut m.per_request_buffer_limit_bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualHost>(
                "VirtualHost",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualHost {
        static instance: ::protobuf::rt::LazyV2<VirtualHost> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualHost::new)
    }
}

impl ::protobuf::Clear for VirtualHost {
    fn clear(&mut self) {
        self.name.clear();
        self.domains.clear();
        self.routes.clear();
        self.matcher.clear();
        self.require_tls = VirtualHost_TlsRequirementType::NONE;
        self.virtual_clusters.clear();
        self.rate_limits.clear();
        self.request_headers_to_add.clear();
        self.request_headers_to_remove.clear();
        self.response_headers_to_add.clear();
        self.response_headers_to_remove.clear();
        self.cors.clear();
        self.typed_per_filter_config.clear();
        self.include_request_attempt_count = false;
        self.include_attempt_count_in_response = false;
        self.retry_policy.clear();
        self.retry_policy_typed_config.clear();
        self.hedge_policy.clear();
        self.per_request_buffer_limit_bytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualHost {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualHost {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum VirtualHost_TlsRequirementType {
    NONE = 0,
    EXTERNAL_ONLY = 1,
    ALL = 2,
}

impl ::protobuf::ProtobufEnum for VirtualHost_TlsRequirementType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VirtualHost_TlsRequirementType> {
        match value {
            0 => ::std::option::Option::Some(VirtualHost_TlsRequirementType::NONE),
            1 => ::std::option::Option::Some(VirtualHost_TlsRequirementType::EXTERNAL_ONLY),
            2 => ::std::option::Option::Some(VirtualHost_TlsRequirementType::ALL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [VirtualHost_TlsRequirementType] = &[
            VirtualHost_TlsRequirementType::NONE,
            VirtualHost_TlsRequirementType::EXTERNAL_ONLY,
            VirtualHost_TlsRequirementType::ALL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<VirtualHost_TlsRequirementType>("VirtualHost.TlsRequirementType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for VirtualHost_TlsRequirementType {
}

impl ::std::default::Default for VirtualHost_TlsRequirementType {
    fn default() -> Self {
        VirtualHost_TlsRequirementType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualHost_TlsRequirementType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FilterAction {
    // message fields
    pub action: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilterAction {
    fn default() -> &'a FilterAction {
        <FilterAction as ::protobuf::Message>::default_instance()
    }
}

impl FilterAction {
    pub fn new() -> FilterAction {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any action = 1;


    pub fn get_action(&self) -> &::protobuf::well_known_types::Any {
        self.action.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::protobuf::well_known_types::Any) {
        self.action = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.action.is_none() {
            self.action.set_default();
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> ::protobuf::well_known_types::Any {
        self.action.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for FilterAction {
    fn is_initialized(&self) -> bool {
        for v in &self.action {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.action.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilterAction {
        FilterAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "action",
                |m: &FilterAction| { &m.action },
                |m: &mut FilterAction| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FilterAction>(
                "FilterAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FilterAction {
        static instance: ::protobuf::rt::LazyV2<FilterAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FilterAction::new)
    }
}

impl ::protobuf::Clear for FilterAction {
    fn clear(&mut self) {
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilterAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilterAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Route {
    // message fields
    pub name: ::std::string::String,
    pub field_match: ::protobuf::SingularPtrField<RouteMatch>,
    pub metadata: ::protobuf::SingularPtrField<super::base::Metadata>,
    pub decorator: ::protobuf::SingularPtrField<Decorator>,
    pub typed_per_filter_config: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>,
    pub request_headers_to_add: ::protobuf::RepeatedField<super::base::HeaderValueOption>,
    pub request_headers_to_remove: ::protobuf::RepeatedField<::std::string::String>,
    pub response_headers_to_add: ::protobuf::RepeatedField<super::base::HeaderValueOption>,
    pub response_headers_to_remove: ::protobuf::RepeatedField<::std::string::String>,
    pub tracing: ::protobuf::SingularPtrField<Tracing>,
    pub per_request_buffer_limit_bytes: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    // message oneof groups
    pub action: ::std::option::Option<Route_oneof_action>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Route {
    fn default() -> &'a Route {
        <Route as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Route_oneof_action {
    route(RouteAction),
    redirect(RedirectAction),
    direct_response(DirectResponseAction),
    filter_action(FilterAction),
    non_forwarding_action(NonForwardingAction),
}

impl Route {
    pub fn new() -> Route {
        ::std::default::Default::default()
    }

    // string name = 14;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .envoy.config.route.v3.RouteMatch match = 1;


    pub fn get_field_match(&self) -> &RouteMatch {
        self.field_match.as_ref().unwrap_or_else(|| <RouteMatch as ::protobuf::Message>::default_instance())
    }
    pub fn clear_field_match(&mut self) {
        self.field_match.clear();
    }

    pub fn has_field_match(&self) -> bool {
        self.field_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_match(&mut self, v: RouteMatch) {
        self.field_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_match(&mut self) -> &mut RouteMatch {
        if self.field_match.is_none() {
            self.field_match.set_default();
        }
        self.field_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_match(&mut self) -> RouteMatch {
        self.field_match.take().unwrap_or_else(|| RouteMatch::new())
    }

    // .envoy.config.route.v3.RouteAction route = 2;


    pub fn get_route(&self) -> &RouteAction {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::route(ref v)) => v,
            _ => <RouteAction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_route(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_route(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::route(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_route(&mut self, v: RouteAction) {
        self.action = ::std::option::Option::Some(Route_oneof_action::route(v))
    }

    // Mutable pointer to the field.
    pub fn mut_route(&mut self) -> &mut RouteAction {
        if let ::std::option::Option::Some(Route_oneof_action::route(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Route_oneof_action::route(RouteAction::new()));
        }
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::route(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_route(&mut self) -> RouteAction {
        if self.has_route() {
            match self.action.take() {
                ::std::option::Option::Some(Route_oneof_action::route(v)) => v,
                _ => panic!(),
            }
        } else {
            RouteAction::new()
        }
    }

    // .envoy.config.route.v3.RedirectAction redirect = 3;


    pub fn get_redirect(&self) -> &RedirectAction {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::redirect(ref v)) => v,
            _ => <RedirectAction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_redirect(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_redirect(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::redirect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_redirect(&mut self, v: RedirectAction) {
        self.action = ::std::option::Option::Some(Route_oneof_action::redirect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_redirect(&mut self) -> &mut RedirectAction {
        if let ::std::option::Option::Some(Route_oneof_action::redirect(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Route_oneof_action::redirect(RedirectAction::new()));
        }
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::redirect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_redirect(&mut self) -> RedirectAction {
        if self.has_redirect() {
            match self.action.take() {
                ::std::option::Option::Some(Route_oneof_action::redirect(v)) => v,
                _ => panic!(),
            }
        } else {
            RedirectAction::new()
        }
    }

    // .envoy.config.route.v3.DirectResponseAction direct_response = 7;


    pub fn get_direct_response(&self) -> &DirectResponseAction {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::direct_response(ref v)) => v,
            _ => <DirectResponseAction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_direct_response(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_direct_response(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::direct_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_direct_response(&mut self, v: DirectResponseAction) {
        self.action = ::std::option::Option::Some(Route_oneof_action::direct_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_direct_response(&mut self) -> &mut DirectResponseAction {
        if let ::std::option::Option::Some(Route_oneof_action::direct_response(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Route_oneof_action::direct_response(DirectResponseAction::new()));
        }
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::direct_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_direct_response(&mut self) -> DirectResponseAction {
        if self.has_direct_response() {
            match self.action.take() {
                ::std::option::Option::Some(Route_oneof_action::direct_response(v)) => v,
                _ => panic!(),
            }
        } else {
            DirectResponseAction::new()
        }
    }

    // .envoy.config.route.v3.FilterAction filter_action = 17;


    pub fn get_filter_action(&self) -> &FilterAction {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::filter_action(ref v)) => v,
            _ => <FilterAction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_filter_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_filter_action(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::filter_action(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_filter_action(&mut self, v: FilterAction) {
        self.action = ::std::option::Option::Some(Route_oneof_action::filter_action(v))
    }

    // Mutable pointer to the field.
    pub fn mut_filter_action(&mut self) -> &mut FilterAction {
        if let ::std::option::Option::Some(Route_oneof_action::filter_action(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Route_oneof_action::filter_action(FilterAction::new()));
        }
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::filter_action(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_filter_action(&mut self) -> FilterAction {
        if self.has_filter_action() {
            match self.action.take() {
                ::std::option::Option::Some(Route_oneof_action::filter_action(v)) => v,
                _ => panic!(),
            }
        } else {
            FilterAction::new()
        }
    }

    // .envoy.config.route.v3.NonForwardingAction non_forwarding_action = 18;


    pub fn get_non_forwarding_action(&self) -> &NonForwardingAction {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::non_forwarding_action(ref v)) => v,
            _ => <NonForwardingAction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_non_forwarding_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_non_forwarding_action(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::non_forwarding_action(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_non_forwarding_action(&mut self, v: NonForwardingAction) {
        self.action = ::std::option::Option::Some(Route_oneof_action::non_forwarding_action(v))
    }

    // Mutable pointer to the field.
    pub fn mut_non_forwarding_action(&mut self) -> &mut NonForwardingAction {
        if let ::std::option::Option::Some(Route_oneof_action::non_forwarding_action(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Route_oneof_action::non_forwarding_action(NonForwardingAction::new()));
        }
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::non_forwarding_action(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_non_forwarding_action(&mut self) -> NonForwardingAction {
        if self.has_non_forwarding_action() {
            match self.action.take() {
                ::std::option::Option::Some(Route_oneof_action::non_forwarding_action(v)) => v,
                _ => panic!(),
            }
        } else {
            NonForwardingAction::new()
        }
    }

    // .envoy.config.core.v3.Metadata metadata = 4;


    pub fn get_metadata(&self) -> &super::base::Metadata {
        self.metadata.as_ref().unwrap_or_else(|| <super::base::Metadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::base::Metadata) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::base::Metadata {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::base::Metadata {
        self.metadata.take().unwrap_or_else(|| super::base::Metadata::new())
    }

    // .envoy.config.route.v3.Decorator decorator = 5;


    pub fn get_decorator(&self) -> &Decorator {
        self.decorator.as_ref().unwrap_or_else(|| <Decorator as ::protobuf::Message>::default_instance())
    }
    pub fn clear_decorator(&mut self) {
        self.decorator.clear();
    }

    pub fn has_decorator(&self) -> bool {
        self.decorator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decorator(&mut self, v: Decorator) {
        self.decorator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decorator(&mut self) -> &mut Decorator {
        if self.decorator.is_none() {
            self.decorator.set_default();
        }
        self.decorator.as_mut().unwrap()
    }

    // Take field
    pub fn take_decorator(&mut self) -> Decorator {
        self.decorator.take().unwrap_or_else(|| Decorator::new())
    }

    // repeated .envoy.config.route.v3.Route.TypedPerFilterConfigEntry typed_per_filter_config = 13;


    pub fn get_typed_per_filter_config(&self) -> &::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &self.typed_per_filter_config
    }
    pub fn clear_typed_per_filter_config(&mut self) {
        self.typed_per_filter_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_typed_per_filter_config(&mut self, v: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>) {
        self.typed_per_filter_config = v;
    }

    // Mutable pointer to the field.
    pub fn mut_typed_per_filter_config(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &mut self.typed_per_filter_config
    }

    // Take field
    pub fn take_typed_per_filter_config(&mut self) -> ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.typed_per_filter_config, ::std::collections::HashMap::new())
    }

    // repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 9;


    pub fn get_request_headers_to_add(&self) -> &[super::base::HeaderValueOption] {
        &self.request_headers_to_add
    }
    pub fn clear_request_headers_to_add(&mut self) {
        self.request_headers_to_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_headers_to_add(&mut self, v: ::protobuf::RepeatedField<super::base::HeaderValueOption>) {
        self.request_headers_to_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers_to_add(&mut self) -> &mut ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        &mut self.request_headers_to_add
    }

    // Take field
    pub fn take_request_headers_to_add(&mut self) -> ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        ::std::mem::replace(&mut self.request_headers_to_add, ::protobuf::RepeatedField::new())
    }

    // repeated string request_headers_to_remove = 12;


    pub fn get_request_headers_to_remove(&self) -> &[::std::string::String] {
        &self.request_headers_to_remove
    }
    pub fn clear_request_headers_to_remove(&mut self) {
        self.request_headers_to_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_headers_to_remove(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.request_headers_to_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers_to_remove(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.request_headers_to_remove
    }

    // Take field
    pub fn take_request_headers_to_remove(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.request_headers_to_remove, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.config.core.v3.HeaderValueOption response_headers_to_add = 10;


    pub fn get_response_headers_to_add(&self) -> &[super::base::HeaderValueOption] {
        &self.response_headers_to_add
    }
    pub fn clear_response_headers_to_add(&mut self) {
        self.response_headers_to_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_headers_to_add(&mut self, v: ::protobuf::RepeatedField<super::base::HeaderValueOption>) {
        self.response_headers_to_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response_headers_to_add(&mut self) -> &mut ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        &mut self.response_headers_to_add
    }

    // Take field
    pub fn take_response_headers_to_add(&mut self) -> ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        ::std::mem::replace(&mut self.response_headers_to_add, ::protobuf::RepeatedField::new())
    }

    // repeated string response_headers_to_remove = 11;


    pub fn get_response_headers_to_remove(&self) -> &[::std::string::String] {
        &self.response_headers_to_remove
    }
    pub fn clear_response_headers_to_remove(&mut self) {
        self.response_headers_to_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_headers_to_remove(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.response_headers_to_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response_headers_to_remove(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.response_headers_to_remove
    }

    // Take field
    pub fn take_response_headers_to_remove(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.response_headers_to_remove, ::protobuf::RepeatedField::new())
    }

    // .envoy.config.route.v3.Tracing tracing = 15;


    pub fn get_tracing(&self) -> &Tracing {
        self.tracing.as_ref().unwrap_or_else(|| <Tracing as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tracing(&mut self) {
        self.tracing.clear();
    }

    pub fn has_tracing(&self) -> bool {
        self.tracing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tracing(&mut self, v: Tracing) {
        self.tracing = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tracing(&mut self) -> &mut Tracing {
        if self.tracing.is_none() {
            self.tracing.set_default();
        }
        self.tracing.as_mut().unwrap()
    }

    // Take field
    pub fn take_tracing(&mut self) -> Tracing {
        self.tracing.take().unwrap_or_else(|| Tracing::new())
    }

    // .google.protobuf.UInt32Value per_request_buffer_limit_bytes = 16;


    pub fn get_per_request_buffer_limit_bytes(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.per_request_buffer_limit_bytes.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_per_request_buffer_limit_bytes(&mut self) {
        self.per_request_buffer_limit_bytes.clear();
    }

    pub fn has_per_request_buffer_limit_bytes(&self) -> bool {
        self.per_request_buffer_limit_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_per_request_buffer_limit_bytes(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.per_request_buffer_limit_bytes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_per_request_buffer_limit_bytes(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.per_request_buffer_limit_bytes.is_none() {
            self.per_request_buffer_limit_bytes.set_default();
        }
        self.per_request_buffer_limit_bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_per_request_buffer_limit_bytes(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.per_request_buffer_limit_bytes.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }
}

impl ::protobuf::Message for Route {
    fn is_initialized(&self) -> bool {
        for v in &self.field_match {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Route_oneof_action::route(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Route_oneof_action::redirect(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Route_oneof_action::direct_response(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Route_oneof_action::filter_action(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Route_oneof_action::non_forwarding_action(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.decorator {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request_headers_to_add {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.response_headers_to_add {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tracing {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.per_request_buffer_limit_bytes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_match)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Route_oneof_action::route(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Route_oneof_action::redirect(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Route_oneof_action::direct_response(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Route_oneof_action::filter_action(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Route_oneof_action::non_forwarding_action(is.read_message()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.decorator)?;
                },
                13 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(wire_type, is, &mut self.typed_per_filter_config)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.request_headers_to_add)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.request_headers_to_remove)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.response_headers_to_add)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.response_headers_to_remove)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tracing)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.per_request_buffer_limit_bytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.name);
        }
        if let Some(ref v) = self.field_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.decorator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(13, &self.typed_per_filter_config);
        for value in &self.request_headers_to_add {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.request_headers_to_remove {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        for value in &self.response_headers_to_add {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.response_headers_to_remove {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if let Some(ref v) = self.tracing.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.per_request_buffer_limit_bytes.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &Route_oneof_action::route(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Route_oneof_action::redirect(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Route_oneof_action::direct_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Route_oneof_action::filter_action(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Route_oneof_action::non_forwarding_action(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(14, &self.name)?;
        }
        if let Some(ref v) = self.field_match.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.decorator.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(13, &self.typed_per_filter_config, os)?;
        for v in &self.request_headers_to_add {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.request_headers_to_remove {
            os.write_string(12, &v)?;
        };
        for v in &self.response_headers_to_add {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.response_headers_to_remove {
            os.write_string(11, &v)?;
        };
        if let Some(ref v) = self.tracing.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.per_request_buffer_limit_bytes.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &Route_oneof_action::route(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Route_oneof_action::redirect(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Route_oneof_action::direct_response(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Route_oneof_action::filter_action(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Route_oneof_action::non_forwarding_action(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Route {
        Route::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Route| { &m.name },
                |m: &mut Route| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteMatch>>(
                "match",
                |m: &Route| { &m.field_match },
                |m: &mut Route| { &mut m.field_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RouteAction>(
                "route",
                Route::has_route,
                Route::get_route,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RedirectAction>(
                "redirect",
                Route::has_redirect,
                Route::get_redirect,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DirectResponseAction>(
                "direct_response",
                Route::has_direct_response,
                Route::get_direct_response,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FilterAction>(
                "filter_action",
                Route::has_filter_action,
                Route::get_filter_action,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, NonForwardingAction>(
                "non_forwarding_action",
                Route::has_non_forwarding_action,
                Route::get_non_forwarding_action,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::Metadata>>(
                "metadata",
                |m: &Route| { &m.metadata },
                |m: &mut Route| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decorator>>(
                "decorator",
                |m: &Route| { &m.decorator },
                |m: &mut Route| { &mut m.decorator },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "typed_per_filter_config",
                |m: &Route| { &m.typed_per_filter_config },
                |m: &mut Route| { &mut m.typed_per_filter_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderValueOption>>(
                "request_headers_to_add",
                |m: &Route| { &m.request_headers_to_add },
                |m: &mut Route| { &mut m.request_headers_to_add },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "request_headers_to_remove",
                |m: &Route| { &m.request_headers_to_remove },
                |m: &mut Route| { &mut m.request_headers_to_remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderValueOption>>(
                "response_headers_to_add",
                |m: &Route| { &m.response_headers_to_add },
                |m: &mut Route| { &mut m.response_headers_to_add },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "response_headers_to_remove",
                |m: &Route| { &m.response_headers_to_remove },
                |m: &mut Route| { &mut m.response_headers_to_remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Tracing>>(
                "tracing",
                |m: &Route| { &m.tracing },
                |m: &mut Route| { &mut m.tracing },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "per_request_buffer_limit_bytes",
                |m: &Route| { &m.per_request_buffer_limit_bytes },
                |m: &mut Route| { &mut m.per_request_buffer_limit_bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Route>(
                "Route",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Route {
        static instance: ::protobuf::rt::LazyV2<Route> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Route::new)
    }
}

impl ::protobuf::Clear for Route {
    fn clear(&mut self) {
        self.name.clear();
        self.field_match.clear();
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.metadata.clear();
        self.decorator.clear();
        self.typed_per_filter_config.clear();
        self.request_headers_to_add.clear();
        self.request_headers_to_remove.clear();
        self.response_headers_to_add.clear();
        self.response_headers_to_remove.clear();
        self.tracing.clear();
        self.per_request_buffer_limit_bytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Route {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Route {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct WeightedCluster {
    // message fields
    pub clusters: ::protobuf::RepeatedField<WeightedCluster_ClusterWeight>,
    pub total_weight: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub runtime_key_prefix: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WeightedCluster {
    fn default() -> &'a WeightedCluster {
        <WeightedCluster as ::protobuf::Message>::default_instance()
    }
}

impl WeightedCluster {
    pub fn new() -> WeightedCluster {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.route.v3.WeightedCluster.ClusterWeight clusters = 1;


    pub fn get_clusters(&self) -> &[WeightedCluster_ClusterWeight] {
        &self.clusters
    }
    pub fn clear_clusters(&mut self) {
        self.clusters.clear();
    }

    // Param is passed by value, moved
    pub fn set_clusters(&mut self, v: ::protobuf::RepeatedField<WeightedCluster_ClusterWeight>) {
        self.clusters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clusters(&mut self) -> &mut ::protobuf::RepeatedField<WeightedCluster_ClusterWeight> {
        &mut self.clusters
    }

    // Take field
    pub fn take_clusters(&mut self) -> ::protobuf::RepeatedField<WeightedCluster_ClusterWeight> {
        ::std::mem::replace(&mut self.clusters, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.UInt32Value total_weight = 3;


    pub fn get_total_weight(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.total_weight.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_total_weight(&mut self) {
        self.total_weight.clear();
    }

    pub fn has_total_weight(&self) -> bool {
        self.total_weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_weight(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.total_weight = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_total_weight(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.total_weight.is_none() {
            self.total_weight.set_default();
        }
        self.total_weight.as_mut().unwrap()
    }

    // Take field
    pub fn take_total_weight(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.total_weight.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // string runtime_key_prefix = 2;


    pub fn get_runtime_key_prefix(&self) -> &str {
        &self.runtime_key_prefix
    }
    pub fn clear_runtime_key_prefix(&mut self) {
        self.runtime_key_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_runtime_key_prefix(&mut self, v: ::std::string::String) {
        self.runtime_key_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_key_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.runtime_key_prefix
    }

    // Take field
    pub fn take_runtime_key_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.runtime_key_prefix, ::std::string::String::new())
    }
}

impl ::protobuf::Message for WeightedCluster {
    fn is_initialized(&self) -> bool {
        for v in &self.clusters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.total_weight {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.clusters)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.total_weight)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.runtime_key_prefix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.total_weight.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.runtime_key_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runtime_key_prefix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.clusters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.total_weight.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.runtime_key_prefix.is_empty() {
            os.write_string(2, &self.runtime_key_prefix)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WeightedCluster {
        WeightedCluster::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WeightedCluster_ClusterWeight>>(
                "clusters",
                |m: &WeightedCluster| { &m.clusters },
                |m: &mut WeightedCluster| { &mut m.clusters },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "total_weight",
                |m: &WeightedCluster| { &m.total_weight },
                |m: &mut WeightedCluster| { &mut m.total_weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "runtime_key_prefix",
                |m: &WeightedCluster| { &m.runtime_key_prefix },
                |m: &mut WeightedCluster| { &mut m.runtime_key_prefix },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WeightedCluster>(
                "WeightedCluster",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WeightedCluster {
        static instance: ::protobuf::rt::LazyV2<WeightedCluster> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WeightedCluster::new)
    }
}

impl ::protobuf::Clear for WeightedCluster {
    fn clear(&mut self) {
        self.clusters.clear();
        self.total_weight.clear();
        self.runtime_key_prefix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WeightedCluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WeightedCluster {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct WeightedCluster_ClusterWeight {
    // message fields
    pub name: ::std::string::String,
    pub cluster_header: ::std::string::String,
    pub weight: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub metadata_match: ::protobuf::SingularPtrField<super::base::Metadata>,
    pub request_headers_to_add: ::protobuf::RepeatedField<super::base::HeaderValueOption>,
    pub request_headers_to_remove: ::protobuf::RepeatedField<::std::string::String>,
    pub response_headers_to_add: ::protobuf::RepeatedField<super::base::HeaderValueOption>,
    pub response_headers_to_remove: ::protobuf::RepeatedField<::std::string::String>,
    pub typed_per_filter_config: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>,
    // message oneof groups
    pub host_rewrite_specifier: ::std::option::Option<WeightedCluster_ClusterWeight_oneof_host_rewrite_specifier>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WeightedCluster_ClusterWeight {
    fn default() -> &'a WeightedCluster_ClusterWeight {
        <WeightedCluster_ClusterWeight as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum WeightedCluster_ClusterWeight_oneof_host_rewrite_specifier {
    host_rewrite_literal(::std::string::String),
}

impl WeightedCluster_ClusterWeight {
    pub fn new() -> WeightedCluster_ClusterWeight {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string cluster_header = 12;


    pub fn get_cluster_header(&self) -> &str {
        &self.cluster_header
    }
    pub fn clear_cluster_header(&mut self) {
        self.cluster_header.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_header(&mut self, v: ::std::string::String) {
        self.cluster_header = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_header(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_header
    }

    // Take field
    pub fn take_cluster_header(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_header, ::std::string::String::new())
    }

    // .google.protobuf.UInt32Value weight = 2;


    pub fn get_weight(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.weight.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_weight(&mut self) {
        self.weight.clear();
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.weight = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_weight(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.weight.is_none() {
            self.weight.set_default();
        }
        self.weight.as_mut().unwrap()
    }

    // Take field
    pub fn take_weight(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.weight.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // .envoy.config.core.v3.Metadata metadata_match = 3;


    pub fn get_metadata_match(&self) -> &super::base::Metadata {
        self.metadata_match.as_ref().unwrap_or_else(|| <super::base::Metadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata_match(&mut self) {
        self.metadata_match.clear();
    }

    pub fn has_metadata_match(&self) -> bool {
        self.metadata_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata_match(&mut self, v: super::base::Metadata) {
        self.metadata_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata_match(&mut self) -> &mut super::base::Metadata {
        if self.metadata_match.is_none() {
            self.metadata_match.set_default();
        }
        self.metadata_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata_match(&mut self) -> super::base::Metadata {
        self.metadata_match.take().unwrap_or_else(|| super::base::Metadata::new())
    }

    // repeated .envoy.config.core.v3.HeaderValueOption request_headers_to_add = 4;


    pub fn get_request_headers_to_add(&self) -> &[super::base::HeaderValueOption] {
        &self.request_headers_to_add
    }
    pub fn clear_request_headers_to_add(&mut self) {
        self.request_headers_to_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_headers_to_add(&mut self, v: ::protobuf::RepeatedField<super::base::HeaderValueOption>) {
        self.request_headers_to_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers_to_add(&mut self) -> &mut ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        &mut self.request_headers_to_add
    }

    // Take field
    pub fn take_request_headers_to_add(&mut self) -> ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        ::std::mem::replace(&mut self.request_headers_to_add, ::protobuf::RepeatedField::new())
    }

    // repeated string request_headers_to_remove = 9;


    pub fn get_request_headers_to_remove(&self) -> &[::std::string::String] {
        &self.request_headers_to_remove
    }
    pub fn clear_request_headers_to_remove(&mut self) {
        self.request_headers_to_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_headers_to_remove(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.request_headers_to_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers_to_remove(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.request_headers_to_remove
    }

    // Take field
    pub fn take_request_headers_to_remove(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.request_headers_to_remove, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.config.core.v3.HeaderValueOption response_headers_to_add = 5;


    pub fn get_response_headers_to_add(&self) -> &[super::base::HeaderValueOption] {
        &self.response_headers_to_add
    }
    pub fn clear_response_headers_to_add(&mut self) {
        self.response_headers_to_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_headers_to_add(&mut self, v: ::protobuf::RepeatedField<super::base::HeaderValueOption>) {
        self.response_headers_to_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response_headers_to_add(&mut self) -> &mut ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        &mut self.response_headers_to_add
    }

    // Take field
    pub fn take_response_headers_to_add(&mut self) -> ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        ::std::mem::replace(&mut self.response_headers_to_add, ::protobuf::RepeatedField::new())
    }

    // repeated string response_headers_to_remove = 6;


    pub fn get_response_headers_to_remove(&self) -> &[::std::string::String] {
        &self.response_headers_to_remove
    }
    pub fn clear_response_headers_to_remove(&mut self) {
        self.response_headers_to_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_headers_to_remove(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.response_headers_to_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response_headers_to_remove(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.response_headers_to_remove
    }

    // Take field
    pub fn take_response_headers_to_remove(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.response_headers_to_remove, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.config.route.v3.WeightedCluster.ClusterWeight.TypedPerFilterConfigEntry typed_per_filter_config = 10;


    pub fn get_typed_per_filter_config(&self) -> &::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &self.typed_per_filter_config
    }
    pub fn clear_typed_per_filter_config(&mut self) {
        self.typed_per_filter_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_typed_per_filter_config(&mut self, v: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>) {
        self.typed_per_filter_config = v;
    }

    // Mutable pointer to the field.
    pub fn mut_typed_per_filter_config(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &mut self.typed_per_filter_config
    }

    // Take field
    pub fn take_typed_per_filter_config(&mut self) -> ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.typed_per_filter_config, ::std::collections::HashMap::new())
    }

    // string host_rewrite_literal = 11;


    pub fn get_host_rewrite_literal(&self) -> &str {
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(WeightedCluster_ClusterWeight_oneof_host_rewrite_specifier::host_rewrite_literal(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_host_rewrite_literal(&mut self) {
        self.host_rewrite_specifier = ::std::option::Option::None;
    }

    pub fn has_host_rewrite_literal(&self) -> bool {
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(WeightedCluster_ClusterWeight_oneof_host_rewrite_specifier::host_rewrite_literal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_host_rewrite_literal(&mut self, v: ::std::string::String) {
        self.host_rewrite_specifier = ::std::option::Option::Some(WeightedCluster_ClusterWeight_oneof_host_rewrite_specifier::host_rewrite_literal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_host_rewrite_literal(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(WeightedCluster_ClusterWeight_oneof_host_rewrite_specifier::host_rewrite_literal(_)) = self.host_rewrite_specifier {
        } else {
            self.host_rewrite_specifier = ::std::option::Option::Some(WeightedCluster_ClusterWeight_oneof_host_rewrite_specifier::host_rewrite_literal(::std::string::String::new()));
        }
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(WeightedCluster_ClusterWeight_oneof_host_rewrite_specifier::host_rewrite_literal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_host_rewrite_literal(&mut self) -> ::std::string::String {
        if self.has_host_rewrite_literal() {
            match self.host_rewrite_specifier.take() {
                ::std::option::Option::Some(WeightedCluster_ClusterWeight_oneof_host_rewrite_specifier::host_rewrite_literal(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for WeightedCluster_ClusterWeight {
    fn is_initialized(&self) -> bool {
        for v in &self.weight {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request_headers_to_add {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.response_headers_to_add {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.weight)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata_match)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.request_headers_to_add)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.request_headers_to_remove)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.response_headers_to_add)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.response_headers_to_remove)?;
                },
                10 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(wire_type, is, &mut self.typed_per_filter_config)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.host_rewrite_specifier = ::std::option::Option::Some(WeightedCluster_ClusterWeight_oneof_host_rewrite_specifier::host_rewrite_literal(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.cluster_header.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.cluster_header);
        }
        if let Some(ref v) = self.weight.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.metadata_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.request_headers_to_add {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.request_headers_to_remove {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.response_headers_to_add {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.response_headers_to_remove {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(10, &self.typed_per_filter_config);
        if let ::std::option::Option::Some(ref v) = self.host_rewrite_specifier {
            match v {
                &WeightedCluster_ClusterWeight_oneof_host_rewrite_specifier::host_rewrite_literal(ref v) => {
                    my_size += ::protobuf::rt::string_size(11, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.cluster_header.is_empty() {
            os.write_string(12, &self.cluster_header)?;
        }
        if let Some(ref v) = self.weight.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.metadata_match.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.request_headers_to_add {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.request_headers_to_remove {
            os.write_string(9, &v)?;
        };
        for v in &self.response_headers_to_add {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.response_headers_to_remove {
            os.write_string(6, &v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(10, &self.typed_per_filter_config, os)?;
        if let ::std::option::Option::Some(ref v) = self.host_rewrite_specifier {
            match v {
                &WeightedCluster_ClusterWeight_oneof_host_rewrite_specifier::host_rewrite_literal(ref v) => {
                    os.write_string(11, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WeightedCluster_ClusterWeight {
        WeightedCluster_ClusterWeight::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &WeightedCluster_ClusterWeight| { &m.name },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_header",
                |m: &WeightedCluster_ClusterWeight| { &m.cluster_header },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.cluster_header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "weight",
                |m: &WeightedCluster_ClusterWeight| { &m.weight },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::Metadata>>(
                "metadata_match",
                |m: &WeightedCluster_ClusterWeight| { &m.metadata_match },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.metadata_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderValueOption>>(
                "request_headers_to_add",
                |m: &WeightedCluster_ClusterWeight| { &m.request_headers_to_add },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.request_headers_to_add },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "request_headers_to_remove",
                |m: &WeightedCluster_ClusterWeight| { &m.request_headers_to_remove },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.request_headers_to_remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderValueOption>>(
                "response_headers_to_add",
                |m: &WeightedCluster_ClusterWeight| { &m.response_headers_to_add },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.response_headers_to_add },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "response_headers_to_remove",
                |m: &WeightedCluster_ClusterWeight| { &m.response_headers_to_remove },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.response_headers_to_remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "typed_per_filter_config",
                |m: &WeightedCluster_ClusterWeight| { &m.typed_per_filter_config },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.typed_per_filter_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "host_rewrite_literal",
                WeightedCluster_ClusterWeight::has_host_rewrite_literal,
                WeightedCluster_ClusterWeight::get_host_rewrite_literal,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WeightedCluster_ClusterWeight>(
                "WeightedCluster.ClusterWeight",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WeightedCluster_ClusterWeight {
        static instance: ::protobuf::rt::LazyV2<WeightedCluster_ClusterWeight> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WeightedCluster_ClusterWeight::new)
    }
}

impl ::protobuf::Clear for WeightedCluster_ClusterWeight {
    fn clear(&mut self) {
        self.name.clear();
        self.cluster_header.clear();
        self.weight.clear();
        self.metadata_match.clear();
        self.request_headers_to_add.clear();
        self.request_headers_to_remove.clear();
        self.response_headers_to_add.clear();
        self.response_headers_to_remove.clear();
        self.typed_per_filter_config.clear();
        self.host_rewrite_specifier = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WeightedCluster_ClusterWeight {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WeightedCluster_ClusterWeight {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteMatch {
    // message fields
    pub case_sensitive: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub runtime_fraction: ::protobuf::SingularPtrField<super::base::RuntimeFractionalPercent>,
    pub headers: ::protobuf::RepeatedField<HeaderMatcher>,
    pub query_parameters: ::protobuf::RepeatedField<QueryParameterMatcher>,
    pub grpc: ::protobuf::SingularPtrField<RouteMatch_GrpcRouteMatchOptions>,
    pub tls_context: ::protobuf::SingularPtrField<RouteMatch_TlsContextMatchOptions>,
    pub dynamic_metadata: ::protobuf::RepeatedField<super::metadata::MetadataMatcher>,
    // message oneof groups
    pub path_specifier: ::std::option::Option<RouteMatch_oneof_path_specifier>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteMatch {
    fn default() -> &'a RouteMatch {
        <RouteMatch as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RouteMatch_oneof_path_specifier {
    prefix(::std::string::String),
    path(::std::string::String),
    safe_regex(super::regex::RegexMatcher),
    connect_matcher(RouteMatch_ConnectMatcher),
}

impl RouteMatch {
    pub fn new() -> RouteMatch {
        ::std::default::Default::default()
    }

    // string prefix = 1;


    pub fn get_prefix(&self) -> &str {
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::prefix(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_prefix(&mut self) {
        self.path_specifier = ::std::option::Option::None;
    }

    pub fn has_prefix(&self) -> bool {
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::prefix(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::prefix(v))
    }

    // Mutable pointer to the field.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RouteMatch_oneof_path_specifier::prefix(_)) = self.path_specifier {
        } else {
            self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::prefix(::std::string::String::new()));
        }
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::prefix(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        if self.has_prefix() {
            match self.path_specifier.take() {
                ::std::option::Option::Some(RouteMatch_oneof_path_specifier::prefix(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string path = 2;


    pub fn get_path(&self) -> &str {
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::path(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path_specifier = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::path(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::path(v))
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RouteMatch_oneof_path_specifier::path(_)) = self.path_specifier {
        } else {
            self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::path(::std::string::String::new()));
        }
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::path(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        if self.has_path() {
            match self.path_specifier.take() {
                ::std::option::Option::Some(RouteMatch_oneof_path_specifier::path(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .envoy.type.matcher.v3.RegexMatcher safe_regex = 10;


    pub fn get_safe_regex(&self) -> &super::regex::RegexMatcher {
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::safe_regex(ref v)) => v,
            _ => <super::regex::RegexMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_safe_regex(&mut self) {
        self.path_specifier = ::std::option::Option::None;
    }

    pub fn has_safe_regex(&self) -> bool {
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::safe_regex(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_safe_regex(&mut self, v: super::regex::RegexMatcher) {
        self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::safe_regex(v))
    }

    // Mutable pointer to the field.
    pub fn mut_safe_regex(&mut self) -> &mut super::regex::RegexMatcher {
        if let ::std::option::Option::Some(RouteMatch_oneof_path_specifier::safe_regex(_)) = self.path_specifier {
        } else {
            self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::safe_regex(super::regex::RegexMatcher::new()));
        }
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::safe_regex(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_safe_regex(&mut self) -> super::regex::RegexMatcher {
        if self.has_safe_regex() {
            match self.path_specifier.take() {
                ::std::option::Option::Some(RouteMatch_oneof_path_specifier::safe_regex(v)) => v,
                _ => panic!(),
            }
        } else {
            super::regex::RegexMatcher::new()
        }
    }

    // .envoy.config.route.v3.RouteMatch.ConnectMatcher connect_matcher = 12;


    pub fn get_connect_matcher(&self) -> &RouteMatch_ConnectMatcher {
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::connect_matcher(ref v)) => v,
            _ => <RouteMatch_ConnectMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_connect_matcher(&mut self) {
        self.path_specifier = ::std::option::Option::None;
    }

    pub fn has_connect_matcher(&self) -> bool {
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::connect_matcher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_connect_matcher(&mut self, v: RouteMatch_ConnectMatcher) {
        self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::connect_matcher(v))
    }

    // Mutable pointer to the field.
    pub fn mut_connect_matcher(&mut self) -> &mut RouteMatch_ConnectMatcher {
        if let ::std::option::Option::Some(RouteMatch_oneof_path_specifier::connect_matcher(_)) = self.path_specifier {
        } else {
            self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::connect_matcher(RouteMatch_ConnectMatcher::new()));
        }
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::connect_matcher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_connect_matcher(&mut self) -> RouteMatch_ConnectMatcher {
        if self.has_connect_matcher() {
            match self.path_specifier.take() {
                ::std::option::Option::Some(RouteMatch_oneof_path_specifier::connect_matcher(v)) => v,
                _ => panic!(),
            }
        } else {
            RouteMatch_ConnectMatcher::new()
        }
    }

    // .google.protobuf.BoolValue case_sensitive = 4;


    pub fn get_case_sensitive(&self) -> &::protobuf::well_known_types::BoolValue {
        self.case_sensitive.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_case_sensitive(&mut self) {
        self.case_sensitive.clear();
    }

    pub fn has_case_sensitive(&self) -> bool {
        self.case_sensitive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_case_sensitive(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.case_sensitive = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_case_sensitive(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.case_sensitive.is_none() {
            self.case_sensitive.set_default();
        }
        self.case_sensitive.as_mut().unwrap()
    }

    // Take field
    pub fn take_case_sensitive(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.case_sensitive.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .envoy.config.core.v3.RuntimeFractionalPercent runtime_fraction = 9;


    pub fn get_runtime_fraction(&self) -> &super::base::RuntimeFractionalPercent {
        self.runtime_fraction.as_ref().unwrap_or_else(|| <super::base::RuntimeFractionalPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_runtime_fraction(&mut self) {
        self.runtime_fraction.clear();
    }

    pub fn has_runtime_fraction(&self) -> bool {
        self.runtime_fraction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runtime_fraction(&mut self, v: super::base::RuntimeFractionalPercent) {
        self.runtime_fraction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_fraction(&mut self) -> &mut super::base::RuntimeFractionalPercent {
        if self.runtime_fraction.is_none() {
            self.runtime_fraction.set_default();
        }
        self.runtime_fraction.as_mut().unwrap()
    }

    // Take field
    pub fn take_runtime_fraction(&mut self) -> super::base::RuntimeFractionalPercent {
        self.runtime_fraction.take().unwrap_or_else(|| super::base::RuntimeFractionalPercent::new())
    }

    // repeated .envoy.config.route.v3.HeaderMatcher headers = 6;


    pub fn get_headers(&self) -> &[HeaderMatcher] {
        &self.headers
    }
    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::protobuf::RepeatedField<HeaderMatcher>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::protobuf::RepeatedField<HeaderMatcher> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::protobuf::RepeatedField<HeaderMatcher> {
        ::std::mem::replace(&mut self.headers, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.config.route.v3.QueryParameterMatcher query_parameters = 7;


    pub fn get_query_parameters(&self) -> &[QueryParameterMatcher] {
        &self.query_parameters
    }
    pub fn clear_query_parameters(&mut self) {
        self.query_parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_query_parameters(&mut self, v: ::protobuf::RepeatedField<QueryParameterMatcher>) {
        self.query_parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_query_parameters(&mut self) -> &mut ::protobuf::RepeatedField<QueryParameterMatcher> {
        &mut self.query_parameters
    }

    // Take field
    pub fn take_query_parameters(&mut self) -> ::protobuf::RepeatedField<QueryParameterMatcher> {
        ::std::mem::replace(&mut self.query_parameters, ::protobuf::RepeatedField::new())
    }

    // .envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions grpc = 8;


    pub fn get_grpc(&self) -> &RouteMatch_GrpcRouteMatchOptions {
        self.grpc.as_ref().unwrap_or_else(|| <RouteMatch_GrpcRouteMatchOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_grpc(&mut self) {
        self.grpc.clear();
    }

    pub fn has_grpc(&self) -> bool {
        self.grpc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grpc(&mut self, v: RouteMatch_GrpcRouteMatchOptions) {
        self.grpc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_grpc(&mut self) -> &mut RouteMatch_GrpcRouteMatchOptions {
        if self.grpc.is_none() {
            self.grpc.set_default();
        }
        self.grpc.as_mut().unwrap()
    }

    // Take field
    pub fn take_grpc(&mut self) -> RouteMatch_GrpcRouteMatchOptions {
        self.grpc.take().unwrap_or_else(|| RouteMatch_GrpcRouteMatchOptions::new())
    }

    // .envoy.config.route.v3.RouteMatch.TlsContextMatchOptions tls_context = 11;


    pub fn get_tls_context(&self) -> &RouteMatch_TlsContextMatchOptions {
        self.tls_context.as_ref().unwrap_or_else(|| <RouteMatch_TlsContextMatchOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tls_context(&mut self) {
        self.tls_context.clear();
    }

    pub fn has_tls_context(&self) -> bool {
        self.tls_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tls_context(&mut self, v: RouteMatch_TlsContextMatchOptions) {
        self.tls_context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tls_context(&mut self) -> &mut RouteMatch_TlsContextMatchOptions {
        if self.tls_context.is_none() {
            self.tls_context.set_default();
        }
        self.tls_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_tls_context(&mut self) -> RouteMatch_TlsContextMatchOptions {
        self.tls_context.take().unwrap_or_else(|| RouteMatch_TlsContextMatchOptions::new())
    }

    // repeated .envoy.type.matcher.v3.MetadataMatcher dynamic_metadata = 13;


    pub fn get_dynamic_metadata(&self) -> &[super::metadata::MetadataMatcher] {
        &self.dynamic_metadata
    }
    pub fn clear_dynamic_metadata(&mut self) {
        self.dynamic_metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_dynamic_metadata(&mut self, v: ::protobuf::RepeatedField<super::metadata::MetadataMatcher>) {
        self.dynamic_metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dynamic_metadata(&mut self) -> &mut ::protobuf::RepeatedField<super::metadata::MetadataMatcher> {
        &mut self.dynamic_metadata
    }

    // Take field
    pub fn take_dynamic_metadata(&mut self) -> ::protobuf::RepeatedField<super::metadata::MetadataMatcher> {
        ::std::mem::replace(&mut self.dynamic_metadata, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RouteMatch {
    fn is_initialized(&self) -> bool {
        if let Some(RouteMatch_oneof_path_specifier::safe_regex(ref v)) = self.path_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RouteMatch_oneof_path_specifier::connect_matcher(ref v)) = self.path_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.case_sensitive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.runtime_fraction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.query_parameters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.grpc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tls_context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dynamic_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::prefix(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::path(is.read_string()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::safe_regex(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::connect_matcher(is.read_message()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.case_sensitive)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.runtime_fraction)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.headers)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.query_parameters)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.grpc)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tls_context)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dynamic_metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.case_sensitive.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.runtime_fraction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.query_parameters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.grpc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tls_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.dynamic_metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.path_specifier {
            match v {
                &RouteMatch_oneof_path_specifier::prefix(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &RouteMatch_oneof_path_specifier::path(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &RouteMatch_oneof_path_specifier::safe_regex(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RouteMatch_oneof_path_specifier::connect_matcher(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.case_sensitive.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.runtime_fraction.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.headers {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.query_parameters {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.grpc.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tls_context.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.dynamic_metadata {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.path_specifier {
            match v {
                &RouteMatch_oneof_path_specifier::prefix(ref v) => {
                    os.write_string(1, v)?;
                },
                &RouteMatch_oneof_path_specifier::path(ref v) => {
                    os.write_string(2, v)?;
                },
                &RouteMatch_oneof_path_specifier::safe_regex(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RouteMatch_oneof_path_specifier::connect_matcher(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteMatch {
        RouteMatch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "prefix",
                RouteMatch::has_prefix,
                RouteMatch::get_prefix,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "path",
                RouteMatch::has_path,
                RouteMatch::get_path,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::regex::RegexMatcher>(
                "safe_regex",
                RouteMatch::has_safe_regex,
                RouteMatch::get_safe_regex,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RouteMatch_ConnectMatcher>(
                "connect_matcher",
                RouteMatch::has_connect_matcher,
                RouteMatch::get_connect_matcher,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "case_sensitive",
                |m: &RouteMatch| { &m.case_sensitive },
                |m: &mut RouteMatch| { &mut m.case_sensitive },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::RuntimeFractionalPercent>>(
                "runtime_fraction",
                |m: &RouteMatch| { &m.runtime_fraction },
                |m: &mut RouteMatch| { &mut m.runtime_fraction },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeaderMatcher>>(
                "headers",
                |m: &RouteMatch| { &m.headers },
                |m: &mut RouteMatch| { &mut m.headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryParameterMatcher>>(
                "query_parameters",
                |m: &RouteMatch| { &m.query_parameters },
                |m: &mut RouteMatch| { &mut m.query_parameters },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteMatch_GrpcRouteMatchOptions>>(
                "grpc",
                |m: &RouteMatch| { &m.grpc },
                |m: &mut RouteMatch| { &mut m.grpc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteMatch_TlsContextMatchOptions>>(
                "tls_context",
                |m: &RouteMatch| { &m.tls_context },
                |m: &mut RouteMatch| { &mut m.tls_context },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::metadata::MetadataMatcher>>(
                "dynamic_metadata",
                |m: &RouteMatch| { &m.dynamic_metadata },
                |m: &mut RouteMatch| { &mut m.dynamic_metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteMatch>(
                "RouteMatch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteMatch {
        static instance: ::protobuf::rt::LazyV2<RouteMatch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteMatch::new)
    }
}

impl ::protobuf::Clear for RouteMatch {
    fn clear(&mut self) {
        self.path_specifier = ::std::option::Option::None;
        self.path_specifier = ::std::option::Option::None;
        self.path_specifier = ::std::option::Option::None;
        self.path_specifier = ::std::option::Option::None;
        self.case_sensitive.clear();
        self.runtime_fraction.clear();
        self.headers.clear();
        self.query_parameters.clear();
        self.grpc.clear();
        self.tls_context.clear();
        self.dynamic_metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteMatch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteMatch_GrpcRouteMatchOptions {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteMatch_GrpcRouteMatchOptions {
    fn default() -> &'a RouteMatch_GrpcRouteMatchOptions {
        <RouteMatch_GrpcRouteMatchOptions as ::protobuf::Message>::default_instance()
    }
}

impl RouteMatch_GrpcRouteMatchOptions {
    pub fn new() -> RouteMatch_GrpcRouteMatchOptions {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RouteMatch_GrpcRouteMatchOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteMatch_GrpcRouteMatchOptions {
        RouteMatch_GrpcRouteMatchOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteMatch_GrpcRouteMatchOptions>(
                "RouteMatch.GrpcRouteMatchOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteMatch_GrpcRouteMatchOptions {
        static instance: ::protobuf::rt::LazyV2<RouteMatch_GrpcRouteMatchOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteMatch_GrpcRouteMatchOptions::new)
    }
}

impl ::protobuf::Clear for RouteMatch_GrpcRouteMatchOptions {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteMatch_GrpcRouteMatchOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteMatch_GrpcRouteMatchOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteMatch_TlsContextMatchOptions {
    // message fields
    pub presented: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub validated: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteMatch_TlsContextMatchOptions {
    fn default() -> &'a RouteMatch_TlsContextMatchOptions {
        <RouteMatch_TlsContextMatchOptions as ::protobuf::Message>::default_instance()
    }
}

impl RouteMatch_TlsContextMatchOptions {
    pub fn new() -> RouteMatch_TlsContextMatchOptions {
        ::std::default::Default::default()
    }

    // .google.protobuf.BoolValue presented = 1;


    pub fn get_presented(&self) -> &::protobuf::well_known_types::BoolValue {
        self.presented.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_presented(&mut self) {
        self.presented.clear();
    }

    pub fn has_presented(&self) -> bool {
        self.presented.is_some()
    }

    // Param is passed by value, moved
    pub fn set_presented(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.presented = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_presented(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.presented.is_none() {
            self.presented.set_default();
        }
        self.presented.as_mut().unwrap()
    }

    // Take field
    pub fn take_presented(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.presented.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .google.protobuf.BoolValue validated = 2;


    pub fn get_validated(&self) -> &::protobuf::well_known_types::BoolValue {
        self.validated.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_validated(&mut self) {
        self.validated.clear();
    }

    pub fn has_validated(&self) -> bool {
        self.validated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validated(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.validated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validated(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.validated.is_none() {
            self.validated.set_default();
        }
        self.validated.as_mut().unwrap()
    }

    // Take field
    pub fn take_validated(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.validated.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }
}

impl ::protobuf::Message for RouteMatch_TlsContextMatchOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.presented {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.validated {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.presented)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.validated)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.presented.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.validated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.presented.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.validated.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteMatch_TlsContextMatchOptions {
        RouteMatch_TlsContextMatchOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "presented",
                |m: &RouteMatch_TlsContextMatchOptions| { &m.presented },
                |m: &mut RouteMatch_TlsContextMatchOptions| { &mut m.presented },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "validated",
                |m: &RouteMatch_TlsContextMatchOptions| { &m.validated },
                |m: &mut RouteMatch_TlsContextMatchOptions| { &mut m.validated },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteMatch_TlsContextMatchOptions>(
                "RouteMatch.TlsContextMatchOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteMatch_TlsContextMatchOptions {
        static instance: ::protobuf::rt::LazyV2<RouteMatch_TlsContextMatchOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteMatch_TlsContextMatchOptions::new)
    }
}

impl ::protobuf::Clear for RouteMatch_TlsContextMatchOptions {
    fn clear(&mut self) {
        self.presented.clear();
        self.validated.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteMatch_TlsContextMatchOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteMatch_TlsContextMatchOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteMatch_ConnectMatcher {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteMatch_ConnectMatcher {
    fn default() -> &'a RouteMatch_ConnectMatcher {
        <RouteMatch_ConnectMatcher as ::protobuf::Message>::default_instance()
    }
}

impl RouteMatch_ConnectMatcher {
    pub fn new() -> RouteMatch_ConnectMatcher {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RouteMatch_ConnectMatcher {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteMatch_ConnectMatcher {
        RouteMatch_ConnectMatcher::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteMatch_ConnectMatcher>(
                "RouteMatch.ConnectMatcher",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteMatch_ConnectMatcher {
        static instance: ::protobuf::rt::LazyV2<RouteMatch_ConnectMatcher> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteMatch_ConnectMatcher::new)
    }
}

impl ::protobuf::Clear for RouteMatch_ConnectMatcher {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteMatch_ConnectMatcher {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteMatch_ConnectMatcher {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct CorsPolicy {
    // message fields
    pub allow_origin_string_match: ::protobuf::RepeatedField<super::string::StringMatcher>,
    pub allow_methods: ::std::string::String,
    pub allow_headers: ::std::string::String,
    pub expose_headers: ::std::string::String,
    pub max_age: ::std::string::String,
    pub allow_credentials: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub shadow_enabled: ::protobuf::SingularPtrField<super::base::RuntimeFractionalPercent>,
    // message oneof groups
    pub enabled_specifier: ::std::option::Option<CorsPolicy_oneof_enabled_specifier>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CorsPolicy {
    fn default() -> &'a CorsPolicy {
        <CorsPolicy as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum CorsPolicy_oneof_enabled_specifier {
    filter_enabled(super::base::RuntimeFractionalPercent),
}

impl CorsPolicy {
    pub fn new() -> CorsPolicy {
        ::std::default::Default::default()
    }

    // repeated .envoy.type.matcher.v3.StringMatcher allow_origin_string_match = 11;


    pub fn get_allow_origin_string_match(&self) -> &[super::string::StringMatcher] {
        &self.allow_origin_string_match
    }
    pub fn clear_allow_origin_string_match(&mut self) {
        self.allow_origin_string_match.clear();
    }

    // Param is passed by value, moved
    pub fn set_allow_origin_string_match(&mut self, v: ::protobuf::RepeatedField<super::string::StringMatcher>) {
        self.allow_origin_string_match = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allow_origin_string_match(&mut self) -> &mut ::protobuf::RepeatedField<super::string::StringMatcher> {
        &mut self.allow_origin_string_match
    }

    // Take field
    pub fn take_allow_origin_string_match(&mut self) -> ::protobuf::RepeatedField<super::string::StringMatcher> {
        ::std::mem::replace(&mut self.allow_origin_string_match, ::protobuf::RepeatedField::new())
    }

    // string allow_methods = 2;


    pub fn get_allow_methods(&self) -> &str {
        &self.allow_methods
    }
    pub fn clear_allow_methods(&mut self) {
        self.allow_methods.clear();
    }

    // Param is passed by value, moved
    pub fn set_allow_methods(&mut self, v: ::std::string::String) {
        self.allow_methods = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allow_methods(&mut self) -> &mut ::std::string::String {
        &mut self.allow_methods
    }

    // Take field
    pub fn take_allow_methods(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.allow_methods, ::std::string::String::new())
    }

    // string allow_headers = 3;


    pub fn get_allow_headers(&self) -> &str {
        &self.allow_headers
    }
    pub fn clear_allow_headers(&mut self) {
        self.allow_headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_allow_headers(&mut self, v: ::std::string::String) {
        self.allow_headers = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allow_headers(&mut self) -> &mut ::std::string::String {
        &mut self.allow_headers
    }

    // Take field
    pub fn take_allow_headers(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.allow_headers, ::std::string::String::new())
    }

    // string expose_headers = 4;


    pub fn get_expose_headers(&self) -> &str {
        &self.expose_headers
    }
    pub fn clear_expose_headers(&mut self) {
        self.expose_headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_expose_headers(&mut self, v: ::std::string::String) {
        self.expose_headers = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expose_headers(&mut self) -> &mut ::std::string::String {
        &mut self.expose_headers
    }

    // Take field
    pub fn take_expose_headers(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.expose_headers, ::std::string::String::new())
    }

    // string max_age = 5;


    pub fn get_max_age(&self) -> &str {
        &self.max_age
    }
    pub fn clear_max_age(&mut self) {
        self.max_age.clear();
    }

    // Param is passed by value, moved
    pub fn set_max_age(&mut self, v: ::std::string::String) {
        self.max_age = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_age(&mut self) -> &mut ::std::string::String {
        &mut self.max_age
    }

    // Take field
    pub fn take_max_age(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.max_age, ::std::string::String::new())
    }

    // .google.protobuf.BoolValue allow_credentials = 6;


    pub fn get_allow_credentials(&self) -> &::protobuf::well_known_types::BoolValue {
        self.allow_credentials.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_allow_credentials(&mut self) {
        self.allow_credentials.clear();
    }

    pub fn has_allow_credentials(&self) -> bool {
        self.allow_credentials.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_credentials(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.allow_credentials = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allow_credentials(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.allow_credentials.is_none() {
            self.allow_credentials.set_default();
        }
        self.allow_credentials.as_mut().unwrap()
    }

    // Take field
    pub fn take_allow_credentials(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.allow_credentials.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .envoy.config.core.v3.RuntimeFractionalPercent filter_enabled = 9;


    pub fn get_filter_enabled(&self) -> &super::base::RuntimeFractionalPercent {
        match self.enabled_specifier {
            ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(ref v)) => v,
            _ => <super::base::RuntimeFractionalPercent as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_filter_enabled(&mut self) {
        self.enabled_specifier = ::std::option::Option::None;
    }

    pub fn has_filter_enabled(&self) -> bool {
        match self.enabled_specifier {
            ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_filter_enabled(&mut self, v: super::base::RuntimeFractionalPercent) {
        self.enabled_specifier = ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(v))
    }

    // Mutable pointer to the field.
    pub fn mut_filter_enabled(&mut self) -> &mut super::base::RuntimeFractionalPercent {
        if let ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(_)) = self.enabled_specifier {
        } else {
            self.enabled_specifier = ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(super::base::RuntimeFractionalPercent::new()));
        }
        match self.enabled_specifier {
            ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_filter_enabled(&mut self) -> super::base::RuntimeFractionalPercent {
        if self.has_filter_enabled() {
            match self.enabled_specifier.take() {
                ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(v)) => v,
                _ => panic!(),
            }
        } else {
            super::base::RuntimeFractionalPercent::new()
        }
    }

    // .envoy.config.core.v3.RuntimeFractionalPercent shadow_enabled = 10;


    pub fn get_shadow_enabled(&self) -> &super::base::RuntimeFractionalPercent {
        self.shadow_enabled.as_ref().unwrap_or_else(|| <super::base::RuntimeFractionalPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shadow_enabled(&mut self) {
        self.shadow_enabled.clear();
    }

    pub fn has_shadow_enabled(&self) -> bool {
        self.shadow_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shadow_enabled(&mut self, v: super::base::RuntimeFractionalPercent) {
        self.shadow_enabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shadow_enabled(&mut self) -> &mut super::base::RuntimeFractionalPercent {
        if self.shadow_enabled.is_none() {
            self.shadow_enabled.set_default();
        }
        self.shadow_enabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_shadow_enabled(&mut self) -> super::base::RuntimeFractionalPercent {
        self.shadow_enabled.take().unwrap_or_else(|| super::base::RuntimeFractionalPercent::new())
    }
}

impl ::protobuf::Message for CorsPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.allow_origin_string_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allow_credentials {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(ref v)) = self.enabled_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.shadow_enabled {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.allow_origin_string_match)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.allow_methods)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.allow_headers)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.expose_headers)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.max_age)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.allow_credentials)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enabled_specifier = ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(is.read_message()?));
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shadow_enabled)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.allow_origin_string_match {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.allow_methods.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.allow_methods);
        }
        if !self.allow_headers.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.allow_headers);
        }
        if !self.expose_headers.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.expose_headers);
        }
        if !self.max_age.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.max_age);
        }
        if let Some(ref v) = self.allow_credentials.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.shadow_enabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.enabled_specifier {
            match v {
                &CorsPolicy_oneof_enabled_specifier::filter_enabled(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.allow_origin_string_match {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.allow_methods.is_empty() {
            os.write_string(2, &self.allow_methods)?;
        }
        if !self.allow_headers.is_empty() {
            os.write_string(3, &self.allow_headers)?;
        }
        if !self.expose_headers.is_empty() {
            os.write_string(4, &self.expose_headers)?;
        }
        if !self.max_age.is_empty() {
            os.write_string(5, &self.max_age)?;
        }
        if let Some(ref v) = self.allow_credentials.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.shadow_enabled.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.enabled_specifier {
            match v {
                &CorsPolicy_oneof_enabled_specifier::filter_enabled(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CorsPolicy {
        CorsPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::string::StringMatcher>>(
                "allow_origin_string_match",
                |m: &CorsPolicy| { &m.allow_origin_string_match },
                |m: &mut CorsPolicy| { &mut m.allow_origin_string_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "allow_methods",
                |m: &CorsPolicy| { &m.allow_methods },
                |m: &mut CorsPolicy| { &mut m.allow_methods },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "allow_headers",
                |m: &CorsPolicy| { &m.allow_headers },
                |m: &mut CorsPolicy| { &mut m.allow_headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "expose_headers",
                |m: &CorsPolicy| { &m.expose_headers },
                |m: &mut CorsPolicy| { &mut m.expose_headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "max_age",
                |m: &CorsPolicy| { &m.max_age },
                |m: &mut CorsPolicy| { &mut m.max_age },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "allow_credentials",
                |m: &CorsPolicy| { &m.allow_credentials },
                |m: &mut CorsPolicy| { &mut m.allow_credentials },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::base::RuntimeFractionalPercent>(
                "filter_enabled",
                CorsPolicy::has_filter_enabled,
                CorsPolicy::get_filter_enabled,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::RuntimeFractionalPercent>>(
                "shadow_enabled",
                |m: &CorsPolicy| { &m.shadow_enabled },
                |m: &mut CorsPolicy| { &mut m.shadow_enabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CorsPolicy>(
                "CorsPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CorsPolicy {
        static instance: ::protobuf::rt::LazyV2<CorsPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CorsPolicy::new)
    }
}

impl ::protobuf::Clear for CorsPolicy {
    fn clear(&mut self) {
        self.allow_origin_string_match.clear();
        self.allow_methods.clear();
        self.allow_headers.clear();
        self.expose_headers.clear();
        self.max_age.clear();
        self.allow_credentials.clear();
        self.enabled_specifier = ::std::option::Option::None;
        self.shadow_enabled.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CorsPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CorsPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteAction {
    // message fields
    pub cluster_not_found_response_code: RouteAction_ClusterNotFoundResponseCode,
    pub metadata_match: ::protobuf::SingularPtrField<super::base::Metadata>,
    pub prefix_rewrite: ::std::string::String,
    pub regex_rewrite: ::protobuf::SingularPtrField<super::regex::RegexMatchAndSubstitute>,
    pub append_x_forwarded_host: bool,
    pub timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub idle_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub retry_policy: ::protobuf::SingularPtrField<RetryPolicy>,
    pub retry_policy_typed_config: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub request_mirror_policies: ::protobuf::RepeatedField<RouteAction_RequestMirrorPolicy>,
    pub priority: super::base::RoutingPriority,
    pub rate_limits: ::protobuf::RepeatedField<RateLimit>,
    pub include_vh_rate_limits: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub hash_policy: ::protobuf::RepeatedField<RouteAction_HashPolicy>,
    pub cors: ::protobuf::SingularPtrField<CorsPolicy>,
    pub max_grpc_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub grpc_timeout_offset: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub upgrade_configs: ::protobuf::RepeatedField<RouteAction_UpgradeConfig>,
    pub internal_redirect_policy: ::protobuf::SingularPtrField<InternalRedirectPolicy>,
    pub internal_redirect_action: RouteAction_InternalRedirectAction,
    pub max_internal_redirects: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub hedge_policy: ::protobuf::SingularPtrField<HedgePolicy>,
    pub max_stream_duration: ::protobuf::SingularPtrField<RouteAction_MaxStreamDuration>,
    // message oneof groups
    pub cluster_specifier: ::std::option::Option<RouteAction_oneof_cluster_specifier>,
    pub host_rewrite_specifier: ::std::option::Option<RouteAction_oneof_host_rewrite_specifier>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction {
    fn default() -> &'a RouteAction {
        <RouteAction as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RouteAction_oneof_cluster_specifier {
    cluster(::std::string::String),
    cluster_header(::std::string::String),
    weighted_clusters(WeightedCluster),
    cluster_specifier_plugin(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RouteAction_oneof_host_rewrite_specifier {
    host_rewrite_literal(::std::string::String),
    auto_host_rewrite(::protobuf::well_known_types::BoolValue),
    host_rewrite_header(::std::string::String),
    host_rewrite_path_regex(super::regex::RegexMatchAndSubstitute),
}

impl RouteAction {
    pub fn new() -> RouteAction {
        ::std::default::Default::default()
    }

    // string cluster = 1;


    pub fn get_cluster(&self) -> &str {
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_cluster(&mut self) {
        self.cluster_specifier = ::std::option::Option::None;
    }

    pub fn has_cluster(&self) -> bool {
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: ::std::string::String) {
        self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cluster(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster(_)) = self.cluster_specifier {
        } else {
            self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster(::std::string::String::new()));
        }
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cluster(&mut self) -> ::std::string::String {
        if self.has_cluster() {
            match self.cluster_specifier.take() {
                ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string cluster_header = 2;


    pub fn get_cluster_header(&self) -> &str {
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_header(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_cluster_header(&mut self) {
        self.cluster_specifier = ::std::option::Option::None;
    }

    pub fn has_cluster_header(&self) -> bool {
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_header(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cluster_header(&mut self, v: ::std::string::String) {
        self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_header(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cluster_header(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_header(_)) = self.cluster_specifier {
        } else {
            self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_header(::std::string::String::new()));
        }
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_header(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cluster_header(&mut self) -> ::std::string::String {
        if self.has_cluster_header() {
            match self.cluster_specifier.take() {
                ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_header(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .envoy.config.route.v3.WeightedCluster weighted_clusters = 3;


    pub fn get_weighted_clusters(&self) -> &WeightedCluster {
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::weighted_clusters(ref v)) => v,
            _ => <WeightedCluster as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_weighted_clusters(&mut self) {
        self.cluster_specifier = ::std::option::Option::None;
    }

    pub fn has_weighted_clusters(&self) -> bool {
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::weighted_clusters(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_weighted_clusters(&mut self, v: WeightedCluster) {
        self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::weighted_clusters(v))
    }

    // Mutable pointer to the field.
    pub fn mut_weighted_clusters(&mut self) -> &mut WeightedCluster {
        if let ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::weighted_clusters(_)) = self.cluster_specifier {
        } else {
            self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::weighted_clusters(WeightedCluster::new()));
        }
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::weighted_clusters(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_weighted_clusters(&mut self) -> WeightedCluster {
        if self.has_weighted_clusters() {
            match self.cluster_specifier.take() {
                ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::weighted_clusters(v)) => v,
                _ => panic!(),
            }
        } else {
            WeightedCluster::new()
        }
    }

    // string cluster_specifier_plugin = 37;


    pub fn get_cluster_specifier_plugin(&self) -> &str {
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_specifier_plugin(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_cluster_specifier_plugin(&mut self) {
        self.cluster_specifier = ::std::option::Option::None;
    }

    pub fn has_cluster_specifier_plugin(&self) -> bool {
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_specifier_plugin(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cluster_specifier_plugin(&mut self, v: ::std::string::String) {
        self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_specifier_plugin(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cluster_specifier_plugin(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_specifier_plugin(_)) = self.cluster_specifier {
        } else {
            self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_specifier_plugin(::std::string::String::new()));
        }
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_specifier_plugin(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cluster_specifier_plugin(&mut self) -> ::std::string::String {
        if self.has_cluster_specifier_plugin() {
            match self.cluster_specifier.take() {
                ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_specifier_plugin(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .envoy.config.route.v3.RouteAction.ClusterNotFoundResponseCode cluster_not_found_response_code = 20;


    pub fn get_cluster_not_found_response_code(&self) -> RouteAction_ClusterNotFoundResponseCode {
        self.cluster_not_found_response_code
    }
    pub fn clear_cluster_not_found_response_code(&mut self) {
        self.cluster_not_found_response_code = RouteAction_ClusterNotFoundResponseCode::SERVICE_UNAVAILABLE;
    }

    // Param is passed by value, moved
    pub fn set_cluster_not_found_response_code(&mut self, v: RouteAction_ClusterNotFoundResponseCode) {
        self.cluster_not_found_response_code = v;
    }

    // .envoy.config.core.v3.Metadata metadata_match = 4;


    pub fn get_metadata_match(&self) -> &super::base::Metadata {
        self.metadata_match.as_ref().unwrap_or_else(|| <super::base::Metadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata_match(&mut self) {
        self.metadata_match.clear();
    }

    pub fn has_metadata_match(&self) -> bool {
        self.metadata_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata_match(&mut self, v: super::base::Metadata) {
        self.metadata_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata_match(&mut self) -> &mut super::base::Metadata {
        if self.metadata_match.is_none() {
            self.metadata_match.set_default();
        }
        self.metadata_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata_match(&mut self) -> super::base::Metadata {
        self.metadata_match.take().unwrap_or_else(|| super::base::Metadata::new())
    }

    // string prefix_rewrite = 5;


    pub fn get_prefix_rewrite(&self) -> &str {
        &self.prefix_rewrite
    }
    pub fn clear_prefix_rewrite(&mut self) {
        self.prefix_rewrite.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix_rewrite(&mut self, v: ::std::string::String) {
        self.prefix_rewrite = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix_rewrite(&mut self) -> &mut ::std::string::String {
        &mut self.prefix_rewrite
    }

    // Take field
    pub fn take_prefix_rewrite(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix_rewrite, ::std::string::String::new())
    }

    // .envoy.type.matcher.v3.RegexMatchAndSubstitute regex_rewrite = 32;


    pub fn get_regex_rewrite(&self) -> &super::regex::RegexMatchAndSubstitute {
        self.regex_rewrite.as_ref().unwrap_or_else(|| <super::regex::RegexMatchAndSubstitute as ::protobuf::Message>::default_instance())
    }
    pub fn clear_regex_rewrite(&mut self) {
        self.regex_rewrite.clear();
    }

    pub fn has_regex_rewrite(&self) -> bool {
        self.regex_rewrite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_regex_rewrite(&mut self, v: super::regex::RegexMatchAndSubstitute) {
        self.regex_rewrite = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_regex_rewrite(&mut self) -> &mut super::regex::RegexMatchAndSubstitute {
        if self.regex_rewrite.is_none() {
            self.regex_rewrite.set_default();
        }
        self.regex_rewrite.as_mut().unwrap()
    }

    // Take field
    pub fn take_regex_rewrite(&mut self) -> super::regex::RegexMatchAndSubstitute {
        self.regex_rewrite.take().unwrap_or_else(|| super::regex::RegexMatchAndSubstitute::new())
    }

    // string host_rewrite_literal = 6;


    pub fn get_host_rewrite_literal(&self) -> &str {
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_literal(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_host_rewrite_literal(&mut self) {
        self.host_rewrite_specifier = ::std::option::Option::None;
    }

    pub fn has_host_rewrite_literal(&self) -> bool {
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_literal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_host_rewrite_literal(&mut self, v: ::std::string::String) {
        self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_literal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_host_rewrite_literal(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_literal(_)) = self.host_rewrite_specifier {
        } else {
            self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_literal(::std::string::String::new()));
        }
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_literal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_host_rewrite_literal(&mut self) -> ::std::string::String {
        if self.has_host_rewrite_literal() {
            match self.host_rewrite_specifier.take() {
                ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_literal(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .google.protobuf.BoolValue auto_host_rewrite = 7;


    pub fn get_auto_host_rewrite(&self) -> &::protobuf::well_known_types::BoolValue {
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(ref v)) => v,
            _ => <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_auto_host_rewrite(&mut self) {
        self.host_rewrite_specifier = ::std::option::Option::None;
    }

    pub fn has_auto_host_rewrite(&self) -> bool {
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_auto_host_rewrite(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(v))
    }

    // Mutable pointer to the field.
    pub fn mut_auto_host_rewrite(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if let ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(_)) = self.host_rewrite_specifier {
        } else {
            self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(::protobuf::well_known_types::BoolValue::new()));
        }
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_auto_host_rewrite(&mut self) -> ::protobuf::well_known_types::BoolValue {
        if self.has_auto_host_rewrite() {
            match self.host_rewrite_specifier.take() {
                ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::BoolValue::new()
        }
    }

    // string host_rewrite_header = 29;


    pub fn get_host_rewrite_header(&self) -> &str {
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_header(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_host_rewrite_header(&mut self) {
        self.host_rewrite_specifier = ::std::option::Option::None;
    }

    pub fn has_host_rewrite_header(&self) -> bool {
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_header(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_host_rewrite_header(&mut self, v: ::std::string::String) {
        self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_header(v))
    }

    // Mutable pointer to the field.
    pub fn mut_host_rewrite_header(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_header(_)) = self.host_rewrite_specifier {
        } else {
            self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_header(::std::string::String::new()));
        }
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_header(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_host_rewrite_header(&mut self) -> ::std::string::String {
        if self.has_host_rewrite_header() {
            match self.host_rewrite_specifier.take() {
                ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_header(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .envoy.type.matcher.v3.RegexMatchAndSubstitute host_rewrite_path_regex = 35;


    pub fn get_host_rewrite_path_regex(&self) -> &super::regex::RegexMatchAndSubstitute {
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_path_regex(ref v)) => v,
            _ => <super::regex::RegexMatchAndSubstitute as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_host_rewrite_path_regex(&mut self) {
        self.host_rewrite_specifier = ::std::option::Option::None;
    }

    pub fn has_host_rewrite_path_regex(&self) -> bool {
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_path_regex(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_host_rewrite_path_regex(&mut self, v: super::regex::RegexMatchAndSubstitute) {
        self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_path_regex(v))
    }

    // Mutable pointer to the field.
    pub fn mut_host_rewrite_path_regex(&mut self) -> &mut super::regex::RegexMatchAndSubstitute {
        if let ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_path_regex(_)) = self.host_rewrite_specifier {
        } else {
            self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_path_regex(super::regex::RegexMatchAndSubstitute::new()));
        }
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_path_regex(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_host_rewrite_path_regex(&mut self) -> super::regex::RegexMatchAndSubstitute {
        if self.has_host_rewrite_path_regex() {
            match self.host_rewrite_specifier.take() {
                ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_path_regex(v)) => v,
                _ => panic!(),
            }
        } else {
            super::regex::RegexMatchAndSubstitute::new()
        }
    }

    // bool append_x_forwarded_host = 38;


    pub fn get_append_x_forwarded_host(&self) -> bool {
        self.append_x_forwarded_host
    }
    pub fn clear_append_x_forwarded_host(&mut self) {
        self.append_x_forwarded_host = false;
    }

    // Param is passed by value, moved
    pub fn set_append_x_forwarded_host(&mut self, v: bool) {
        self.append_x_forwarded_host = v;
    }

    // .google.protobuf.Duration timeout = 8;


    pub fn get_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_timeout(&mut self) {
        self.timeout.clear();
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.timeout.is_none() {
            self.timeout.set_default();
        }
        self.timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration idle_timeout = 24;


    pub fn get_idle_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.idle_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_idle_timeout(&mut self) {
        self.idle_timeout.clear();
    }

    pub fn has_idle_timeout(&self) -> bool {
        self.idle_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.idle_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_idle_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.idle_timeout.is_none() {
            self.idle_timeout.set_default();
        }
        self.idle_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_idle_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.idle_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .envoy.config.route.v3.RetryPolicy retry_policy = 9;


    pub fn get_retry_policy(&self) -> &RetryPolicy {
        self.retry_policy.as_ref().unwrap_or_else(|| <RetryPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_policy(&mut self) {
        self.retry_policy.clear();
    }

    pub fn has_retry_policy(&self) -> bool {
        self.retry_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_policy(&mut self, v: RetryPolicy) {
        self.retry_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_policy(&mut self) -> &mut RetryPolicy {
        if self.retry_policy.is_none() {
            self.retry_policy.set_default();
        }
        self.retry_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_policy(&mut self) -> RetryPolicy {
        self.retry_policy.take().unwrap_or_else(|| RetryPolicy::new())
    }

    // .google.protobuf.Any retry_policy_typed_config = 33;


    pub fn get_retry_policy_typed_config(&self) -> &::protobuf::well_known_types::Any {
        self.retry_policy_typed_config.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_policy_typed_config(&mut self) {
        self.retry_policy_typed_config.clear();
    }

    pub fn has_retry_policy_typed_config(&self) -> bool {
        self.retry_policy_typed_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_policy_typed_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.retry_policy_typed_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_policy_typed_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.retry_policy_typed_config.is_none() {
            self.retry_policy_typed_config.set_default();
        }
        self.retry_policy_typed_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_policy_typed_config(&mut self) -> ::protobuf::well_known_types::Any {
        self.retry_policy_typed_config.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // repeated .envoy.config.route.v3.RouteAction.RequestMirrorPolicy request_mirror_policies = 30;


    pub fn get_request_mirror_policies(&self) -> &[RouteAction_RequestMirrorPolicy] {
        &self.request_mirror_policies
    }
    pub fn clear_request_mirror_policies(&mut self) {
        self.request_mirror_policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_mirror_policies(&mut self, v: ::protobuf::RepeatedField<RouteAction_RequestMirrorPolicy>) {
        self.request_mirror_policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_mirror_policies(&mut self) -> &mut ::protobuf::RepeatedField<RouteAction_RequestMirrorPolicy> {
        &mut self.request_mirror_policies
    }

    // Take field
    pub fn take_request_mirror_policies(&mut self) -> ::protobuf::RepeatedField<RouteAction_RequestMirrorPolicy> {
        ::std::mem::replace(&mut self.request_mirror_policies, ::protobuf::RepeatedField::new())
    }

    // .envoy.config.core.v3.RoutingPriority priority = 11;


    pub fn get_priority(&self) -> super::base::RoutingPriority {
        self.priority
    }
    pub fn clear_priority(&mut self) {
        self.priority = super::base::RoutingPriority::DEFAULT;
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: super::base::RoutingPriority) {
        self.priority = v;
    }

    // repeated .envoy.config.route.v3.RateLimit rate_limits = 13;


    pub fn get_rate_limits(&self) -> &[RateLimit] {
        &self.rate_limits
    }
    pub fn clear_rate_limits(&mut self) {
        self.rate_limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_rate_limits(&mut self, v: ::protobuf::RepeatedField<RateLimit>) {
        self.rate_limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rate_limits(&mut self) -> &mut ::protobuf::RepeatedField<RateLimit> {
        &mut self.rate_limits
    }

    // Take field
    pub fn take_rate_limits(&mut self) -> ::protobuf::RepeatedField<RateLimit> {
        ::std::mem::replace(&mut self.rate_limits, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.BoolValue include_vh_rate_limits = 14;


    pub fn get_include_vh_rate_limits(&self) -> &::protobuf::well_known_types::BoolValue {
        self.include_vh_rate_limits.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_include_vh_rate_limits(&mut self) {
        self.include_vh_rate_limits.clear();
    }

    pub fn has_include_vh_rate_limits(&self) -> bool {
        self.include_vh_rate_limits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_vh_rate_limits(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.include_vh_rate_limits = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_include_vh_rate_limits(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.include_vh_rate_limits.is_none() {
            self.include_vh_rate_limits.set_default();
        }
        self.include_vh_rate_limits.as_mut().unwrap()
    }

    // Take field
    pub fn take_include_vh_rate_limits(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.include_vh_rate_limits.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // repeated .envoy.config.route.v3.RouteAction.HashPolicy hash_policy = 15;


    pub fn get_hash_policy(&self) -> &[RouteAction_HashPolicy] {
        &self.hash_policy
    }
    pub fn clear_hash_policy(&mut self) {
        self.hash_policy.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash_policy(&mut self, v: ::protobuf::RepeatedField<RouteAction_HashPolicy>) {
        self.hash_policy = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hash_policy(&mut self) -> &mut ::protobuf::RepeatedField<RouteAction_HashPolicy> {
        &mut self.hash_policy
    }

    // Take field
    pub fn take_hash_policy(&mut self) -> ::protobuf::RepeatedField<RouteAction_HashPolicy> {
        ::std::mem::replace(&mut self.hash_policy, ::protobuf::RepeatedField::new())
    }

    // .envoy.config.route.v3.CorsPolicy cors = 17;


    pub fn get_cors(&self) -> &CorsPolicy {
        self.cors.as_ref().unwrap_or_else(|| <CorsPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cors(&mut self) {
        self.cors.clear();
    }

    pub fn has_cors(&self) -> bool {
        self.cors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cors(&mut self, v: CorsPolicy) {
        self.cors = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cors(&mut self) -> &mut CorsPolicy {
        if self.cors.is_none() {
            self.cors.set_default();
        }
        self.cors.as_mut().unwrap()
    }

    // Take field
    pub fn take_cors(&mut self) -> CorsPolicy {
        self.cors.take().unwrap_or_else(|| CorsPolicy::new())
    }

    // .google.protobuf.Duration max_grpc_timeout = 23;


    pub fn get_max_grpc_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.max_grpc_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_max_grpc_timeout(&mut self) {
        self.max_grpc_timeout.clear();
    }

    pub fn has_max_grpc_timeout(&self) -> bool {
        self.max_grpc_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_grpc_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.max_grpc_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_grpc_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.max_grpc_timeout.is_none() {
            self.max_grpc_timeout.set_default();
        }
        self.max_grpc_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_grpc_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.max_grpc_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration grpc_timeout_offset = 28;


    pub fn get_grpc_timeout_offset(&self) -> &::protobuf::well_known_types::Duration {
        self.grpc_timeout_offset.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_grpc_timeout_offset(&mut self) {
        self.grpc_timeout_offset.clear();
    }

    pub fn has_grpc_timeout_offset(&self) -> bool {
        self.grpc_timeout_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grpc_timeout_offset(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.grpc_timeout_offset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_grpc_timeout_offset(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.grpc_timeout_offset.is_none() {
            self.grpc_timeout_offset.set_default();
        }
        self.grpc_timeout_offset.as_mut().unwrap()
    }

    // Take field
    pub fn take_grpc_timeout_offset(&mut self) -> ::protobuf::well_known_types::Duration {
        self.grpc_timeout_offset.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // repeated .envoy.config.route.v3.RouteAction.UpgradeConfig upgrade_configs = 25;


    pub fn get_upgrade_configs(&self) -> &[RouteAction_UpgradeConfig] {
        &self.upgrade_configs
    }
    pub fn clear_upgrade_configs(&mut self) {
        self.upgrade_configs.clear();
    }

    // Param is passed by value, moved
    pub fn set_upgrade_configs(&mut self, v: ::protobuf::RepeatedField<RouteAction_UpgradeConfig>) {
        self.upgrade_configs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_upgrade_configs(&mut self) -> &mut ::protobuf::RepeatedField<RouteAction_UpgradeConfig> {
        &mut self.upgrade_configs
    }

    // Take field
    pub fn take_upgrade_configs(&mut self) -> ::protobuf::RepeatedField<RouteAction_UpgradeConfig> {
        ::std::mem::replace(&mut self.upgrade_configs, ::protobuf::RepeatedField::new())
    }

    // .envoy.config.route.v3.InternalRedirectPolicy internal_redirect_policy = 34;


    pub fn get_internal_redirect_policy(&self) -> &InternalRedirectPolicy {
        self.internal_redirect_policy.as_ref().unwrap_or_else(|| <InternalRedirectPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_internal_redirect_policy(&mut self) {
        self.internal_redirect_policy.clear();
    }

    pub fn has_internal_redirect_policy(&self) -> bool {
        self.internal_redirect_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_internal_redirect_policy(&mut self, v: InternalRedirectPolicy) {
        self.internal_redirect_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_internal_redirect_policy(&mut self) -> &mut InternalRedirectPolicy {
        if self.internal_redirect_policy.is_none() {
            self.internal_redirect_policy.set_default();
        }
        self.internal_redirect_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_internal_redirect_policy(&mut self) -> InternalRedirectPolicy {
        self.internal_redirect_policy.take().unwrap_or_else(|| InternalRedirectPolicy::new())
    }

    // .envoy.config.route.v3.RouteAction.InternalRedirectAction internal_redirect_action = 26;


    pub fn get_internal_redirect_action(&self) -> RouteAction_InternalRedirectAction {
        self.internal_redirect_action
    }
    pub fn clear_internal_redirect_action(&mut self) {
        self.internal_redirect_action = RouteAction_InternalRedirectAction::PASS_THROUGH_INTERNAL_REDIRECT;
    }

    // Param is passed by value, moved
    pub fn set_internal_redirect_action(&mut self, v: RouteAction_InternalRedirectAction) {
        self.internal_redirect_action = v;
    }

    // .google.protobuf.UInt32Value max_internal_redirects = 31;


    pub fn get_max_internal_redirects(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.max_internal_redirects.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_max_internal_redirects(&mut self) {
        self.max_internal_redirects.clear();
    }

    pub fn has_max_internal_redirects(&self) -> bool {
        self.max_internal_redirects.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_internal_redirects(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.max_internal_redirects = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_internal_redirects(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.max_internal_redirects.is_none() {
            self.max_internal_redirects.set_default();
        }
        self.max_internal_redirects.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_internal_redirects(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.max_internal_redirects.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // .envoy.config.route.v3.HedgePolicy hedge_policy = 27;


    pub fn get_hedge_policy(&self) -> &HedgePolicy {
        self.hedge_policy.as_ref().unwrap_or_else(|| <HedgePolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hedge_policy(&mut self) {
        self.hedge_policy.clear();
    }

    pub fn has_hedge_policy(&self) -> bool {
        self.hedge_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hedge_policy(&mut self, v: HedgePolicy) {
        self.hedge_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hedge_policy(&mut self) -> &mut HedgePolicy {
        if self.hedge_policy.is_none() {
            self.hedge_policy.set_default();
        }
        self.hedge_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_hedge_policy(&mut self) -> HedgePolicy {
        self.hedge_policy.take().unwrap_or_else(|| HedgePolicy::new())
    }

    // .envoy.config.route.v3.RouteAction.MaxStreamDuration max_stream_duration = 36;


    pub fn get_max_stream_duration(&self) -> &RouteAction_MaxStreamDuration {
        self.max_stream_duration.as_ref().unwrap_or_else(|| <RouteAction_MaxStreamDuration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_max_stream_duration(&mut self) {
        self.max_stream_duration.clear();
    }

    pub fn has_max_stream_duration(&self) -> bool {
        self.max_stream_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_stream_duration(&mut self, v: RouteAction_MaxStreamDuration) {
        self.max_stream_duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_stream_duration(&mut self) -> &mut RouteAction_MaxStreamDuration {
        if self.max_stream_duration.is_none() {
            self.max_stream_duration.set_default();
        }
        self.max_stream_duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_stream_duration(&mut self) -> RouteAction_MaxStreamDuration {
        self.max_stream_duration.take().unwrap_or_else(|| RouteAction_MaxStreamDuration::new())
    }
}

impl ::protobuf::Message for RouteAction {
    fn is_initialized(&self) -> bool {
        if let Some(RouteAction_oneof_cluster_specifier::weighted_clusters(ref v)) = self.cluster_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.metadata_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.regex_rewrite {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(ref v)) = self.host_rewrite_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_path_regex(ref v)) = self.host_rewrite_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.idle_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_policy_typed_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request_mirror_policies {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rate_limits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.include_vh_rate_limits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hash_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_grpc_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.grpc_timeout_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.upgrade_configs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.internal_redirect_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_internal_redirects {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hedge_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_stream_duration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_header(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::weighted_clusters(is.read_message()?));
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_specifier_plugin(is.read_string()?));
                },
                20 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.cluster_not_found_response_code, 20, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata_match)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix_rewrite)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.regex_rewrite)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_literal(is.read_string()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(is.read_message()?));
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_header(is.read_string()?));
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite_path_regex(is.read_message()?));
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.append_x_forwarded_host = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timeout)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.idle_timeout)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_policy)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_policy_typed_config)?;
                },
                30 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.request_mirror_policies)?;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.priority, 11, &mut self.unknown_fields)?
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rate_limits)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.include_vh_rate_limits)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hash_policy)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cors)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_grpc_timeout)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.grpc_timeout_offset)?;
                },
                25 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.upgrade_configs)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.internal_redirect_policy)?;
                },
                26 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.internal_redirect_action, 26, &mut self.unknown_fields)?
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_internal_redirects)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hedge_policy)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_stream_duration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cluster_not_found_response_code != RouteAction_ClusterNotFoundResponseCode::SERVICE_UNAVAILABLE {
            my_size += ::protobuf::rt::enum_size(20, self.cluster_not_found_response_code);
        }
        if let Some(ref v) = self.metadata_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.prefix_rewrite.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.prefix_rewrite);
        }
        if let Some(ref v) = self.regex_rewrite.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.append_x_forwarded_host != false {
            my_size += 3;
        }
        if let Some(ref v) = self.timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.idle_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.retry_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.retry_policy_typed_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.request_mirror_policies {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.priority != super::base::RoutingPriority::DEFAULT {
            my_size += ::protobuf::rt::enum_size(11, self.priority);
        }
        for value in &self.rate_limits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.include_vh_rate_limits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.hash_policy {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.cors.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.max_grpc_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.grpc_timeout_offset.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.upgrade_configs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.internal_redirect_policy.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.internal_redirect_action != RouteAction_InternalRedirectAction::PASS_THROUGH_INTERNAL_REDIRECT {
            my_size += ::protobuf::rt::enum_size(26, self.internal_redirect_action);
        }
        if let Some(ref v) = self.max_internal_redirects.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hedge_policy.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.max_stream_duration.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.cluster_specifier {
            match v {
                &RouteAction_oneof_cluster_specifier::cluster(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &RouteAction_oneof_cluster_specifier::cluster_header(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &RouteAction_oneof_cluster_specifier::weighted_clusters(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RouteAction_oneof_cluster_specifier::cluster_specifier_plugin(ref v) => {
                    my_size += ::protobuf::rt::string_size(37, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.host_rewrite_specifier {
            match v {
                &RouteAction_oneof_host_rewrite_specifier::host_rewrite_literal(ref v) => {
                    my_size += ::protobuf::rt::string_size(6, &v);
                },
                &RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RouteAction_oneof_host_rewrite_specifier::host_rewrite_header(ref v) => {
                    my_size += ::protobuf::rt::string_size(29, &v);
                },
                &RouteAction_oneof_host_rewrite_specifier::host_rewrite_path_regex(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cluster_not_found_response_code != RouteAction_ClusterNotFoundResponseCode::SERVICE_UNAVAILABLE {
            os.write_enum(20, ::protobuf::ProtobufEnum::value(&self.cluster_not_found_response_code))?;
        }
        if let Some(ref v) = self.metadata_match.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.prefix_rewrite.is_empty() {
            os.write_string(5, &self.prefix_rewrite)?;
        }
        if let Some(ref v) = self.regex_rewrite.as_ref() {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.append_x_forwarded_host != false {
            os.write_bool(38, self.append_x_forwarded_host)?;
        }
        if let Some(ref v) = self.timeout.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.idle_timeout.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.retry_policy.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.retry_policy_typed_config.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.request_mirror_policies {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.priority != super::base::RoutingPriority::DEFAULT {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.priority))?;
        }
        for v in &self.rate_limits {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.include_vh_rate_limits.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.hash_policy {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.cors.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.max_grpc_timeout.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.grpc_timeout_offset.as_ref() {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.upgrade_configs {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.internal_redirect_policy.as_ref() {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.internal_redirect_action != RouteAction_InternalRedirectAction::PASS_THROUGH_INTERNAL_REDIRECT {
            os.write_enum(26, ::protobuf::ProtobufEnum::value(&self.internal_redirect_action))?;
        }
        if let Some(ref v) = self.max_internal_redirects.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hedge_policy.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.max_stream_duration.as_ref() {
            os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.cluster_specifier {
            match v {
                &RouteAction_oneof_cluster_specifier::cluster(ref v) => {
                    os.write_string(1, v)?;
                },
                &RouteAction_oneof_cluster_specifier::cluster_header(ref v) => {
                    os.write_string(2, v)?;
                },
                &RouteAction_oneof_cluster_specifier::weighted_clusters(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RouteAction_oneof_cluster_specifier::cluster_specifier_plugin(ref v) => {
                    os.write_string(37, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.host_rewrite_specifier {
            match v {
                &RouteAction_oneof_host_rewrite_specifier::host_rewrite_literal(ref v) => {
                    os.write_string(6, v)?;
                },
                &RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RouteAction_oneof_host_rewrite_specifier::host_rewrite_header(ref v) => {
                    os.write_string(29, v)?;
                },
                &RouteAction_oneof_host_rewrite_specifier::host_rewrite_path_regex(ref v) => {
                    os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction {
        RouteAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "cluster",
                RouteAction::has_cluster,
                RouteAction::get_cluster,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "cluster_header",
                RouteAction::has_cluster_header,
                RouteAction::get_cluster_header,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WeightedCluster>(
                "weighted_clusters",
                RouteAction::has_weighted_clusters,
                RouteAction::get_weighted_clusters,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "cluster_specifier_plugin",
                RouteAction::has_cluster_specifier_plugin,
                RouteAction::get_cluster_specifier_plugin,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RouteAction_ClusterNotFoundResponseCode>>(
                "cluster_not_found_response_code",
                |m: &RouteAction| { &m.cluster_not_found_response_code },
                |m: &mut RouteAction| { &mut m.cluster_not_found_response_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::Metadata>>(
                "metadata_match",
                |m: &RouteAction| { &m.metadata_match },
                |m: &mut RouteAction| { &mut m.metadata_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "prefix_rewrite",
                |m: &RouteAction| { &m.prefix_rewrite },
                |m: &mut RouteAction| { &mut m.prefix_rewrite },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::regex::RegexMatchAndSubstitute>>(
                "regex_rewrite",
                |m: &RouteAction| { &m.regex_rewrite },
                |m: &mut RouteAction| { &mut m.regex_rewrite },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "host_rewrite_literal",
                RouteAction::has_host_rewrite_literal,
                RouteAction::get_host_rewrite_literal,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::BoolValue>(
                "auto_host_rewrite",
                RouteAction::has_auto_host_rewrite,
                RouteAction::get_auto_host_rewrite,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "host_rewrite_header",
                RouteAction::has_host_rewrite_header,
                RouteAction::get_host_rewrite_header,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::regex::RegexMatchAndSubstitute>(
                "host_rewrite_path_regex",
                RouteAction::has_host_rewrite_path_regex,
                RouteAction::get_host_rewrite_path_regex,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "append_x_forwarded_host",
                |m: &RouteAction| { &m.append_x_forwarded_host },
                |m: &mut RouteAction| { &mut m.append_x_forwarded_host },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "timeout",
                |m: &RouteAction| { &m.timeout },
                |m: &mut RouteAction| { &mut m.timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "idle_timeout",
                |m: &RouteAction| { &m.idle_timeout },
                |m: &mut RouteAction| { &mut m.idle_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RetryPolicy>>(
                "retry_policy",
                |m: &RouteAction| { &m.retry_policy },
                |m: &mut RouteAction| { &mut m.retry_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "retry_policy_typed_config",
                |m: &RouteAction| { &m.retry_policy_typed_config },
                |m: &mut RouteAction| { &mut m.retry_policy_typed_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteAction_RequestMirrorPolicy>>(
                "request_mirror_policies",
                |m: &RouteAction| { &m.request_mirror_policies },
                |m: &mut RouteAction| { &mut m.request_mirror_policies },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::base::RoutingPriority>>(
                "priority",
                |m: &RouteAction| { &m.priority },
                |m: &mut RouteAction| { &mut m.priority },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateLimit>>(
                "rate_limits",
                |m: &RouteAction| { &m.rate_limits },
                |m: &mut RouteAction| { &mut m.rate_limits },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "include_vh_rate_limits",
                |m: &RouteAction| { &m.include_vh_rate_limits },
                |m: &mut RouteAction| { &mut m.include_vh_rate_limits },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteAction_HashPolicy>>(
                "hash_policy",
                |m: &RouteAction| { &m.hash_policy },
                |m: &mut RouteAction| { &mut m.hash_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CorsPolicy>>(
                "cors",
                |m: &RouteAction| { &m.cors },
                |m: &mut RouteAction| { &mut m.cors },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "max_grpc_timeout",
                |m: &RouteAction| { &m.max_grpc_timeout },
                |m: &mut RouteAction| { &mut m.max_grpc_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "grpc_timeout_offset",
                |m: &RouteAction| { &m.grpc_timeout_offset },
                |m: &mut RouteAction| { &mut m.grpc_timeout_offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteAction_UpgradeConfig>>(
                "upgrade_configs",
                |m: &RouteAction| { &m.upgrade_configs },
                |m: &mut RouteAction| { &mut m.upgrade_configs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InternalRedirectPolicy>>(
                "internal_redirect_policy",
                |m: &RouteAction| { &m.internal_redirect_policy },
                |m: &mut RouteAction| { &mut m.internal_redirect_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RouteAction_InternalRedirectAction>>(
                "internal_redirect_action",
                |m: &RouteAction| { &m.internal_redirect_action },
                |m: &mut RouteAction| { &mut m.internal_redirect_action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "max_internal_redirects",
                |m: &RouteAction| { &m.max_internal_redirects },
                |m: &mut RouteAction| { &mut m.max_internal_redirects },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HedgePolicy>>(
                "hedge_policy",
                |m: &RouteAction| { &m.hedge_policy },
                |m: &mut RouteAction| { &mut m.hedge_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteAction_MaxStreamDuration>>(
                "max_stream_duration",
                |m: &RouteAction| { &m.max_stream_duration },
                |m: &mut RouteAction| { &mut m.max_stream_duration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction>(
                "RouteAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction {
        static instance: ::protobuf::rt::LazyV2<RouteAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction::new)
    }
}

impl ::protobuf::Clear for RouteAction {
    fn clear(&mut self) {
        self.cluster_specifier = ::std::option::Option::None;
        self.cluster_specifier = ::std::option::Option::None;
        self.cluster_specifier = ::std::option::Option::None;
        self.cluster_specifier = ::std::option::Option::None;
        self.cluster_not_found_response_code = RouteAction_ClusterNotFoundResponseCode::SERVICE_UNAVAILABLE;
        self.metadata_match.clear();
        self.prefix_rewrite.clear();
        self.regex_rewrite.clear();
        self.host_rewrite_specifier = ::std::option::Option::None;
        self.host_rewrite_specifier = ::std::option::Option::None;
        self.host_rewrite_specifier = ::std::option::Option::None;
        self.host_rewrite_specifier = ::std::option::Option::None;
        self.append_x_forwarded_host = false;
        self.timeout.clear();
        self.idle_timeout.clear();
        self.retry_policy.clear();
        self.retry_policy_typed_config.clear();
        self.request_mirror_policies.clear();
        self.priority = super::base::RoutingPriority::DEFAULT;
        self.rate_limits.clear();
        self.include_vh_rate_limits.clear();
        self.hash_policy.clear();
        self.cors.clear();
        self.max_grpc_timeout.clear();
        self.grpc_timeout_offset.clear();
        self.upgrade_configs.clear();
        self.internal_redirect_policy.clear();
        self.internal_redirect_action = RouteAction_InternalRedirectAction::PASS_THROUGH_INTERNAL_REDIRECT;
        self.max_internal_redirects.clear();
        self.hedge_policy.clear();
        self.max_stream_duration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteAction_RequestMirrorPolicy {
    // message fields
    pub cluster: ::std::string::String,
    pub runtime_fraction: ::protobuf::SingularPtrField<super::base::RuntimeFractionalPercent>,
    pub trace_sampled: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_RequestMirrorPolicy {
    fn default() -> &'a RouteAction_RequestMirrorPolicy {
        <RouteAction_RequestMirrorPolicy as ::protobuf::Message>::default_instance()
    }
}

impl RouteAction_RequestMirrorPolicy {
    pub fn new() -> RouteAction_RequestMirrorPolicy {
        ::std::default::Default::default()
    }

    // string cluster = 1;


    pub fn get_cluster(&self) -> &str {
        &self.cluster
    }
    pub fn clear_cluster(&mut self) {
        self.cluster.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: ::std::string::String) {
        self.cluster = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster(&mut self) -> &mut ::std::string::String {
        &mut self.cluster
    }

    // Take field
    pub fn take_cluster(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster, ::std::string::String::new())
    }

    // .envoy.config.core.v3.RuntimeFractionalPercent runtime_fraction = 3;


    pub fn get_runtime_fraction(&self) -> &super::base::RuntimeFractionalPercent {
        self.runtime_fraction.as_ref().unwrap_or_else(|| <super::base::RuntimeFractionalPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_runtime_fraction(&mut self) {
        self.runtime_fraction.clear();
    }

    pub fn has_runtime_fraction(&self) -> bool {
        self.runtime_fraction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runtime_fraction(&mut self, v: super::base::RuntimeFractionalPercent) {
        self.runtime_fraction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_fraction(&mut self) -> &mut super::base::RuntimeFractionalPercent {
        if self.runtime_fraction.is_none() {
            self.runtime_fraction.set_default();
        }
        self.runtime_fraction.as_mut().unwrap()
    }

    // Take field
    pub fn take_runtime_fraction(&mut self) -> super::base::RuntimeFractionalPercent {
        self.runtime_fraction.take().unwrap_or_else(|| super::base::RuntimeFractionalPercent::new())
    }

    // .google.protobuf.BoolValue trace_sampled = 4;


    pub fn get_trace_sampled(&self) -> &::protobuf::well_known_types::BoolValue {
        self.trace_sampled.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trace_sampled(&mut self) {
        self.trace_sampled.clear();
    }

    pub fn has_trace_sampled(&self) -> bool {
        self.trace_sampled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trace_sampled(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.trace_sampled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_sampled(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.trace_sampled.is_none() {
            self.trace_sampled.set_default();
        }
        self.trace_sampled.as_mut().unwrap()
    }

    // Take field
    pub fn take_trace_sampled(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.trace_sampled.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }
}

impl ::protobuf::Message for RouteAction_RequestMirrorPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.runtime_fraction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trace_sampled {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.runtime_fraction)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trace_sampled)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.cluster.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cluster);
        }
        if let Some(ref v) = self.runtime_fraction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.trace_sampled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.cluster.is_empty() {
            os.write_string(1, &self.cluster)?;
        }
        if let Some(ref v) = self.runtime_fraction.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.trace_sampled.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_RequestMirrorPolicy {
        RouteAction_RequestMirrorPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster",
                |m: &RouteAction_RequestMirrorPolicy| { &m.cluster },
                |m: &mut RouteAction_RequestMirrorPolicy| { &mut m.cluster },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::RuntimeFractionalPercent>>(
                "runtime_fraction",
                |m: &RouteAction_RequestMirrorPolicy| { &m.runtime_fraction },
                |m: &mut RouteAction_RequestMirrorPolicy| { &mut m.runtime_fraction },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "trace_sampled",
                |m: &RouteAction_RequestMirrorPolicy| { &m.trace_sampled },
                |m: &mut RouteAction_RequestMirrorPolicy| { &mut m.trace_sampled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_RequestMirrorPolicy>(
                "RouteAction.RequestMirrorPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_RequestMirrorPolicy {
        static instance: ::protobuf::rt::LazyV2<RouteAction_RequestMirrorPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_RequestMirrorPolicy::new)
    }
}

impl ::protobuf::Clear for RouteAction_RequestMirrorPolicy {
    fn clear(&mut self) {
        self.cluster.clear();
        self.runtime_fraction.clear();
        self.trace_sampled.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_RequestMirrorPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_RequestMirrorPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteAction_HashPolicy {
    // message fields
    pub terminal: bool,
    // message oneof groups
    pub policy_specifier: ::std::option::Option<RouteAction_HashPolicy_oneof_policy_specifier>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_HashPolicy {
    fn default() -> &'a RouteAction_HashPolicy {
        <RouteAction_HashPolicy as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RouteAction_HashPolicy_oneof_policy_specifier {
    header(RouteAction_HashPolicy_Header),
    cookie(RouteAction_HashPolicy_Cookie),
    connection_properties(RouteAction_HashPolicy_ConnectionProperties),
    query_parameter(RouteAction_HashPolicy_QueryParameter),
    filter_state(RouteAction_HashPolicy_FilterState),
}

impl RouteAction_HashPolicy {
    pub fn new() -> RouteAction_HashPolicy {
        ::std::default::Default::default()
    }

    // .envoy.config.route.v3.RouteAction.HashPolicy.Header header = 1;


    pub fn get_header(&self) -> &RouteAction_HashPolicy_Header {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::header(ref v)) => v,
            _ => <RouteAction_HashPolicy_Header as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_header(&mut self) {
        self.policy_specifier = ::std::option::Option::None;
    }

    pub fn has_header(&self) -> bool {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::header(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: RouteAction_HashPolicy_Header) {
        self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::header(v))
    }

    // Mutable pointer to the field.
    pub fn mut_header(&mut self) -> &mut RouteAction_HashPolicy_Header {
        if let ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::header(_)) = self.policy_specifier {
        } else {
            self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::header(RouteAction_HashPolicy_Header::new()));
        }
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::header(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_header(&mut self) -> RouteAction_HashPolicy_Header {
        if self.has_header() {
            match self.policy_specifier.take() {
                ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::header(v)) => v,
                _ => panic!(),
            }
        } else {
            RouteAction_HashPolicy_Header::new()
        }
    }

    // .envoy.config.route.v3.RouteAction.HashPolicy.Cookie cookie = 2;


    pub fn get_cookie(&self) -> &RouteAction_HashPolicy_Cookie {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(ref v)) => v,
            _ => <RouteAction_HashPolicy_Cookie as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_cookie(&mut self) {
        self.policy_specifier = ::std::option::Option::None;
    }

    pub fn has_cookie(&self) -> bool {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: RouteAction_HashPolicy_Cookie) {
        self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cookie(&mut self) -> &mut RouteAction_HashPolicy_Cookie {
        if let ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(_)) = self.policy_specifier {
        } else {
            self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(RouteAction_HashPolicy_Cookie::new()));
        }
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cookie(&mut self) -> RouteAction_HashPolicy_Cookie {
        if self.has_cookie() {
            match self.policy_specifier.take() {
                ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(v)) => v,
                _ => panic!(),
            }
        } else {
            RouteAction_HashPolicy_Cookie::new()
        }
    }

    // .envoy.config.route.v3.RouteAction.HashPolicy.ConnectionProperties connection_properties = 3;


    pub fn get_connection_properties(&self) -> &RouteAction_HashPolicy_ConnectionProperties {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(ref v)) => v,
            _ => <RouteAction_HashPolicy_ConnectionProperties as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_connection_properties(&mut self) {
        self.policy_specifier = ::std::option::Option::None;
    }

    pub fn has_connection_properties(&self) -> bool {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_connection_properties(&mut self, v: RouteAction_HashPolicy_ConnectionProperties) {
        self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(v))
    }

    // Mutable pointer to the field.
    pub fn mut_connection_properties(&mut self) -> &mut RouteAction_HashPolicy_ConnectionProperties {
        if let ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(_)) = self.policy_specifier {
        } else {
            self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(RouteAction_HashPolicy_ConnectionProperties::new()));
        }
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_connection_properties(&mut self) -> RouteAction_HashPolicy_ConnectionProperties {
        if self.has_connection_properties() {
            match self.policy_specifier.take() {
                ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(v)) => v,
                _ => panic!(),
            }
        } else {
            RouteAction_HashPolicy_ConnectionProperties::new()
        }
    }

    // .envoy.config.route.v3.RouteAction.HashPolicy.QueryParameter query_parameter = 5;


    pub fn get_query_parameter(&self) -> &RouteAction_HashPolicy_QueryParameter {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(ref v)) => v,
            _ => <RouteAction_HashPolicy_QueryParameter as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_query_parameter(&mut self) {
        self.policy_specifier = ::std::option::Option::None;
    }

    pub fn has_query_parameter(&self) -> bool {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_query_parameter(&mut self, v: RouteAction_HashPolicy_QueryParameter) {
        self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_query_parameter(&mut self) -> &mut RouteAction_HashPolicy_QueryParameter {
        if let ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(_)) = self.policy_specifier {
        } else {
            self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(RouteAction_HashPolicy_QueryParameter::new()));
        }
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_query_parameter(&mut self) -> RouteAction_HashPolicy_QueryParameter {
        if self.has_query_parameter() {
            match self.policy_specifier.take() {
                ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(v)) => v,
                _ => panic!(),
            }
        } else {
            RouteAction_HashPolicy_QueryParameter::new()
        }
    }

    // .envoy.config.route.v3.RouteAction.HashPolicy.FilterState filter_state = 6;


    pub fn get_filter_state(&self) -> &RouteAction_HashPolicy_FilterState {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(ref v)) => v,
            _ => <RouteAction_HashPolicy_FilterState as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_filter_state(&mut self) {
        self.policy_specifier = ::std::option::Option::None;
    }

    pub fn has_filter_state(&self) -> bool {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_filter_state(&mut self, v: RouteAction_HashPolicy_FilterState) {
        self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(v))
    }

    // Mutable pointer to the field.
    pub fn mut_filter_state(&mut self) -> &mut RouteAction_HashPolicy_FilterState {
        if let ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(_)) = self.policy_specifier {
        } else {
            self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(RouteAction_HashPolicy_FilterState::new()));
        }
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_filter_state(&mut self) -> RouteAction_HashPolicy_FilterState {
        if self.has_filter_state() {
            match self.policy_specifier.take() {
                ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(v)) => v,
                _ => panic!(),
            }
        } else {
            RouteAction_HashPolicy_FilterState::new()
        }
    }

    // bool terminal = 4;


    pub fn get_terminal(&self) -> bool {
        self.terminal
    }
    pub fn clear_terminal(&mut self) {
        self.terminal = false;
    }

    // Param is passed by value, moved
    pub fn set_terminal(&mut self, v: bool) {
        self.terminal = v;
    }
}

impl ::protobuf::Message for RouteAction_HashPolicy {
    fn is_initialized(&self) -> bool {
        if let Some(RouteAction_HashPolicy_oneof_policy_specifier::header(ref v)) = self.policy_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(ref v)) = self.policy_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(ref v)) = self.policy_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(ref v)) = self.policy_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(ref v)) = self.policy_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::header(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.terminal = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.terminal != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.policy_specifier {
            match v {
                &RouteAction_HashPolicy_oneof_policy_specifier::header(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RouteAction_HashPolicy_oneof_policy_specifier::cookie(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RouteAction_HashPolicy_oneof_policy_specifier::filter_state(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.terminal != false {
            os.write_bool(4, self.terminal)?;
        }
        if let ::std::option::Option::Some(ref v) = self.policy_specifier {
            match v {
                &RouteAction_HashPolicy_oneof_policy_specifier::header(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RouteAction_HashPolicy_oneof_policy_specifier::cookie(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RouteAction_HashPolicy_oneof_policy_specifier::filter_state(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_HashPolicy {
        RouteAction_HashPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RouteAction_HashPolicy_Header>(
                "header",
                RouteAction_HashPolicy::has_header,
                RouteAction_HashPolicy::get_header,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RouteAction_HashPolicy_Cookie>(
                "cookie",
                RouteAction_HashPolicy::has_cookie,
                RouteAction_HashPolicy::get_cookie,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RouteAction_HashPolicy_ConnectionProperties>(
                "connection_properties",
                RouteAction_HashPolicy::has_connection_properties,
                RouteAction_HashPolicy::get_connection_properties,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RouteAction_HashPolicy_QueryParameter>(
                "query_parameter",
                RouteAction_HashPolicy::has_query_parameter,
                RouteAction_HashPolicy::get_query_parameter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RouteAction_HashPolicy_FilterState>(
                "filter_state",
                RouteAction_HashPolicy::has_filter_state,
                RouteAction_HashPolicy::get_filter_state,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "terminal",
                |m: &RouteAction_HashPolicy| { &m.terminal },
                |m: &mut RouteAction_HashPolicy| { &mut m.terminal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_HashPolicy>(
                "RouteAction.HashPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_HashPolicy {
        static instance: ::protobuf::rt::LazyV2<RouteAction_HashPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_HashPolicy::new)
    }
}

impl ::protobuf::Clear for RouteAction_HashPolicy {
    fn clear(&mut self) {
        self.policy_specifier = ::std::option::Option::None;
        self.policy_specifier = ::std::option::Option::None;
        self.policy_specifier = ::std::option::Option::None;
        self.policy_specifier = ::std::option::Option::None;
        self.policy_specifier = ::std::option::Option::None;
        self.terminal = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_HashPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_HashPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteAction_HashPolicy_Header {
    // message fields
    pub header_name: ::std::string::String,
    pub regex_rewrite: ::protobuf::SingularPtrField<super::regex::RegexMatchAndSubstitute>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_HashPolicy_Header {
    fn default() -> &'a RouteAction_HashPolicy_Header {
        <RouteAction_HashPolicy_Header as ::protobuf::Message>::default_instance()
    }
}

impl RouteAction_HashPolicy_Header {
    pub fn new() -> RouteAction_HashPolicy_Header {
        ::std::default::Default::default()
    }

    // string header_name = 1;


    pub fn get_header_name(&self) -> &str {
        &self.header_name
    }
    pub fn clear_header_name(&mut self) {
        self.header_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_header_name(&mut self, v: ::std::string::String) {
        self.header_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header_name(&mut self) -> &mut ::std::string::String {
        &mut self.header_name
    }

    // Take field
    pub fn take_header_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.header_name, ::std::string::String::new())
    }

    // .envoy.type.matcher.v3.RegexMatchAndSubstitute regex_rewrite = 2;


    pub fn get_regex_rewrite(&self) -> &super::regex::RegexMatchAndSubstitute {
        self.regex_rewrite.as_ref().unwrap_or_else(|| <super::regex::RegexMatchAndSubstitute as ::protobuf::Message>::default_instance())
    }
    pub fn clear_regex_rewrite(&mut self) {
        self.regex_rewrite.clear();
    }

    pub fn has_regex_rewrite(&self) -> bool {
        self.regex_rewrite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_regex_rewrite(&mut self, v: super::regex::RegexMatchAndSubstitute) {
        self.regex_rewrite = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_regex_rewrite(&mut self) -> &mut super::regex::RegexMatchAndSubstitute {
        if self.regex_rewrite.is_none() {
            self.regex_rewrite.set_default();
        }
        self.regex_rewrite.as_mut().unwrap()
    }

    // Take field
    pub fn take_regex_rewrite(&mut self) -> super::regex::RegexMatchAndSubstitute {
        self.regex_rewrite.take().unwrap_or_else(|| super::regex::RegexMatchAndSubstitute::new())
    }
}

impl ::protobuf::Message for RouteAction_HashPolicy_Header {
    fn is_initialized(&self) -> bool {
        for v in &self.regex_rewrite {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.header_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.regex_rewrite)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.header_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.header_name);
        }
        if let Some(ref v) = self.regex_rewrite.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.header_name.is_empty() {
            os.write_string(1, &self.header_name)?;
        }
        if let Some(ref v) = self.regex_rewrite.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_HashPolicy_Header {
        RouteAction_HashPolicy_Header::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "header_name",
                |m: &RouteAction_HashPolicy_Header| { &m.header_name },
                |m: &mut RouteAction_HashPolicy_Header| { &mut m.header_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::regex::RegexMatchAndSubstitute>>(
                "regex_rewrite",
                |m: &RouteAction_HashPolicy_Header| { &m.regex_rewrite },
                |m: &mut RouteAction_HashPolicy_Header| { &mut m.regex_rewrite },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_HashPolicy_Header>(
                "RouteAction.HashPolicy.Header",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_HashPolicy_Header {
        static instance: ::protobuf::rt::LazyV2<RouteAction_HashPolicy_Header> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_HashPolicy_Header::new)
    }
}

impl ::protobuf::Clear for RouteAction_HashPolicy_Header {
    fn clear(&mut self) {
        self.header_name.clear();
        self.regex_rewrite.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_HashPolicy_Header {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_HashPolicy_Header {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteAction_HashPolicy_Cookie {
    // message fields
    pub name: ::std::string::String,
    pub ttl: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub path: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_HashPolicy_Cookie {
    fn default() -> &'a RouteAction_HashPolicy_Cookie {
        <RouteAction_HashPolicy_Cookie as ::protobuf::Message>::default_instance()
    }
}

impl RouteAction_HashPolicy_Cookie {
    pub fn new() -> RouteAction_HashPolicy_Cookie {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Duration ttl = 2;


    pub fn get_ttl(&self) -> &::protobuf::well_known_types::Duration {
        self.ttl.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ttl(&mut self) {
        self.ttl.clear();
    }

    pub fn has_ttl(&self) -> bool {
        self.ttl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ttl(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.ttl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ttl(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.ttl.is_none() {
            self.ttl.set_default();
        }
        self.ttl.as_mut().unwrap()
    }

    // Take field
    pub fn take_ttl(&mut self) -> ::protobuf::well_known_types::Duration {
        self.ttl.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // string path = 3;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RouteAction_HashPolicy_Cookie {
    fn is_initialized(&self) -> bool {
        for v in &self.ttl {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ttl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.ttl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.ttl.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.path.is_empty() {
            os.write_string(3, &self.path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_HashPolicy_Cookie {
        RouteAction_HashPolicy_Cookie::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RouteAction_HashPolicy_Cookie| { &m.name },
                |m: &mut RouteAction_HashPolicy_Cookie| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "ttl",
                |m: &RouteAction_HashPolicy_Cookie| { &m.ttl },
                |m: &mut RouteAction_HashPolicy_Cookie| { &mut m.ttl },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &RouteAction_HashPolicy_Cookie| { &m.path },
                |m: &mut RouteAction_HashPolicy_Cookie| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_HashPolicy_Cookie>(
                "RouteAction.HashPolicy.Cookie",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_HashPolicy_Cookie {
        static instance: ::protobuf::rt::LazyV2<RouteAction_HashPolicy_Cookie> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_HashPolicy_Cookie::new)
    }
}

impl ::protobuf::Clear for RouteAction_HashPolicy_Cookie {
    fn clear(&mut self) {
        self.name.clear();
        self.ttl.clear();
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_HashPolicy_Cookie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_HashPolicy_Cookie {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteAction_HashPolicy_ConnectionProperties {
    // message fields
    pub source_ip: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_HashPolicy_ConnectionProperties {
    fn default() -> &'a RouteAction_HashPolicy_ConnectionProperties {
        <RouteAction_HashPolicy_ConnectionProperties as ::protobuf::Message>::default_instance()
    }
}

impl RouteAction_HashPolicy_ConnectionProperties {
    pub fn new() -> RouteAction_HashPolicy_ConnectionProperties {
        ::std::default::Default::default()
    }

    // bool source_ip = 1;


    pub fn get_source_ip(&self) -> bool {
        self.source_ip
    }
    pub fn clear_source_ip(&mut self) {
        self.source_ip = false;
    }

    // Param is passed by value, moved
    pub fn set_source_ip(&mut self, v: bool) {
        self.source_ip = v;
    }
}

impl ::protobuf::Message for RouteAction_HashPolicy_ConnectionProperties {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.source_ip = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.source_ip != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.source_ip != false {
            os.write_bool(1, self.source_ip)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_HashPolicy_ConnectionProperties {
        RouteAction_HashPolicy_ConnectionProperties::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "source_ip",
                |m: &RouteAction_HashPolicy_ConnectionProperties| { &m.source_ip },
                |m: &mut RouteAction_HashPolicy_ConnectionProperties| { &mut m.source_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_HashPolicy_ConnectionProperties>(
                "RouteAction.HashPolicy.ConnectionProperties",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_HashPolicy_ConnectionProperties {
        static instance: ::protobuf::rt::LazyV2<RouteAction_HashPolicy_ConnectionProperties> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_HashPolicy_ConnectionProperties::new)
    }
}

impl ::protobuf::Clear for RouteAction_HashPolicy_ConnectionProperties {
    fn clear(&mut self) {
        self.source_ip = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_HashPolicy_ConnectionProperties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_HashPolicy_ConnectionProperties {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteAction_HashPolicy_QueryParameter {
    // message fields
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_HashPolicy_QueryParameter {
    fn default() -> &'a RouteAction_HashPolicy_QueryParameter {
        <RouteAction_HashPolicy_QueryParameter as ::protobuf::Message>::default_instance()
    }
}

impl RouteAction_HashPolicy_QueryParameter {
    pub fn new() -> RouteAction_HashPolicy_QueryParameter {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RouteAction_HashPolicy_QueryParameter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_HashPolicy_QueryParameter {
        RouteAction_HashPolicy_QueryParameter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RouteAction_HashPolicy_QueryParameter| { &m.name },
                |m: &mut RouteAction_HashPolicy_QueryParameter| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_HashPolicy_QueryParameter>(
                "RouteAction.HashPolicy.QueryParameter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_HashPolicy_QueryParameter {
        static instance: ::protobuf::rt::LazyV2<RouteAction_HashPolicy_QueryParameter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_HashPolicy_QueryParameter::new)
    }
}

impl ::protobuf::Clear for RouteAction_HashPolicy_QueryParameter {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_HashPolicy_QueryParameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_HashPolicy_QueryParameter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteAction_HashPolicy_FilterState {
    // message fields
    pub key: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_HashPolicy_FilterState {
    fn default() -> &'a RouteAction_HashPolicy_FilterState {
        <RouteAction_HashPolicy_FilterState as ::protobuf::Message>::default_instance()
    }
}

impl RouteAction_HashPolicy_FilterState {
    pub fn new() -> RouteAction_HashPolicy_FilterState {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RouteAction_HashPolicy_FilterState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_HashPolicy_FilterState {
        RouteAction_HashPolicy_FilterState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &RouteAction_HashPolicy_FilterState| { &m.key },
                |m: &mut RouteAction_HashPolicy_FilterState| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_HashPolicy_FilterState>(
                "RouteAction.HashPolicy.FilterState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_HashPolicy_FilterState {
        static instance: ::protobuf::rt::LazyV2<RouteAction_HashPolicy_FilterState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_HashPolicy_FilterState::new)
    }
}

impl ::protobuf::Clear for RouteAction_HashPolicy_FilterState {
    fn clear(&mut self) {
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_HashPolicy_FilterState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_HashPolicy_FilterState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteAction_UpgradeConfig {
    // message fields
    pub upgrade_type: ::std::string::String,
    pub enabled: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub connect_config: ::protobuf::SingularPtrField<RouteAction_UpgradeConfig_ConnectConfig>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_UpgradeConfig {
    fn default() -> &'a RouteAction_UpgradeConfig {
        <RouteAction_UpgradeConfig as ::protobuf::Message>::default_instance()
    }
}

impl RouteAction_UpgradeConfig {
    pub fn new() -> RouteAction_UpgradeConfig {
        ::std::default::Default::default()
    }

    // string upgrade_type = 1;


    pub fn get_upgrade_type(&self) -> &str {
        &self.upgrade_type
    }
    pub fn clear_upgrade_type(&mut self) {
        self.upgrade_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_upgrade_type(&mut self, v: ::std::string::String) {
        self.upgrade_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upgrade_type(&mut self) -> &mut ::std::string::String {
        &mut self.upgrade_type
    }

    // Take field
    pub fn take_upgrade_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.upgrade_type, ::std::string::String::new())
    }

    // .google.protobuf.BoolValue enabled = 2;


    pub fn get_enabled(&self) -> &::protobuf::well_known_types::BoolValue {
        self.enabled.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_enabled(&mut self) {
        self.enabled.clear();
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.enabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_enabled(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.enabled.is_none() {
            self.enabled.set_default();
        }
        self.enabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_enabled(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.enabled.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .envoy.config.route.v3.RouteAction.UpgradeConfig.ConnectConfig connect_config = 3;


    pub fn get_connect_config(&self) -> &RouteAction_UpgradeConfig_ConnectConfig {
        self.connect_config.as_ref().unwrap_or_else(|| <RouteAction_UpgradeConfig_ConnectConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_connect_config(&mut self) {
        self.connect_config.clear();
    }

    pub fn has_connect_config(&self) -> bool {
        self.connect_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_config(&mut self, v: RouteAction_UpgradeConfig_ConnectConfig) {
        self.connect_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect_config(&mut self) -> &mut RouteAction_UpgradeConfig_ConnectConfig {
        if self.connect_config.is_none() {
            self.connect_config.set_default();
        }
        self.connect_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect_config(&mut self) -> RouteAction_UpgradeConfig_ConnectConfig {
        self.connect_config.take().unwrap_or_else(|| RouteAction_UpgradeConfig_ConnectConfig::new())
    }
}

impl ::protobuf::Message for RouteAction_UpgradeConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.enabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.connect_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.upgrade_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.enabled)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connect_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.upgrade_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.upgrade_type);
        }
        if let Some(ref v) = self.enabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.connect_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.upgrade_type.is_empty() {
            os.write_string(1, &self.upgrade_type)?;
        }
        if let Some(ref v) = self.enabled.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.connect_config.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_UpgradeConfig {
        RouteAction_UpgradeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "upgrade_type",
                |m: &RouteAction_UpgradeConfig| { &m.upgrade_type },
                |m: &mut RouteAction_UpgradeConfig| { &mut m.upgrade_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "enabled",
                |m: &RouteAction_UpgradeConfig| { &m.enabled },
                |m: &mut RouteAction_UpgradeConfig| { &mut m.enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteAction_UpgradeConfig_ConnectConfig>>(
                "connect_config",
                |m: &RouteAction_UpgradeConfig| { &m.connect_config },
                |m: &mut RouteAction_UpgradeConfig| { &mut m.connect_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_UpgradeConfig>(
                "RouteAction.UpgradeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_UpgradeConfig {
        static instance: ::protobuf::rt::LazyV2<RouteAction_UpgradeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_UpgradeConfig::new)
    }
}

impl ::protobuf::Clear for RouteAction_UpgradeConfig {
    fn clear(&mut self) {
        self.upgrade_type.clear();
        self.enabled.clear();
        self.connect_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_UpgradeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_UpgradeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteAction_UpgradeConfig_ConnectConfig {
    // message fields
    pub proxy_protocol_config: ::protobuf::SingularPtrField<super::proxy_protocol::ProxyProtocolConfig>,
    pub allow_post: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_UpgradeConfig_ConnectConfig {
    fn default() -> &'a RouteAction_UpgradeConfig_ConnectConfig {
        <RouteAction_UpgradeConfig_ConnectConfig as ::protobuf::Message>::default_instance()
    }
}

impl RouteAction_UpgradeConfig_ConnectConfig {
    pub fn new() -> RouteAction_UpgradeConfig_ConnectConfig {
        ::std::default::Default::default()
    }

    // .envoy.config.core.v3.ProxyProtocolConfig proxy_protocol_config = 1;


    pub fn get_proxy_protocol_config(&self) -> &super::proxy_protocol::ProxyProtocolConfig {
        self.proxy_protocol_config.as_ref().unwrap_or_else(|| <super::proxy_protocol::ProxyProtocolConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_proxy_protocol_config(&mut self) {
        self.proxy_protocol_config.clear();
    }

    pub fn has_proxy_protocol_config(&self) -> bool {
        self.proxy_protocol_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxy_protocol_config(&mut self, v: super::proxy_protocol::ProxyProtocolConfig) {
        self.proxy_protocol_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proxy_protocol_config(&mut self) -> &mut super::proxy_protocol::ProxyProtocolConfig {
        if self.proxy_protocol_config.is_none() {
            self.proxy_protocol_config.set_default();
        }
        self.proxy_protocol_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_proxy_protocol_config(&mut self) -> super::proxy_protocol::ProxyProtocolConfig {
        self.proxy_protocol_config.take().unwrap_or_else(|| super::proxy_protocol::ProxyProtocolConfig::new())
    }

    // bool allow_post = 2;


    pub fn get_allow_post(&self) -> bool {
        self.allow_post
    }
    pub fn clear_allow_post(&mut self) {
        self.allow_post = false;
    }

    // Param is passed by value, moved
    pub fn set_allow_post(&mut self, v: bool) {
        self.allow_post = v;
    }
}

impl ::protobuf::Message for RouteAction_UpgradeConfig_ConnectConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.proxy_protocol_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proxy_protocol_config)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_post = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.proxy_protocol_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.allow_post != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.proxy_protocol_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.allow_post != false {
            os.write_bool(2, self.allow_post)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_UpgradeConfig_ConnectConfig {
        RouteAction_UpgradeConfig_ConnectConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::proxy_protocol::ProxyProtocolConfig>>(
                "proxy_protocol_config",
                |m: &RouteAction_UpgradeConfig_ConnectConfig| { &m.proxy_protocol_config },
                |m: &mut RouteAction_UpgradeConfig_ConnectConfig| { &mut m.proxy_protocol_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_post",
                |m: &RouteAction_UpgradeConfig_ConnectConfig| { &m.allow_post },
                |m: &mut RouteAction_UpgradeConfig_ConnectConfig| { &mut m.allow_post },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_UpgradeConfig_ConnectConfig>(
                "RouteAction.UpgradeConfig.ConnectConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_UpgradeConfig_ConnectConfig {
        static instance: ::protobuf::rt::LazyV2<RouteAction_UpgradeConfig_ConnectConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_UpgradeConfig_ConnectConfig::new)
    }
}

impl ::protobuf::Clear for RouteAction_UpgradeConfig_ConnectConfig {
    fn clear(&mut self) {
        self.proxy_protocol_config.clear();
        self.allow_post = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_UpgradeConfig_ConnectConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_UpgradeConfig_ConnectConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RouteAction_MaxStreamDuration {
    // message fields
    pub max_stream_duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub grpc_timeout_header_max: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub grpc_timeout_header_offset: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_MaxStreamDuration {
    fn default() -> &'a RouteAction_MaxStreamDuration {
        <RouteAction_MaxStreamDuration as ::protobuf::Message>::default_instance()
    }
}

impl RouteAction_MaxStreamDuration {
    pub fn new() -> RouteAction_MaxStreamDuration {
        ::std::default::Default::default()
    }

    // .google.protobuf.Duration max_stream_duration = 1;


    pub fn get_max_stream_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.max_stream_duration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_max_stream_duration(&mut self) {
        self.max_stream_duration.clear();
    }

    pub fn has_max_stream_duration(&self) -> bool {
        self.max_stream_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_stream_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.max_stream_duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_stream_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.max_stream_duration.is_none() {
            self.max_stream_duration.set_default();
        }
        self.max_stream_duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_stream_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.max_stream_duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration grpc_timeout_header_max = 2;


    pub fn get_grpc_timeout_header_max(&self) -> &::protobuf::well_known_types::Duration {
        self.grpc_timeout_header_max.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_grpc_timeout_header_max(&mut self) {
        self.grpc_timeout_header_max.clear();
    }

    pub fn has_grpc_timeout_header_max(&self) -> bool {
        self.grpc_timeout_header_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grpc_timeout_header_max(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.grpc_timeout_header_max = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_grpc_timeout_header_max(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.grpc_timeout_header_max.is_none() {
            self.grpc_timeout_header_max.set_default();
        }
        self.grpc_timeout_header_max.as_mut().unwrap()
    }

    // Take field
    pub fn take_grpc_timeout_header_max(&mut self) -> ::protobuf::well_known_types::Duration {
        self.grpc_timeout_header_max.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration grpc_timeout_header_offset = 3;


    pub fn get_grpc_timeout_header_offset(&self) -> &::protobuf::well_known_types::Duration {
        self.grpc_timeout_header_offset.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_grpc_timeout_header_offset(&mut self) {
        self.grpc_timeout_header_offset.clear();
    }

    pub fn has_grpc_timeout_header_offset(&self) -> bool {
        self.grpc_timeout_header_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grpc_timeout_header_offset(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.grpc_timeout_header_offset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_grpc_timeout_header_offset(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.grpc_timeout_header_offset.is_none() {
            self.grpc_timeout_header_offset.set_default();
        }
        self.grpc_timeout_header_offset.as_mut().unwrap()
    }

    // Take field
    pub fn take_grpc_timeout_header_offset(&mut self) -> ::protobuf::well_known_types::Duration {
        self.grpc_timeout_header_offset.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for RouteAction_MaxStreamDuration {
    fn is_initialized(&self) -> bool {
        for v in &self.max_stream_duration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.grpc_timeout_header_max {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.grpc_timeout_header_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_stream_duration)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.grpc_timeout_header_max)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.grpc_timeout_header_offset)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.max_stream_duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.grpc_timeout_header_max.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.grpc_timeout_header_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.max_stream_duration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.grpc_timeout_header_max.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.grpc_timeout_header_offset.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_MaxStreamDuration {
        RouteAction_MaxStreamDuration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "max_stream_duration",
                |m: &RouteAction_MaxStreamDuration| { &m.max_stream_duration },
                |m: &mut RouteAction_MaxStreamDuration| { &mut m.max_stream_duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "grpc_timeout_header_max",
                |m: &RouteAction_MaxStreamDuration| { &m.grpc_timeout_header_max },
                |m: &mut RouteAction_MaxStreamDuration| { &mut m.grpc_timeout_header_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "grpc_timeout_header_offset",
                |m: &RouteAction_MaxStreamDuration| { &m.grpc_timeout_header_offset },
                |m: &mut RouteAction_MaxStreamDuration| { &mut m.grpc_timeout_header_offset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_MaxStreamDuration>(
                "RouteAction.MaxStreamDuration",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_MaxStreamDuration {
        static instance: ::protobuf::rt::LazyV2<RouteAction_MaxStreamDuration> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_MaxStreamDuration::new)
    }
}

impl ::protobuf::Clear for RouteAction_MaxStreamDuration {
    fn clear(&mut self) {
        self.max_stream_duration.clear();
        self.grpc_timeout_header_max.clear();
        self.grpc_timeout_header_offset.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_MaxStreamDuration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_MaxStreamDuration {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RouteAction_ClusterNotFoundResponseCode {
    SERVICE_UNAVAILABLE = 0,
    NOT_FOUND = 1,
}

impl ::protobuf::ProtobufEnum for RouteAction_ClusterNotFoundResponseCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RouteAction_ClusterNotFoundResponseCode> {
        match value {
            0 => ::std::option::Option::Some(RouteAction_ClusterNotFoundResponseCode::SERVICE_UNAVAILABLE),
            1 => ::std::option::Option::Some(RouteAction_ClusterNotFoundResponseCode::NOT_FOUND),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RouteAction_ClusterNotFoundResponseCode] = &[
            RouteAction_ClusterNotFoundResponseCode::SERVICE_UNAVAILABLE,
            RouteAction_ClusterNotFoundResponseCode::NOT_FOUND,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RouteAction_ClusterNotFoundResponseCode>("RouteAction.ClusterNotFoundResponseCode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RouteAction_ClusterNotFoundResponseCode {
}

impl ::std::default::Default for RouteAction_ClusterNotFoundResponseCode {
    fn default() -> Self {
        RouteAction_ClusterNotFoundResponseCode::SERVICE_UNAVAILABLE
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_ClusterNotFoundResponseCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RouteAction_InternalRedirectAction {
    PASS_THROUGH_INTERNAL_REDIRECT = 0,
    HANDLE_INTERNAL_REDIRECT = 1,
}

impl ::protobuf::ProtobufEnum for RouteAction_InternalRedirectAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RouteAction_InternalRedirectAction> {
        match value {
            0 => ::std::option::Option::Some(RouteAction_InternalRedirectAction::PASS_THROUGH_INTERNAL_REDIRECT),
            1 => ::std::option::Option::Some(RouteAction_InternalRedirectAction::HANDLE_INTERNAL_REDIRECT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RouteAction_InternalRedirectAction] = &[
            RouteAction_InternalRedirectAction::PASS_THROUGH_INTERNAL_REDIRECT,
            RouteAction_InternalRedirectAction::HANDLE_INTERNAL_REDIRECT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RouteAction_InternalRedirectAction>("RouteAction.InternalRedirectAction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RouteAction_InternalRedirectAction {
}

impl ::std::default::Default for RouteAction_InternalRedirectAction {
    fn default() -> Self {
        RouteAction_InternalRedirectAction::PASS_THROUGH_INTERNAL_REDIRECT
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_InternalRedirectAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RetryPolicy {
    // message fields
    pub retry_on: ::std::string::String,
    pub num_retries: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub per_try_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub per_try_idle_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub retry_priority: ::protobuf::SingularPtrField<RetryPolicy_RetryPriority>,
    pub retry_host_predicate: ::protobuf::RepeatedField<RetryPolicy_RetryHostPredicate>,
    pub retry_options_predicates: ::protobuf::RepeatedField<super::extension::TypedExtensionConfig>,
    pub host_selection_retry_max_attempts: i64,
    pub retriable_status_codes: ::std::vec::Vec<u32>,
    pub retry_back_off: ::protobuf::SingularPtrField<RetryPolicy_RetryBackOff>,
    pub rate_limited_retry_back_off: ::protobuf::SingularPtrField<RetryPolicy_RateLimitedRetryBackOff>,
    pub retriable_headers: ::protobuf::RepeatedField<HeaderMatcher>,
    pub retriable_request_headers: ::protobuf::RepeatedField<HeaderMatcher>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RetryPolicy {
    fn default() -> &'a RetryPolicy {
        <RetryPolicy as ::protobuf::Message>::default_instance()
    }
}

impl RetryPolicy {
    pub fn new() -> RetryPolicy {
        ::std::default::Default::default()
    }

    // string retry_on = 1;


    pub fn get_retry_on(&self) -> &str {
        &self.retry_on
    }
    pub fn clear_retry_on(&mut self) {
        self.retry_on.clear();
    }

    // Param is passed by value, moved
    pub fn set_retry_on(&mut self, v: ::std::string::String) {
        self.retry_on = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_on(&mut self) -> &mut ::std::string::String {
        &mut self.retry_on
    }

    // Take field
    pub fn take_retry_on(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.retry_on, ::std::string::String::new())
    }

    // .google.protobuf.UInt32Value num_retries = 2;


    pub fn get_num_retries(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.num_retries.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_num_retries(&mut self) {
        self.num_retries.clear();
    }

    pub fn has_num_retries(&self) -> bool {
        self.num_retries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_retries(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.num_retries = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_num_retries(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.num_retries.is_none() {
            self.num_retries.set_default();
        }
        self.num_retries.as_mut().unwrap()
    }

    // Take field
    pub fn take_num_retries(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.num_retries.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // .google.protobuf.Duration per_try_timeout = 3;


    pub fn get_per_try_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.per_try_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_per_try_timeout(&mut self) {
        self.per_try_timeout.clear();
    }

    pub fn has_per_try_timeout(&self) -> bool {
        self.per_try_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_per_try_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.per_try_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_per_try_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.per_try_timeout.is_none() {
            self.per_try_timeout.set_default();
        }
        self.per_try_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_per_try_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.per_try_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration per_try_idle_timeout = 13;


    pub fn get_per_try_idle_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.per_try_idle_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_per_try_idle_timeout(&mut self) {
        self.per_try_idle_timeout.clear();
    }

    pub fn has_per_try_idle_timeout(&self) -> bool {
        self.per_try_idle_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_per_try_idle_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.per_try_idle_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_per_try_idle_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.per_try_idle_timeout.is_none() {
            self.per_try_idle_timeout.set_default();
        }
        self.per_try_idle_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_per_try_idle_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.per_try_idle_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .envoy.config.route.v3.RetryPolicy.RetryPriority retry_priority = 4;


    pub fn get_retry_priority(&self) -> &RetryPolicy_RetryPriority {
        self.retry_priority.as_ref().unwrap_or_else(|| <RetryPolicy_RetryPriority as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_priority(&mut self) {
        self.retry_priority.clear();
    }

    pub fn has_retry_priority(&self) -> bool {
        self.retry_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_priority(&mut self, v: RetryPolicy_RetryPriority) {
        self.retry_priority = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_priority(&mut self) -> &mut RetryPolicy_RetryPriority {
        if self.retry_priority.is_none() {
            self.retry_priority.set_default();
        }
        self.retry_priority.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_priority(&mut self) -> RetryPolicy_RetryPriority {
        self.retry_priority.take().unwrap_or_else(|| RetryPolicy_RetryPriority::new())
    }

    // repeated .envoy.config.route.v3.RetryPolicy.RetryHostPredicate retry_host_predicate = 5;


    pub fn get_retry_host_predicate(&self) -> &[RetryPolicy_RetryHostPredicate] {
        &self.retry_host_predicate
    }
    pub fn clear_retry_host_predicate(&mut self) {
        self.retry_host_predicate.clear();
    }

    // Param is passed by value, moved
    pub fn set_retry_host_predicate(&mut self, v: ::protobuf::RepeatedField<RetryPolicy_RetryHostPredicate>) {
        self.retry_host_predicate = v;
    }

    // Mutable pointer to the field.
    pub fn mut_retry_host_predicate(&mut self) -> &mut ::protobuf::RepeatedField<RetryPolicy_RetryHostPredicate> {
        &mut self.retry_host_predicate
    }

    // Take field
    pub fn take_retry_host_predicate(&mut self) -> ::protobuf::RepeatedField<RetryPolicy_RetryHostPredicate> {
        ::std::mem::replace(&mut self.retry_host_predicate, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.config.core.v3.TypedExtensionConfig retry_options_predicates = 12;


    pub fn get_retry_options_predicates(&self) -> &[super::extension::TypedExtensionConfig] {
        &self.retry_options_predicates
    }
    pub fn clear_retry_options_predicates(&mut self) {
        self.retry_options_predicates.clear();
    }

    // Param is passed by value, moved
    pub fn set_retry_options_predicates(&mut self, v: ::protobuf::RepeatedField<super::extension::TypedExtensionConfig>) {
        self.retry_options_predicates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_retry_options_predicates(&mut self) -> &mut ::protobuf::RepeatedField<super::extension::TypedExtensionConfig> {
        &mut self.retry_options_predicates
    }

    // Take field
    pub fn take_retry_options_predicates(&mut self) -> ::protobuf::RepeatedField<super::extension::TypedExtensionConfig> {
        ::std::mem::replace(&mut self.retry_options_predicates, ::protobuf::RepeatedField::new())
    }

    // int64 host_selection_retry_max_attempts = 6;


    pub fn get_host_selection_retry_max_attempts(&self) -> i64 {
        self.host_selection_retry_max_attempts
    }
    pub fn clear_host_selection_retry_max_attempts(&mut self) {
        self.host_selection_retry_max_attempts = 0;
    }

    // Param is passed by value, moved
    pub fn set_host_selection_retry_max_attempts(&mut self, v: i64) {
        self.host_selection_retry_max_attempts = v;
    }

    // repeated uint32 retriable_status_codes = 7;


    pub fn get_retriable_status_codes(&self) -> &[u32] {
        &self.retriable_status_codes
    }
    pub fn clear_retriable_status_codes(&mut self) {
        self.retriable_status_codes.clear();
    }

    // Param is passed by value, moved
    pub fn set_retriable_status_codes(&mut self, v: ::std::vec::Vec<u32>) {
        self.retriable_status_codes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_retriable_status_codes(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.retriable_status_codes
    }

    // Take field
    pub fn take_retriable_status_codes(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.retriable_status_codes, ::std::vec::Vec::new())
    }

    // .envoy.config.route.v3.RetryPolicy.RetryBackOff retry_back_off = 8;


    pub fn get_retry_back_off(&self) -> &RetryPolicy_RetryBackOff {
        self.retry_back_off.as_ref().unwrap_or_else(|| <RetryPolicy_RetryBackOff as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_back_off(&mut self) {
        self.retry_back_off.clear();
    }

    pub fn has_retry_back_off(&self) -> bool {
        self.retry_back_off.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_back_off(&mut self, v: RetryPolicy_RetryBackOff) {
        self.retry_back_off = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_back_off(&mut self) -> &mut RetryPolicy_RetryBackOff {
        if self.retry_back_off.is_none() {
            self.retry_back_off.set_default();
        }
        self.retry_back_off.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_back_off(&mut self) -> RetryPolicy_RetryBackOff {
        self.retry_back_off.take().unwrap_or_else(|| RetryPolicy_RetryBackOff::new())
    }

    // .envoy.config.route.v3.RetryPolicy.RateLimitedRetryBackOff rate_limited_retry_back_off = 11;


    pub fn get_rate_limited_retry_back_off(&self) -> &RetryPolicy_RateLimitedRetryBackOff {
        self.rate_limited_retry_back_off.as_ref().unwrap_or_else(|| <RetryPolicy_RateLimitedRetryBackOff as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rate_limited_retry_back_off(&mut self) {
        self.rate_limited_retry_back_off.clear();
    }

    pub fn has_rate_limited_retry_back_off(&self) -> bool {
        self.rate_limited_retry_back_off.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rate_limited_retry_back_off(&mut self, v: RetryPolicy_RateLimitedRetryBackOff) {
        self.rate_limited_retry_back_off = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rate_limited_retry_back_off(&mut self) -> &mut RetryPolicy_RateLimitedRetryBackOff {
        if self.rate_limited_retry_back_off.is_none() {
            self.rate_limited_retry_back_off.set_default();
        }
        self.rate_limited_retry_back_off.as_mut().unwrap()
    }

    // Take field
    pub fn take_rate_limited_retry_back_off(&mut self) -> RetryPolicy_RateLimitedRetryBackOff {
        self.rate_limited_retry_back_off.take().unwrap_or_else(|| RetryPolicy_RateLimitedRetryBackOff::new())
    }

    // repeated .envoy.config.route.v3.HeaderMatcher retriable_headers = 9;


    pub fn get_retriable_headers(&self) -> &[HeaderMatcher] {
        &self.retriable_headers
    }
    pub fn clear_retriable_headers(&mut self) {
        self.retriable_headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_retriable_headers(&mut self, v: ::protobuf::RepeatedField<HeaderMatcher>) {
        self.retriable_headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_retriable_headers(&mut self) -> &mut ::protobuf::RepeatedField<HeaderMatcher> {
        &mut self.retriable_headers
    }

    // Take field
    pub fn take_retriable_headers(&mut self) -> ::protobuf::RepeatedField<HeaderMatcher> {
        ::std::mem::replace(&mut self.retriable_headers, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.config.route.v3.HeaderMatcher retriable_request_headers = 10;


    pub fn get_retriable_request_headers(&self) -> &[HeaderMatcher] {
        &self.retriable_request_headers
    }
    pub fn clear_retriable_request_headers(&mut self) {
        self.retriable_request_headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_retriable_request_headers(&mut self, v: ::protobuf::RepeatedField<HeaderMatcher>) {
        self.retriable_request_headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_retriable_request_headers(&mut self) -> &mut ::protobuf::RepeatedField<HeaderMatcher> {
        &mut self.retriable_request_headers
    }

    // Take field
    pub fn take_retriable_request_headers(&mut self) -> ::protobuf::RepeatedField<HeaderMatcher> {
        ::std::mem::replace(&mut self.retriable_request_headers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RetryPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.num_retries {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.per_try_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.per_try_idle_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_priority {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_host_predicate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_options_predicates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_back_off {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rate_limited_retry_back_off {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retriable_headers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retriable_request_headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.retry_on)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.num_retries)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.per_try_timeout)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.per_try_idle_timeout)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_priority)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.retry_host_predicate)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.retry_options_predicates)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.host_selection_retry_max_attempts = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.retriable_status_codes)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_back_off)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rate_limited_retry_back_off)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.retriable_headers)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.retriable_request_headers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.retry_on.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.retry_on);
        }
        if let Some(ref v) = self.num_retries.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.per_try_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.per_try_idle_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.retry_priority.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.retry_host_predicate {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.retry_options_predicates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.host_selection_retry_max_attempts != 0 {
            my_size += ::protobuf::rt::value_size(6, self.host_selection_retry_max_attempts, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.retriable_status_codes {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.retry_back_off.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rate_limited_retry_back_off.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.retriable_headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.retriable_request_headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.retry_on.is_empty() {
            os.write_string(1, &self.retry_on)?;
        }
        if let Some(ref v) = self.num_retries.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.per_try_timeout.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.per_try_idle_timeout.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.retry_priority.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.retry_host_predicate {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.retry_options_predicates {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.host_selection_retry_max_attempts != 0 {
            os.write_int64(6, self.host_selection_retry_max_attempts)?;
        }
        for v in &self.retriable_status_codes {
            os.write_uint32(7, *v)?;
        };
        if let Some(ref v) = self.retry_back_off.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rate_limited_retry_back_off.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.retriable_headers {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.retriable_request_headers {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RetryPolicy {
        RetryPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "retry_on",
                |m: &RetryPolicy| { &m.retry_on },
                |m: &mut RetryPolicy| { &mut m.retry_on },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "num_retries",
                |m: &RetryPolicy| { &m.num_retries },
                |m: &mut RetryPolicy| { &mut m.num_retries },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "per_try_timeout",
                |m: &RetryPolicy| { &m.per_try_timeout },
                |m: &mut RetryPolicy| { &mut m.per_try_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "per_try_idle_timeout",
                |m: &RetryPolicy| { &m.per_try_idle_timeout },
                |m: &mut RetryPolicy| { &mut m.per_try_idle_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RetryPolicy_RetryPriority>>(
                "retry_priority",
                |m: &RetryPolicy| { &m.retry_priority },
                |m: &mut RetryPolicy| { &mut m.retry_priority },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RetryPolicy_RetryHostPredicate>>(
                "retry_host_predicate",
                |m: &RetryPolicy| { &m.retry_host_predicate },
                |m: &mut RetryPolicy| { &mut m.retry_host_predicate },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::extension::TypedExtensionConfig>>(
                "retry_options_predicates",
                |m: &RetryPolicy| { &m.retry_options_predicates },
                |m: &mut RetryPolicy| { &mut m.retry_options_predicates },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "host_selection_retry_max_attempts",
                |m: &RetryPolicy| { &m.host_selection_retry_max_attempts },
                |m: &mut RetryPolicy| { &mut m.host_selection_retry_max_attempts },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "retriable_status_codes",
                |m: &RetryPolicy| { &m.retriable_status_codes },
                |m: &mut RetryPolicy| { &mut m.retriable_status_codes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RetryPolicy_RetryBackOff>>(
                "retry_back_off",
                |m: &RetryPolicy| { &m.retry_back_off },
                |m: &mut RetryPolicy| { &mut m.retry_back_off },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RetryPolicy_RateLimitedRetryBackOff>>(
                "rate_limited_retry_back_off",
                |m: &RetryPolicy| { &m.rate_limited_retry_back_off },
                |m: &mut RetryPolicy| { &mut m.rate_limited_retry_back_off },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeaderMatcher>>(
                "retriable_headers",
                |m: &RetryPolicy| { &m.retriable_headers },
                |m: &mut RetryPolicy| { &mut m.retriable_headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeaderMatcher>>(
                "retriable_request_headers",
                |m: &RetryPolicy| { &m.retriable_request_headers },
                |m: &mut RetryPolicy| { &mut m.retriable_request_headers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RetryPolicy>(
                "RetryPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RetryPolicy {
        static instance: ::protobuf::rt::LazyV2<RetryPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RetryPolicy::new)
    }
}

impl ::protobuf::Clear for RetryPolicy {
    fn clear(&mut self) {
        self.retry_on.clear();
        self.num_retries.clear();
        self.per_try_timeout.clear();
        self.per_try_idle_timeout.clear();
        self.retry_priority.clear();
        self.retry_host_predicate.clear();
        self.retry_options_predicates.clear();
        self.host_selection_retry_max_attempts = 0;
        self.retriable_status_codes.clear();
        self.retry_back_off.clear();
        self.rate_limited_retry_back_off.clear();
        self.retriable_headers.clear();
        self.retriable_request_headers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RetryPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RetryPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RetryPolicy_RetryPriority {
    // message fields
    pub name: ::std::string::String,
    // message oneof groups
    pub config_type: ::std::option::Option<RetryPolicy_RetryPriority_oneof_config_type>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RetryPolicy_RetryPriority {
    fn default() -> &'a RetryPolicy_RetryPriority {
        <RetryPolicy_RetryPriority as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RetryPolicy_RetryPriority_oneof_config_type {
    typed_config(::protobuf::well_known_types::Any),
}

impl RetryPolicy_RetryPriority {
    pub fn new() -> RetryPolicy_RetryPriority {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Any typed_config = 3;


    pub fn get_typed_config(&self) -> &::protobuf::well_known_types::Any {
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(ref v)) => v,
            _ => <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_typed_config(&mut self) {
        self.config_type = ::std::option::Option::None;
    }

    pub fn has_typed_config(&self) -> bool {
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_typed_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.config_type = ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_typed_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if let ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(_)) = self.config_type {
        } else {
            self.config_type = ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(::protobuf::well_known_types::Any::new()));
        }
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_typed_config(&mut self) -> ::protobuf::well_known_types::Any {
        if self.has_typed_config() {
            match self.config_type.take() {
                ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Any::new()
        }
    }
}

impl ::protobuf::Message for RetryPolicy_RetryPriority {
    fn is_initialized(&self) -> bool {
        if let Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(ref v)) = self.config_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.config_type = ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.config_type {
            match v {
                &RetryPolicy_RetryPriority_oneof_config_type::typed_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.config_type {
            match v {
                &RetryPolicy_RetryPriority_oneof_config_type::typed_config(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RetryPolicy_RetryPriority {
        RetryPolicy_RetryPriority::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RetryPolicy_RetryPriority| { &m.name },
                |m: &mut RetryPolicy_RetryPriority| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Any>(
                "typed_config",
                RetryPolicy_RetryPriority::has_typed_config,
                RetryPolicy_RetryPriority::get_typed_config,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RetryPolicy_RetryPriority>(
                "RetryPolicy.RetryPriority",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RetryPolicy_RetryPriority {
        static instance: ::protobuf::rt::LazyV2<RetryPolicy_RetryPriority> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RetryPolicy_RetryPriority::new)
    }
}

impl ::protobuf::Clear for RetryPolicy_RetryPriority {
    fn clear(&mut self) {
        self.name.clear();
        self.config_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RetryPolicy_RetryPriority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RetryPolicy_RetryPriority {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RetryPolicy_RetryHostPredicate {
    // message fields
    pub name: ::std::string::String,
    // message oneof groups
    pub config_type: ::std::option::Option<RetryPolicy_RetryHostPredicate_oneof_config_type>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RetryPolicy_RetryHostPredicate {
    fn default() -> &'a RetryPolicy_RetryHostPredicate {
        <RetryPolicy_RetryHostPredicate as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RetryPolicy_RetryHostPredicate_oneof_config_type {
    typed_config(::protobuf::well_known_types::Any),
}

impl RetryPolicy_RetryHostPredicate {
    pub fn new() -> RetryPolicy_RetryHostPredicate {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Any typed_config = 3;


    pub fn get_typed_config(&self) -> &::protobuf::well_known_types::Any {
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(ref v)) => v,
            _ => <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_typed_config(&mut self) {
        self.config_type = ::std::option::Option::None;
    }

    pub fn has_typed_config(&self) -> bool {
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_typed_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.config_type = ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_typed_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if let ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(_)) = self.config_type {
        } else {
            self.config_type = ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(::protobuf::well_known_types::Any::new()));
        }
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_typed_config(&mut self) -> ::protobuf::well_known_types::Any {
        if self.has_typed_config() {
            match self.config_type.take() {
                ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Any::new()
        }
    }
}

impl ::protobuf::Message for RetryPolicy_RetryHostPredicate {
    fn is_initialized(&self) -> bool {
        if let Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(ref v)) = self.config_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.config_type = ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.config_type {
            match v {
                &RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.config_type {
            match v {
                &RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RetryPolicy_RetryHostPredicate {
        RetryPolicy_RetryHostPredicate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RetryPolicy_RetryHostPredicate| { &m.name },
                |m: &mut RetryPolicy_RetryHostPredicate| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Any>(
                "typed_config",
                RetryPolicy_RetryHostPredicate::has_typed_config,
                RetryPolicy_RetryHostPredicate::get_typed_config,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RetryPolicy_RetryHostPredicate>(
                "RetryPolicy.RetryHostPredicate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RetryPolicy_RetryHostPredicate {
        static instance: ::protobuf::rt::LazyV2<RetryPolicy_RetryHostPredicate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RetryPolicy_RetryHostPredicate::new)
    }
}

impl ::protobuf::Clear for RetryPolicy_RetryHostPredicate {
    fn clear(&mut self) {
        self.name.clear();
        self.config_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RetryPolicy_RetryHostPredicate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RetryPolicy_RetryHostPredicate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RetryPolicy_RetryBackOff {
    // message fields
    pub base_interval: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub max_interval: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RetryPolicy_RetryBackOff {
    fn default() -> &'a RetryPolicy_RetryBackOff {
        <RetryPolicy_RetryBackOff as ::protobuf::Message>::default_instance()
    }
}

impl RetryPolicy_RetryBackOff {
    pub fn new() -> RetryPolicy_RetryBackOff {
        ::std::default::Default::default()
    }

    // .google.protobuf.Duration base_interval = 1;


    pub fn get_base_interval(&self) -> &::protobuf::well_known_types::Duration {
        self.base_interval.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_base_interval(&mut self) {
        self.base_interval.clear();
    }

    pub fn has_base_interval(&self) -> bool {
        self.base_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_interval(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.base_interval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_interval(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.base_interval.is_none() {
            self.base_interval.set_default();
        }
        self.base_interval.as_mut().unwrap()
    }

    // Take field
    pub fn take_base_interval(&mut self) -> ::protobuf::well_known_types::Duration {
        self.base_interval.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration max_interval = 2;


    pub fn get_max_interval(&self) -> &::protobuf::well_known_types::Duration {
        self.max_interval.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_max_interval(&mut self) {
        self.max_interval.clear();
    }

    pub fn has_max_interval(&self) -> bool {
        self.max_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_interval(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.max_interval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_interval(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.max_interval.is_none() {
            self.max_interval.set_default();
        }
        self.max_interval.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_interval(&mut self) -> ::protobuf::well_known_types::Duration {
        self.max_interval.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for RetryPolicy_RetryBackOff {
    fn is_initialized(&self) -> bool {
        for v in &self.base_interval {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_interval {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base_interval)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_interval)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base_interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.max_interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base_interval.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.max_interval.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RetryPolicy_RetryBackOff {
        RetryPolicy_RetryBackOff::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "base_interval",
                |m: &RetryPolicy_RetryBackOff| { &m.base_interval },
                |m: &mut RetryPolicy_RetryBackOff| { &mut m.base_interval },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "max_interval",
                |m: &RetryPolicy_RetryBackOff| { &m.max_interval },
                |m: &mut RetryPolicy_RetryBackOff| { &mut m.max_interval },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RetryPolicy_RetryBackOff>(
                "RetryPolicy.RetryBackOff",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RetryPolicy_RetryBackOff {
        static instance: ::protobuf::rt::LazyV2<RetryPolicy_RetryBackOff> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RetryPolicy_RetryBackOff::new)
    }
}

impl ::protobuf::Clear for RetryPolicy_RetryBackOff {
    fn clear(&mut self) {
        self.base_interval.clear();
        self.max_interval.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RetryPolicy_RetryBackOff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RetryPolicy_RetryBackOff {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RetryPolicy_ResetHeader {
    // message fields
    pub name: ::std::string::String,
    pub format: RetryPolicy_ResetHeaderFormat,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RetryPolicy_ResetHeader {
    fn default() -> &'a RetryPolicy_ResetHeader {
        <RetryPolicy_ResetHeader as ::protobuf::Message>::default_instance()
    }
}

impl RetryPolicy_ResetHeader {
    pub fn new() -> RetryPolicy_ResetHeader {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .envoy.config.route.v3.RetryPolicy.ResetHeaderFormat format = 2;


    pub fn get_format(&self) -> RetryPolicy_ResetHeaderFormat {
        self.format
    }
    pub fn clear_format(&mut self) {
        self.format = RetryPolicy_ResetHeaderFormat::SECONDS;
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: RetryPolicy_ResetHeaderFormat) {
        self.format = v;
    }
}

impl ::protobuf::Message for RetryPolicy_ResetHeader {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.format, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.format != RetryPolicy_ResetHeaderFormat::SECONDS {
            my_size += ::protobuf::rt::enum_size(2, self.format);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.format != RetryPolicy_ResetHeaderFormat::SECONDS {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.format))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RetryPolicy_ResetHeader {
        RetryPolicy_ResetHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RetryPolicy_ResetHeader| { &m.name },
                |m: &mut RetryPolicy_ResetHeader| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RetryPolicy_ResetHeaderFormat>>(
                "format",
                |m: &RetryPolicy_ResetHeader| { &m.format },
                |m: &mut RetryPolicy_ResetHeader| { &mut m.format },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RetryPolicy_ResetHeader>(
                "RetryPolicy.ResetHeader",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RetryPolicy_ResetHeader {
        static instance: ::protobuf::rt::LazyV2<RetryPolicy_ResetHeader> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RetryPolicy_ResetHeader::new)
    }
}

impl ::protobuf::Clear for RetryPolicy_ResetHeader {
    fn clear(&mut self) {
        self.name.clear();
        self.format = RetryPolicy_ResetHeaderFormat::SECONDS;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RetryPolicy_ResetHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RetryPolicy_ResetHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RetryPolicy_RateLimitedRetryBackOff {
    // message fields
    pub reset_headers: ::protobuf::RepeatedField<RetryPolicy_ResetHeader>,
    pub max_interval: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RetryPolicy_RateLimitedRetryBackOff {
    fn default() -> &'a RetryPolicy_RateLimitedRetryBackOff {
        <RetryPolicy_RateLimitedRetryBackOff as ::protobuf::Message>::default_instance()
    }
}

impl RetryPolicy_RateLimitedRetryBackOff {
    pub fn new() -> RetryPolicy_RateLimitedRetryBackOff {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.route.v3.RetryPolicy.ResetHeader reset_headers = 1;


    pub fn get_reset_headers(&self) -> &[RetryPolicy_ResetHeader] {
        &self.reset_headers
    }
    pub fn clear_reset_headers(&mut self) {
        self.reset_headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_reset_headers(&mut self, v: ::protobuf::RepeatedField<RetryPolicy_ResetHeader>) {
        self.reset_headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reset_headers(&mut self) -> &mut ::protobuf::RepeatedField<RetryPolicy_ResetHeader> {
        &mut self.reset_headers
    }

    // Take field
    pub fn take_reset_headers(&mut self) -> ::protobuf::RepeatedField<RetryPolicy_ResetHeader> {
        ::std::mem::replace(&mut self.reset_headers, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Duration max_interval = 2;


    pub fn get_max_interval(&self) -> &::protobuf::well_known_types::Duration {
        self.max_interval.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_max_interval(&mut self) {
        self.max_interval.clear();
    }

    pub fn has_max_interval(&self) -> bool {
        self.max_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_interval(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.max_interval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_interval(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.max_interval.is_none() {
            self.max_interval.set_default();
        }
        self.max_interval.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_interval(&mut self) -> ::protobuf::well_known_types::Duration {
        self.max_interval.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for RetryPolicy_RateLimitedRetryBackOff {
    fn is_initialized(&self) -> bool {
        for v in &self.reset_headers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_interval {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.reset_headers)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_interval)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.reset_headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.max_interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.reset_headers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.max_interval.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RetryPolicy_RateLimitedRetryBackOff {
        RetryPolicy_RateLimitedRetryBackOff::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RetryPolicy_ResetHeader>>(
                "reset_headers",
                |m: &RetryPolicy_RateLimitedRetryBackOff| { &m.reset_headers },
                |m: &mut RetryPolicy_RateLimitedRetryBackOff| { &mut m.reset_headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "max_interval",
                |m: &RetryPolicy_RateLimitedRetryBackOff| { &m.max_interval },
                |m: &mut RetryPolicy_RateLimitedRetryBackOff| { &mut m.max_interval },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RetryPolicy_RateLimitedRetryBackOff>(
                "RetryPolicy.RateLimitedRetryBackOff",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RetryPolicy_RateLimitedRetryBackOff {
        static instance: ::protobuf::rt::LazyV2<RetryPolicy_RateLimitedRetryBackOff> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RetryPolicy_RateLimitedRetryBackOff::new)
    }
}

impl ::protobuf::Clear for RetryPolicy_RateLimitedRetryBackOff {
    fn clear(&mut self) {
        self.reset_headers.clear();
        self.max_interval.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RetryPolicy_RateLimitedRetryBackOff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RetryPolicy_RateLimitedRetryBackOff {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RetryPolicy_ResetHeaderFormat {
    SECONDS = 0,
    UNIX_TIMESTAMP = 1,
}

impl ::protobuf::ProtobufEnum for RetryPolicy_ResetHeaderFormat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RetryPolicy_ResetHeaderFormat> {
        match value {
            0 => ::std::option::Option::Some(RetryPolicy_ResetHeaderFormat::SECONDS),
            1 => ::std::option::Option::Some(RetryPolicy_ResetHeaderFormat::UNIX_TIMESTAMP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RetryPolicy_ResetHeaderFormat] = &[
            RetryPolicy_ResetHeaderFormat::SECONDS,
            RetryPolicy_ResetHeaderFormat::UNIX_TIMESTAMP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RetryPolicy_ResetHeaderFormat>("RetryPolicy.ResetHeaderFormat", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RetryPolicy_ResetHeaderFormat {
}

impl ::std::default::Default for RetryPolicy_ResetHeaderFormat {
    fn default() -> Self {
        RetryPolicy_ResetHeaderFormat::SECONDS
    }
}

impl ::protobuf::reflect::ProtobufValue for RetryPolicy_ResetHeaderFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct HedgePolicy {
    // message fields
    pub initial_requests: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub additional_request_chance: ::protobuf::SingularPtrField<super::percent::FractionalPercent>,
    pub hedge_on_per_try_timeout: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HedgePolicy {
    fn default() -> &'a HedgePolicy {
        <HedgePolicy as ::protobuf::Message>::default_instance()
    }
}

impl HedgePolicy {
    pub fn new() -> HedgePolicy {
        ::std::default::Default::default()
    }

    // .google.protobuf.UInt32Value initial_requests = 1;


    pub fn get_initial_requests(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.initial_requests.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_initial_requests(&mut self) {
        self.initial_requests.clear();
    }

    pub fn has_initial_requests(&self) -> bool {
        self.initial_requests.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_requests(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.initial_requests = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initial_requests(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.initial_requests.is_none() {
            self.initial_requests.set_default();
        }
        self.initial_requests.as_mut().unwrap()
    }

    // Take field
    pub fn take_initial_requests(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.initial_requests.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // .envoy.type.v3.FractionalPercent additional_request_chance = 2;


    pub fn get_additional_request_chance(&self) -> &super::percent::FractionalPercent {
        self.additional_request_chance.as_ref().unwrap_or_else(|| <super::percent::FractionalPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_additional_request_chance(&mut self) {
        self.additional_request_chance.clear();
    }

    pub fn has_additional_request_chance(&self) -> bool {
        self.additional_request_chance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_request_chance(&mut self, v: super::percent::FractionalPercent) {
        self.additional_request_chance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_additional_request_chance(&mut self) -> &mut super::percent::FractionalPercent {
        if self.additional_request_chance.is_none() {
            self.additional_request_chance.set_default();
        }
        self.additional_request_chance.as_mut().unwrap()
    }

    // Take field
    pub fn take_additional_request_chance(&mut self) -> super::percent::FractionalPercent {
        self.additional_request_chance.take().unwrap_or_else(|| super::percent::FractionalPercent::new())
    }

    // bool hedge_on_per_try_timeout = 3;


    pub fn get_hedge_on_per_try_timeout(&self) -> bool {
        self.hedge_on_per_try_timeout
    }
    pub fn clear_hedge_on_per_try_timeout(&mut self) {
        self.hedge_on_per_try_timeout = false;
    }

    // Param is passed by value, moved
    pub fn set_hedge_on_per_try_timeout(&mut self, v: bool) {
        self.hedge_on_per_try_timeout = v;
    }
}

impl ::protobuf::Message for HedgePolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.initial_requests {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.additional_request_chance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.initial_requests)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.additional_request_chance)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hedge_on_per_try_timeout = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.initial_requests.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.additional_request_chance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.hedge_on_per_try_timeout != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.initial_requests.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.additional_request_chance.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.hedge_on_per_try_timeout != false {
            os.write_bool(3, self.hedge_on_per_try_timeout)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HedgePolicy {
        HedgePolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "initial_requests",
                |m: &HedgePolicy| { &m.initial_requests },
                |m: &mut HedgePolicy| { &mut m.initial_requests },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::percent::FractionalPercent>>(
                "additional_request_chance",
                |m: &HedgePolicy| { &m.additional_request_chance },
                |m: &mut HedgePolicy| { &mut m.additional_request_chance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hedge_on_per_try_timeout",
                |m: &HedgePolicy| { &m.hedge_on_per_try_timeout },
                |m: &mut HedgePolicy| { &mut m.hedge_on_per_try_timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HedgePolicy>(
                "HedgePolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HedgePolicy {
        static instance: ::protobuf::rt::LazyV2<HedgePolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HedgePolicy::new)
    }
}

impl ::protobuf::Clear for HedgePolicy {
    fn clear(&mut self) {
        self.initial_requests.clear();
        self.additional_request_chance.clear();
        self.hedge_on_per_try_timeout = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HedgePolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HedgePolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RedirectAction {
    // message fields
    pub host_redirect: ::std::string::String,
    pub port_redirect: u32,
    pub response_code: RedirectAction_RedirectResponseCode,
    pub strip_query: bool,
    // message oneof groups
    pub scheme_rewrite_specifier: ::std::option::Option<RedirectAction_oneof_scheme_rewrite_specifier>,
    pub path_rewrite_specifier: ::std::option::Option<RedirectAction_oneof_path_rewrite_specifier>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedirectAction {
    fn default() -> &'a RedirectAction {
        <RedirectAction as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RedirectAction_oneof_scheme_rewrite_specifier {
    https_redirect(bool),
    scheme_redirect(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RedirectAction_oneof_path_rewrite_specifier {
    path_redirect(::std::string::String),
    prefix_rewrite(::std::string::String),
    regex_rewrite(super::regex::RegexMatchAndSubstitute),
}

impl RedirectAction {
    pub fn new() -> RedirectAction {
        ::std::default::Default::default()
    }

    // bool https_redirect = 4;


    pub fn get_https_redirect(&self) -> bool {
        match self.scheme_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::https_redirect(v)) => v,
            _ => false,
        }
    }
    pub fn clear_https_redirect(&mut self) {
        self.scheme_rewrite_specifier = ::std::option::Option::None;
    }

    pub fn has_https_redirect(&self) -> bool {
        match self.scheme_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::https_redirect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_https_redirect(&mut self, v: bool) {
        self.scheme_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::https_redirect(v))
    }

    // string scheme_redirect = 7;


    pub fn get_scheme_redirect(&self) -> &str {
        match self.scheme_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_scheme_redirect(&mut self) {
        self.scheme_rewrite_specifier = ::std::option::Option::None;
    }

    pub fn has_scheme_redirect(&self) -> bool {
        match self.scheme_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_scheme_redirect(&mut self, v: ::std::string::String) {
        self.scheme_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_scheme_redirect(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(_)) = self.scheme_rewrite_specifier {
        } else {
            self.scheme_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(::std::string::String::new()));
        }
        match self.scheme_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_scheme_redirect(&mut self) -> ::std::string::String {
        if self.has_scheme_redirect() {
            match self.scheme_rewrite_specifier.take() {
                ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string host_redirect = 1;


    pub fn get_host_redirect(&self) -> &str {
        &self.host_redirect
    }
    pub fn clear_host_redirect(&mut self) {
        self.host_redirect.clear();
    }

    // Param is passed by value, moved
    pub fn set_host_redirect(&mut self, v: ::std::string::String) {
        self.host_redirect = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_redirect(&mut self) -> &mut ::std::string::String {
        &mut self.host_redirect
    }

    // Take field
    pub fn take_host_redirect(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host_redirect, ::std::string::String::new())
    }

    // uint32 port_redirect = 8;


    pub fn get_port_redirect(&self) -> u32 {
        self.port_redirect
    }
    pub fn clear_port_redirect(&mut self) {
        self.port_redirect = 0;
    }

    // Param is passed by value, moved
    pub fn set_port_redirect(&mut self, v: u32) {
        self.port_redirect = v;
    }

    // string path_redirect = 2;


    pub fn get_path_redirect(&self) -> &str {
        match self.path_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::path_redirect(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_path_redirect(&mut self) {
        self.path_rewrite_specifier = ::std::option::Option::None;
    }

    pub fn has_path_redirect(&self) -> bool {
        match self.path_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::path_redirect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_path_redirect(&mut self, v: ::std::string::String) {
        self.path_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::path_redirect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_path_redirect(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::path_redirect(_)) = self.path_rewrite_specifier {
        } else {
            self.path_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::path_redirect(::std::string::String::new()));
        }
        match self.path_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::path_redirect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_path_redirect(&mut self) -> ::std::string::String {
        if self.has_path_redirect() {
            match self.path_rewrite_specifier.take() {
                ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::path_redirect(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string prefix_rewrite = 5;


    pub fn get_prefix_rewrite(&self) -> &str {
        match self.path_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_prefix_rewrite(&mut self) {
        self.path_rewrite_specifier = ::std::option::Option::None;
    }

    pub fn has_prefix_rewrite(&self) -> bool {
        match self.path_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_prefix_rewrite(&mut self, v: ::std::string::String) {
        self.path_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(v))
    }

    // Mutable pointer to the field.
    pub fn mut_prefix_rewrite(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(_)) = self.path_rewrite_specifier {
        } else {
            self.path_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(::std::string::String::new()));
        }
        match self.path_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_prefix_rewrite(&mut self) -> ::std::string::String {
        if self.has_prefix_rewrite() {
            match self.path_rewrite_specifier.take() {
                ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .envoy.type.matcher.v3.RegexMatchAndSubstitute regex_rewrite = 9;


    pub fn get_regex_rewrite(&self) -> &super::regex::RegexMatchAndSubstitute {
        match self.path_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::regex_rewrite(ref v)) => v,
            _ => <super::regex::RegexMatchAndSubstitute as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_regex_rewrite(&mut self) {
        self.path_rewrite_specifier = ::std::option::Option::None;
    }

    pub fn has_regex_rewrite(&self) -> bool {
        match self.path_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::regex_rewrite(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_regex_rewrite(&mut self, v: super::regex::RegexMatchAndSubstitute) {
        self.path_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::regex_rewrite(v))
    }

    // Mutable pointer to the field.
    pub fn mut_regex_rewrite(&mut self) -> &mut super::regex::RegexMatchAndSubstitute {
        if let ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::regex_rewrite(_)) = self.path_rewrite_specifier {
        } else {
            self.path_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::regex_rewrite(super::regex::RegexMatchAndSubstitute::new()));
        }
        match self.path_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::regex_rewrite(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_regex_rewrite(&mut self) -> super::regex::RegexMatchAndSubstitute {
        if self.has_regex_rewrite() {
            match self.path_rewrite_specifier.take() {
                ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::regex_rewrite(v)) => v,
                _ => panic!(),
            }
        } else {
            super::regex::RegexMatchAndSubstitute::new()
        }
    }

    // .envoy.config.route.v3.RedirectAction.RedirectResponseCode response_code = 3;


    pub fn get_response_code(&self) -> RedirectAction_RedirectResponseCode {
        self.response_code
    }
    pub fn clear_response_code(&mut self) {
        self.response_code = RedirectAction_RedirectResponseCode::MOVED_PERMANENTLY;
    }

    // Param is passed by value, moved
    pub fn set_response_code(&mut self, v: RedirectAction_RedirectResponseCode) {
        self.response_code = v;
    }

    // bool strip_query = 6;


    pub fn get_strip_query(&self) -> bool {
        self.strip_query
    }
    pub fn clear_strip_query(&mut self) {
        self.strip_query = false;
    }

    // Param is passed by value, moved
    pub fn set_strip_query(&mut self, v: bool) {
        self.strip_query = v;
    }
}

impl ::protobuf::Message for RedirectAction {
    fn is_initialized(&self) -> bool {
        if let Some(RedirectAction_oneof_path_rewrite_specifier::regex_rewrite(ref v)) = self.path_rewrite_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scheme_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::https_redirect(is.read_bool()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scheme_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(is.read_string()?));
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host_redirect)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port_redirect = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::path_redirect(is.read_string()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(is.read_string()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::regex_rewrite(is.read_message()?));
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.response_code, 3, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.strip_query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host_redirect.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host_redirect);
        }
        if self.port_redirect != 0 {
            my_size += ::protobuf::rt::value_size(8, self.port_redirect, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.response_code != RedirectAction_RedirectResponseCode::MOVED_PERMANENTLY {
            my_size += ::protobuf::rt::enum_size(3, self.response_code);
        }
        if self.strip_query != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.scheme_rewrite_specifier {
            match v {
                &RedirectAction_oneof_scheme_rewrite_specifier::https_redirect(v) => {
                    my_size += 2;
                },
                &RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(ref v) => {
                    my_size += ::protobuf::rt::string_size(7, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.path_rewrite_specifier {
            match v {
                &RedirectAction_oneof_path_rewrite_specifier::path_redirect(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
                &RedirectAction_oneof_path_rewrite_specifier::regex_rewrite(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.host_redirect.is_empty() {
            os.write_string(1, &self.host_redirect)?;
        }
        if self.port_redirect != 0 {
            os.write_uint32(8, self.port_redirect)?;
        }
        if self.response_code != RedirectAction_RedirectResponseCode::MOVED_PERMANENTLY {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.response_code))?;
        }
        if self.strip_query != false {
            os.write_bool(6, self.strip_query)?;
        }
        if let ::std::option::Option::Some(ref v) = self.scheme_rewrite_specifier {
            match v {
                &RedirectAction_oneof_scheme_rewrite_specifier::https_redirect(v) => {
                    os.write_bool(4, v)?;
                },
                &RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(ref v) => {
                    os.write_string(7, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.path_rewrite_specifier {
            match v {
                &RedirectAction_oneof_path_rewrite_specifier::path_redirect(ref v) => {
                    os.write_string(2, v)?;
                },
                &RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(ref v) => {
                    os.write_string(5, v)?;
                },
                &RedirectAction_oneof_path_rewrite_specifier::regex_rewrite(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedirectAction {
        RedirectAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "https_redirect",
                RedirectAction::has_https_redirect,
                RedirectAction::get_https_redirect,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "scheme_redirect",
                RedirectAction::has_scheme_redirect,
                RedirectAction::get_scheme_redirect,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host_redirect",
                |m: &RedirectAction| { &m.host_redirect },
                |m: &mut RedirectAction| { &mut m.host_redirect },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port_redirect",
                |m: &RedirectAction| { &m.port_redirect },
                |m: &mut RedirectAction| { &mut m.port_redirect },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "path_redirect",
                RedirectAction::has_path_redirect,
                RedirectAction::get_path_redirect,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "prefix_rewrite",
                RedirectAction::has_prefix_rewrite,
                RedirectAction::get_prefix_rewrite,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::regex::RegexMatchAndSubstitute>(
                "regex_rewrite",
                RedirectAction::has_regex_rewrite,
                RedirectAction::get_regex_rewrite,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RedirectAction_RedirectResponseCode>>(
                "response_code",
                |m: &RedirectAction| { &m.response_code },
                |m: &mut RedirectAction| { &mut m.response_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "strip_query",
                |m: &RedirectAction| { &m.strip_query },
                |m: &mut RedirectAction| { &mut m.strip_query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RedirectAction>(
                "RedirectAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedirectAction {
        static instance: ::protobuf::rt::LazyV2<RedirectAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RedirectAction::new)
    }
}

impl ::protobuf::Clear for RedirectAction {
    fn clear(&mut self) {
        self.scheme_rewrite_specifier = ::std::option::Option::None;
        self.scheme_rewrite_specifier = ::std::option::Option::None;
        self.host_redirect.clear();
        self.port_redirect = 0;
        self.path_rewrite_specifier = ::std::option::Option::None;
        self.path_rewrite_specifier = ::std::option::Option::None;
        self.path_rewrite_specifier = ::std::option::Option::None;
        self.response_code = RedirectAction_RedirectResponseCode::MOVED_PERMANENTLY;
        self.strip_query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedirectAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedirectAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RedirectAction_RedirectResponseCode {
    MOVED_PERMANENTLY = 0,
    FOUND = 1,
    SEE_OTHER = 2,
    TEMPORARY_REDIRECT = 3,
    PERMANENT_REDIRECT = 4,
}

impl ::protobuf::ProtobufEnum for RedirectAction_RedirectResponseCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RedirectAction_RedirectResponseCode> {
        match value {
            0 => ::std::option::Option::Some(RedirectAction_RedirectResponseCode::MOVED_PERMANENTLY),
            1 => ::std::option::Option::Some(RedirectAction_RedirectResponseCode::FOUND),
            2 => ::std::option::Option::Some(RedirectAction_RedirectResponseCode::SEE_OTHER),
            3 => ::std::option::Option::Some(RedirectAction_RedirectResponseCode::TEMPORARY_REDIRECT),
            4 => ::std::option::Option::Some(RedirectAction_RedirectResponseCode::PERMANENT_REDIRECT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RedirectAction_RedirectResponseCode] = &[
            RedirectAction_RedirectResponseCode::MOVED_PERMANENTLY,
            RedirectAction_RedirectResponseCode::FOUND,
            RedirectAction_RedirectResponseCode::SEE_OTHER,
            RedirectAction_RedirectResponseCode::TEMPORARY_REDIRECT,
            RedirectAction_RedirectResponseCode::PERMANENT_REDIRECT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RedirectAction_RedirectResponseCode>("RedirectAction.RedirectResponseCode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RedirectAction_RedirectResponseCode {
}

impl ::std::default::Default for RedirectAction_RedirectResponseCode {
    fn default() -> Self {
        RedirectAction_RedirectResponseCode::MOVED_PERMANENTLY
    }
}

impl ::protobuf::reflect::ProtobufValue for RedirectAction_RedirectResponseCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DirectResponseAction {
    // message fields
    pub status: u32,
    pub body: ::protobuf::SingularPtrField<super::base::DataSource>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectResponseAction {
    fn default() -> &'a DirectResponseAction {
        <DirectResponseAction as ::protobuf::Message>::default_instance()
    }
}

impl DirectResponseAction {
    pub fn new() -> DirectResponseAction {
        ::std::default::Default::default()
    }

    // uint32 status = 1;


    pub fn get_status(&self) -> u32 {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = 0;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u32) {
        self.status = v;
    }

    // .envoy.config.core.v3.DataSource body = 2;


    pub fn get_body(&self) -> &super::base::DataSource {
        self.body.as_ref().unwrap_or_else(|| <super::base::DataSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: super::base::DataSource) {
        self.body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut super::base::DataSource {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> super::base::DataSource {
        self.body.take().unwrap_or_else(|| super::base::DataSource::new())
    }
}

impl ::protobuf::Message for DirectResponseAction {
    fn is_initialized(&self) -> bool {
        for v in &self.body {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != 0 {
            my_size += ::protobuf::rt::value_size(1, self.status, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != 0 {
            os.write_uint32(1, self.status)?;
        }
        if let Some(ref v) = self.body.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectResponseAction {
        DirectResponseAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "status",
                |m: &DirectResponseAction| { &m.status },
                |m: &mut DirectResponseAction| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::DataSource>>(
                "body",
                |m: &DirectResponseAction| { &m.body },
                |m: &mut DirectResponseAction| { &mut m.body },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DirectResponseAction>(
                "DirectResponseAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DirectResponseAction {
        static instance: ::protobuf::rt::LazyV2<DirectResponseAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DirectResponseAction::new)
    }
}

impl ::protobuf::Clear for DirectResponseAction {
    fn clear(&mut self) {
        self.status = 0;
        self.body.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectResponseAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectResponseAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct NonForwardingAction {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NonForwardingAction {
    fn default() -> &'a NonForwardingAction {
        <NonForwardingAction as ::protobuf::Message>::default_instance()
    }
}

impl NonForwardingAction {
    pub fn new() -> NonForwardingAction {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for NonForwardingAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NonForwardingAction {
        NonForwardingAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NonForwardingAction>(
                "NonForwardingAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NonForwardingAction {
        static instance: ::protobuf::rt::LazyV2<NonForwardingAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NonForwardingAction::new)
    }
}

impl ::protobuf::Clear for NonForwardingAction {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NonForwardingAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NonForwardingAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Decorator {
    // message fields
    pub operation: ::std::string::String,
    pub propagate: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Decorator {
    fn default() -> &'a Decorator {
        <Decorator as ::protobuf::Message>::default_instance()
    }
}

impl Decorator {
    pub fn new() -> Decorator {
        ::std::default::Default::default()
    }

    // string operation = 1;


    pub fn get_operation(&self) -> &str {
        &self.operation
    }
    pub fn clear_operation(&mut self) {
        self.operation.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: ::std::string::String) {
        self.operation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation(&mut self) -> &mut ::std::string::String {
        &mut self.operation
    }

    // Take field
    pub fn take_operation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation, ::std::string::String::new())
    }

    // .google.protobuf.BoolValue propagate = 2;


    pub fn get_propagate(&self) -> &::protobuf::well_known_types::BoolValue {
        self.propagate.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_propagate(&mut self) {
        self.propagate.clear();
    }

    pub fn has_propagate(&self) -> bool {
        self.propagate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_propagate(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.propagate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_propagate(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.propagate.is_none() {
            self.propagate.set_default();
        }
        self.propagate.as_mut().unwrap()
    }

    // Take field
    pub fn take_propagate(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.propagate.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }
}

impl ::protobuf::Message for Decorator {
    fn is_initialized(&self) -> bool {
        for v in &self.propagate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.propagate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.operation.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.operation);
        }
        if let Some(ref v) = self.propagate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.operation.is_empty() {
            os.write_string(1, &self.operation)?;
        }
        if let Some(ref v) = self.propagate.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Decorator {
        Decorator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operation",
                |m: &Decorator| { &m.operation },
                |m: &mut Decorator| { &mut m.operation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "propagate",
                |m: &Decorator| { &m.propagate },
                |m: &mut Decorator| { &mut m.propagate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Decorator>(
                "Decorator",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Decorator {
        static instance: ::protobuf::rt::LazyV2<Decorator> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Decorator::new)
    }
}

impl ::protobuf::Clear for Decorator {
    fn clear(&mut self) {
        self.operation.clear();
        self.propagate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Decorator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Decorator {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Tracing {
    // message fields
    pub client_sampling: ::protobuf::SingularPtrField<super::percent::FractionalPercent>,
    pub random_sampling: ::protobuf::SingularPtrField<super::percent::FractionalPercent>,
    pub overall_sampling: ::protobuf::SingularPtrField<super::percent::FractionalPercent>,
    pub custom_tags: ::protobuf::RepeatedField<super::custom_tag::CustomTag>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Tracing {
    fn default() -> &'a Tracing {
        <Tracing as ::protobuf::Message>::default_instance()
    }
}

impl Tracing {
    pub fn new() -> Tracing {
        ::std::default::Default::default()
    }

    // .envoy.type.v3.FractionalPercent client_sampling = 1;


    pub fn get_client_sampling(&self) -> &super::percent::FractionalPercent {
        self.client_sampling.as_ref().unwrap_or_else(|| <super::percent::FractionalPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_client_sampling(&mut self) {
        self.client_sampling.clear();
    }

    pub fn has_client_sampling(&self) -> bool {
        self.client_sampling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_sampling(&mut self, v: super::percent::FractionalPercent) {
        self.client_sampling = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_sampling(&mut self) -> &mut super::percent::FractionalPercent {
        if self.client_sampling.is_none() {
            self.client_sampling.set_default();
        }
        self.client_sampling.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_sampling(&mut self) -> super::percent::FractionalPercent {
        self.client_sampling.take().unwrap_or_else(|| super::percent::FractionalPercent::new())
    }

    // .envoy.type.v3.FractionalPercent random_sampling = 2;


    pub fn get_random_sampling(&self) -> &super::percent::FractionalPercent {
        self.random_sampling.as_ref().unwrap_or_else(|| <super::percent::FractionalPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_random_sampling(&mut self) {
        self.random_sampling.clear();
    }

    pub fn has_random_sampling(&self) -> bool {
        self.random_sampling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_random_sampling(&mut self, v: super::percent::FractionalPercent) {
        self.random_sampling = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_random_sampling(&mut self) -> &mut super::percent::FractionalPercent {
        if self.random_sampling.is_none() {
            self.random_sampling.set_default();
        }
        self.random_sampling.as_mut().unwrap()
    }

    // Take field
    pub fn take_random_sampling(&mut self) -> super::percent::FractionalPercent {
        self.random_sampling.take().unwrap_or_else(|| super::percent::FractionalPercent::new())
    }

    // .envoy.type.v3.FractionalPercent overall_sampling = 3;


    pub fn get_overall_sampling(&self) -> &super::percent::FractionalPercent {
        self.overall_sampling.as_ref().unwrap_or_else(|| <super::percent::FractionalPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_overall_sampling(&mut self) {
        self.overall_sampling.clear();
    }

    pub fn has_overall_sampling(&self) -> bool {
        self.overall_sampling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overall_sampling(&mut self, v: super::percent::FractionalPercent) {
        self.overall_sampling = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_overall_sampling(&mut self) -> &mut super::percent::FractionalPercent {
        if self.overall_sampling.is_none() {
            self.overall_sampling.set_default();
        }
        self.overall_sampling.as_mut().unwrap()
    }

    // Take field
    pub fn take_overall_sampling(&mut self) -> super::percent::FractionalPercent {
        self.overall_sampling.take().unwrap_or_else(|| super::percent::FractionalPercent::new())
    }

    // repeated .envoy.type.tracing.v3.CustomTag custom_tags = 4;


    pub fn get_custom_tags(&self) -> &[super::custom_tag::CustomTag] {
        &self.custom_tags
    }
    pub fn clear_custom_tags(&mut self) {
        self.custom_tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_tags(&mut self, v: ::protobuf::RepeatedField<super::custom_tag::CustomTag>) {
        self.custom_tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_custom_tags(&mut self) -> &mut ::protobuf::RepeatedField<super::custom_tag::CustomTag> {
        &mut self.custom_tags
    }

    // Take field
    pub fn take_custom_tags(&mut self) -> ::protobuf::RepeatedField<super::custom_tag::CustomTag> {
        ::std::mem::replace(&mut self.custom_tags, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Tracing {
    fn is_initialized(&self) -> bool {
        for v in &self.client_sampling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.random_sampling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.overall_sampling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.custom_tags {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.client_sampling)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.random_sampling)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.overall_sampling)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.custom_tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.client_sampling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.random_sampling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.overall_sampling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.custom_tags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.client_sampling.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.random_sampling.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.overall_sampling.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.custom_tags {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tracing {
        Tracing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::percent::FractionalPercent>>(
                "client_sampling",
                |m: &Tracing| { &m.client_sampling },
                |m: &mut Tracing| { &mut m.client_sampling },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::percent::FractionalPercent>>(
                "random_sampling",
                |m: &Tracing| { &m.random_sampling },
                |m: &mut Tracing| { &mut m.random_sampling },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::percent::FractionalPercent>>(
                "overall_sampling",
                |m: &Tracing| { &m.overall_sampling },
                |m: &mut Tracing| { &mut m.overall_sampling },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::custom_tag::CustomTag>>(
                "custom_tags",
                |m: &Tracing| { &m.custom_tags },
                |m: &mut Tracing| { &mut m.custom_tags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Tracing>(
                "Tracing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Tracing {
        static instance: ::protobuf::rt::LazyV2<Tracing> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Tracing::new)
    }
}

impl ::protobuf::Clear for Tracing {
    fn clear(&mut self) {
        self.client_sampling.clear();
        self.random_sampling.clear();
        self.overall_sampling.clear();
        self.custom_tags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tracing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tracing {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct VirtualCluster {
    // message fields
    pub headers: ::protobuf::RepeatedField<HeaderMatcher>,
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualCluster {
    fn default() -> &'a VirtualCluster {
        <VirtualCluster as ::protobuf::Message>::default_instance()
    }
}

impl VirtualCluster {
    pub fn new() -> VirtualCluster {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.route.v3.HeaderMatcher headers = 4;


    pub fn get_headers(&self) -> &[HeaderMatcher] {
        &self.headers
    }
    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::protobuf::RepeatedField<HeaderMatcher>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::protobuf::RepeatedField<HeaderMatcher> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::protobuf::RepeatedField<HeaderMatcher> {
        ::std::mem::replace(&mut self.headers, ::protobuf::RepeatedField::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VirtualCluster {
    fn is_initialized(&self) -> bool {
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.headers)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.headers {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualCluster {
        VirtualCluster::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeaderMatcher>>(
                "headers",
                |m: &VirtualCluster| { &m.headers },
                |m: &mut VirtualCluster| { &mut m.headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &VirtualCluster| { &m.name },
                |m: &mut VirtualCluster| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualCluster>(
                "VirtualCluster",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualCluster {
        static instance: ::protobuf::rt::LazyV2<VirtualCluster> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualCluster::new)
    }
}

impl ::protobuf::Clear for VirtualCluster {
    fn clear(&mut self) {
        self.headers.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualCluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualCluster {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RateLimit {
    // message fields
    pub stage: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub disable_key: ::std::string::String,
    pub actions: ::protobuf::RepeatedField<RateLimit_Action>,
    pub limit: ::protobuf::SingularPtrField<RateLimit_Override>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit {
    fn default() -> &'a RateLimit {
        <RateLimit as ::protobuf::Message>::default_instance()
    }
}

impl RateLimit {
    pub fn new() -> RateLimit {
        ::std::default::Default::default()
    }

    // .google.protobuf.UInt32Value stage = 1;


    pub fn get_stage(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.stage.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stage(&mut self) {
        self.stage.clear();
    }

    pub fn has_stage(&self) -> bool {
        self.stage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stage(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.stage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stage(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.stage.is_none() {
            self.stage.set_default();
        }
        self.stage.as_mut().unwrap()
    }

    // Take field
    pub fn take_stage(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.stage.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // string disable_key = 2;


    pub fn get_disable_key(&self) -> &str {
        &self.disable_key
    }
    pub fn clear_disable_key(&mut self) {
        self.disable_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_disable_key(&mut self, v: ::std::string::String) {
        self.disable_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disable_key(&mut self) -> &mut ::std::string::String {
        &mut self.disable_key
    }

    // Take field
    pub fn take_disable_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.disable_key, ::std::string::String::new())
    }

    // repeated .envoy.config.route.v3.RateLimit.Action actions = 3;


    pub fn get_actions(&self) -> &[RateLimit_Action] {
        &self.actions
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: ::protobuf::RepeatedField<RateLimit_Action>) {
        self.actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actions(&mut self) -> &mut ::protobuf::RepeatedField<RateLimit_Action> {
        &mut self.actions
    }

    // Take field
    pub fn take_actions(&mut self) -> ::protobuf::RepeatedField<RateLimit_Action> {
        ::std::mem::replace(&mut self.actions, ::protobuf::RepeatedField::new())
    }

    // .envoy.config.route.v3.RateLimit.Override limit = 4;


    pub fn get_limit(&self) -> &RateLimit_Override {
        self.limit.as_ref().unwrap_or_else(|| <RateLimit_Override as ::protobuf::Message>::default_instance())
    }
    pub fn clear_limit(&mut self) {
        self.limit.clear();
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: RateLimit_Override) {
        self.limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limit(&mut self) -> &mut RateLimit_Override {
        if self.limit.is_none() {
            self.limit.set_default();
        }
        self.limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_limit(&mut self) -> RateLimit_Override {
        self.limit.take().unwrap_or_else(|| RateLimit_Override::new())
    }
}

impl ::protobuf::Message for RateLimit {
    fn is_initialized(&self) -> bool {
        for v in &self.stage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.actions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stage)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.disable_key)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.actions)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.disable_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.disable_key);
        }
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stage.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.disable_key.is_empty() {
            os.write_string(2, &self.disable_key)?;
        }
        for v in &self.actions {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.limit.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit {
        RateLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "stage",
                |m: &RateLimit| { &m.stage },
                |m: &mut RateLimit| { &mut m.stage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "disable_key",
                |m: &RateLimit| { &m.disable_key },
                |m: &mut RateLimit| { &mut m.disable_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateLimit_Action>>(
                "actions",
                |m: &RateLimit| { &m.actions },
                |m: &mut RateLimit| { &mut m.actions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateLimit_Override>>(
                "limit",
                |m: &RateLimit| { &m.limit },
                |m: &mut RateLimit| { &mut m.limit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit>(
                "RateLimit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit {
        static instance: ::protobuf::rt::LazyV2<RateLimit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit::new)
    }
}

impl ::protobuf::Clear for RateLimit {
    fn clear(&mut self) {
        self.stage.clear();
        self.disable_key.clear();
        self.actions.clear();
        self.limit.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RateLimit_Action {
    // message oneof groups
    pub action_specifier: ::std::option::Option<RateLimit_Action_oneof_action_specifier>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Action {
    fn default() -> &'a RateLimit_Action {
        <RateLimit_Action as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RateLimit_Action_oneof_action_specifier {
    source_cluster(RateLimit_Action_SourceCluster),
    destination_cluster(RateLimit_Action_DestinationCluster),
    request_headers(RateLimit_Action_RequestHeaders),
    remote_address(RateLimit_Action_RemoteAddress),
    generic_key(RateLimit_Action_GenericKey),
    header_value_match(RateLimit_Action_HeaderValueMatch),
    dynamic_metadata(RateLimit_Action_DynamicMetaData),
    metadata(RateLimit_Action_MetaData),
    extension(super::extension::TypedExtensionConfig),
}

impl RateLimit_Action {
    pub fn new() -> RateLimit_Action {
        ::std::default::Default::default()
    }

    // .envoy.config.route.v3.RateLimit.Action.SourceCluster source_cluster = 1;


    pub fn get_source_cluster(&self) -> &RateLimit_Action_SourceCluster {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::source_cluster(ref v)) => v,
            _ => <RateLimit_Action_SourceCluster as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_source_cluster(&mut self) {
        self.action_specifier = ::std::option::Option::None;
    }

    pub fn has_source_cluster(&self) -> bool {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::source_cluster(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_source_cluster(&mut self, v: RateLimit_Action_SourceCluster) {
        self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::source_cluster(v))
    }

    // Mutable pointer to the field.
    pub fn mut_source_cluster(&mut self) -> &mut RateLimit_Action_SourceCluster {
        if let ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::source_cluster(_)) = self.action_specifier {
        } else {
            self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::source_cluster(RateLimit_Action_SourceCluster::new()));
        }
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::source_cluster(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_source_cluster(&mut self) -> RateLimit_Action_SourceCluster {
        if self.has_source_cluster() {
            match self.action_specifier.take() {
                ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::source_cluster(v)) => v,
                _ => panic!(),
            }
        } else {
            RateLimit_Action_SourceCluster::new()
        }
    }

    // .envoy.config.route.v3.RateLimit.Action.DestinationCluster destination_cluster = 2;


    pub fn get_destination_cluster(&self) -> &RateLimit_Action_DestinationCluster {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::destination_cluster(ref v)) => v,
            _ => <RateLimit_Action_DestinationCluster as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_destination_cluster(&mut self) {
        self.action_specifier = ::std::option::Option::None;
    }

    pub fn has_destination_cluster(&self) -> bool {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::destination_cluster(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_destination_cluster(&mut self, v: RateLimit_Action_DestinationCluster) {
        self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::destination_cluster(v))
    }

    // Mutable pointer to the field.
    pub fn mut_destination_cluster(&mut self) -> &mut RateLimit_Action_DestinationCluster {
        if let ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::destination_cluster(_)) = self.action_specifier {
        } else {
            self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::destination_cluster(RateLimit_Action_DestinationCluster::new()));
        }
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::destination_cluster(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_destination_cluster(&mut self) -> RateLimit_Action_DestinationCluster {
        if self.has_destination_cluster() {
            match self.action_specifier.take() {
                ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::destination_cluster(v)) => v,
                _ => panic!(),
            }
        } else {
            RateLimit_Action_DestinationCluster::new()
        }
    }

    // .envoy.config.route.v3.RateLimit.Action.RequestHeaders request_headers = 3;


    pub fn get_request_headers(&self) -> &RateLimit_Action_RequestHeaders {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::request_headers(ref v)) => v,
            _ => <RateLimit_Action_RequestHeaders as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_request_headers(&mut self) {
        self.action_specifier = ::std::option::Option::None;
    }

    pub fn has_request_headers(&self) -> bool {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::request_headers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_headers(&mut self, v: RateLimit_Action_RequestHeaders) {
        self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::request_headers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers(&mut self) -> &mut RateLimit_Action_RequestHeaders {
        if let ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::request_headers(_)) = self.action_specifier {
        } else {
            self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::request_headers(RateLimit_Action_RequestHeaders::new()));
        }
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::request_headers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_headers(&mut self) -> RateLimit_Action_RequestHeaders {
        if self.has_request_headers() {
            match self.action_specifier.take() {
                ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::request_headers(v)) => v,
                _ => panic!(),
            }
        } else {
            RateLimit_Action_RequestHeaders::new()
        }
    }

    // .envoy.config.route.v3.RateLimit.Action.RemoteAddress remote_address = 4;


    pub fn get_remote_address(&self) -> &RateLimit_Action_RemoteAddress {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::remote_address(ref v)) => v,
            _ => <RateLimit_Action_RemoteAddress as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_remote_address(&mut self) {
        self.action_specifier = ::std::option::Option::None;
    }

    pub fn has_remote_address(&self) -> bool {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::remote_address(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remote_address(&mut self, v: RateLimit_Action_RemoteAddress) {
        self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::remote_address(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remote_address(&mut self) -> &mut RateLimit_Action_RemoteAddress {
        if let ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::remote_address(_)) = self.action_specifier {
        } else {
            self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::remote_address(RateLimit_Action_RemoteAddress::new()));
        }
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::remote_address(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remote_address(&mut self) -> RateLimit_Action_RemoteAddress {
        if self.has_remote_address() {
            match self.action_specifier.take() {
                ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::remote_address(v)) => v,
                _ => panic!(),
            }
        } else {
            RateLimit_Action_RemoteAddress::new()
        }
    }

    // .envoy.config.route.v3.RateLimit.Action.GenericKey generic_key = 5;


    pub fn get_generic_key(&self) -> &RateLimit_Action_GenericKey {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::generic_key(ref v)) => v,
            _ => <RateLimit_Action_GenericKey as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_generic_key(&mut self) {
        self.action_specifier = ::std::option::Option::None;
    }

    pub fn has_generic_key(&self) -> bool {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::generic_key(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_generic_key(&mut self, v: RateLimit_Action_GenericKey) {
        self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::generic_key(v))
    }

    // Mutable pointer to the field.
    pub fn mut_generic_key(&mut self) -> &mut RateLimit_Action_GenericKey {
        if let ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::generic_key(_)) = self.action_specifier {
        } else {
            self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::generic_key(RateLimit_Action_GenericKey::new()));
        }
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::generic_key(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_generic_key(&mut self) -> RateLimit_Action_GenericKey {
        if self.has_generic_key() {
            match self.action_specifier.take() {
                ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::generic_key(v)) => v,
                _ => panic!(),
            }
        } else {
            RateLimit_Action_GenericKey::new()
        }
    }

    // .envoy.config.route.v3.RateLimit.Action.HeaderValueMatch header_value_match = 6;


    pub fn get_header_value_match(&self) -> &RateLimit_Action_HeaderValueMatch {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::header_value_match(ref v)) => v,
            _ => <RateLimit_Action_HeaderValueMatch as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_header_value_match(&mut self) {
        self.action_specifier = ::std::option::Option::None;
    }

    pub fn has_header_value_match(&self) -> bool {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::header_value_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_header_value_match(&mut self, v: RateLimit_Action_HeaderValueMatch) {
        self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::header_value_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_header_value_match(&mut self) -> &mut RateLimit_Action_HeaderValueMatch {
        if let ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::header_value_match(_)) = self.action_specifier {
        } else {
            self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::header_value_match(RateLimit_Action_HeaderValueMatch::new()));
        }
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::header_value_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_header_value_match(&mut self) -> RateLimit_Action_HeaderValueMatch {
        if self.has_header_value_match() {
            match self.action_specifier.take() {
                ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::header_value_match(v)) => v,
                _ => panic!(),
            }
        } else {
            RateLimit_Action_HeaderValueMatch::new()
        }
    }

    // .envoy.config.route.v3.RateLimit.Action.DynamicMetaData dynamic_metadata = 7;


    pub fn get_dynamic_metadata(&self) -> &RateLimit_Action_DynamicMetaData {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::dynamic_metadata(ref v)) => v,
            _ => <RateLimit_Action_DynamicMetaData as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_dynamic_metadata(&mut self) {
        self.action_specifier = ::std::option::Option::None;
    }

    pub fn has_dynamic_metadata(&self) -> bool {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::dynamic_metadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dynamic_metadata(&mut self, v: RateLimit_Action_DynamicMetaData) {
        self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::dynamic_metadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dynamic_metadata(&mut self) -> &mut RateLimit_Action_DynamicMetaData {
        if let ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::dynamic_metadata(_)) = self.action_specifier {
        } else {
            self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::dynamic_metadata(RateLimit_Action_DynamicMetaData::new()));
        }
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::dynamic_metadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dynamic_metadata(&mut self) -> RateLimit_Action_DynamicMetaData {
        if self.has_dynamic_metadata() {
            match self.action_specifier.take() {
                ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::dynamic_metadata(v)) => v,
                _ => panic!(),
            }
        } else {
            RateLimit_Action_DynamicMetaData::new()
        }
    }

    // .envoy.config.route.v3.RateLimit.Action.MetaData metadata = 8;


    pub fn get_metadata(&self) -> &RateLimit_Action_MetaData {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::metadata(ref v)) => v,
            _ => <RateLimit_Action_MetaData as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_metadata(&mut self) {
        self.action_specifier = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::metadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: RateLimit_Action_MetaData) {
        self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::metadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut RateLimit_Action_MetaData {
        if let ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::metadata(_)) = self.action_specifier {
        } else {
            self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::metadata(RateLimit_Action_MetaData::new()));
        }
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::metadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_metadata(&mut self) -> RateLimit_Action_MetaData {
        if self.has_metadata() {
            match self.action_specifier.take() {
                ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::metadata(v)) => v,
                _ => panic!(),
            }
        } else {
            RateLimit_Action_MetaData::new()
        }
    }

    // .envoy.config.core.v3.TypedExtensionConfig extension = 9;


    pub fn get_extension(&self) -> &super::extension::TypedExtensionConfig {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::extension(ref v)) => v,
            _ => <super::extension::TypedExtensionConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_extension(&mut self) {
        self.action_specifier = ::std::option::Option::None;
    }

    pub fn has_extension(&self) -> bool {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::extension(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: super::extension::TypedExtensionConfig) {
        self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::extension(v))
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut super::extension::TypedExtensionConfig {
        if let ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::extension(_)) = self.action_specifier {
        } else {
            self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::extension(super::extension::TypedExtensionConfig::new()));
        }
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::extension(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_extension(&mut self) -> super::extension::TypedExtensionConfig {
        if self.has_extension() {
            match self.action_specifier.take() {
                ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::extension(v)) => v,
                _ => panic!(),
            }
        } else {
            super::extension::TypedExtensionConfig::new()
        }
    }
}

impl ::protobuf::Message for RateLimit_Action {
    fn is_initialized(&self) -> bool {
        if let Some(RateLimit_Action_oneof_action_specifier::source_cluster(ref v)) = self.action_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RateLimit_Action_oneof_action_specifier::destination_cluster(ref v)) = self.action_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RateLimit_Action_oneof_action_specifier::request_headers(ref v)) = self.action_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RateLimit_Action_oneof_action_specifier::remote_address(ref v)) = self.action_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RateLimit_Action_oneof_action_specifier::generic_key(ref v)) = self.action_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RateLimit_Action_oneof_action_specifier::header_value_match(ref v)) = self.action_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RateLimit_Action_oneof_action_specifier::dynamic_metadata(ref v)) = self.action_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RateLimit_Action_oneof_action_specifier::metadata(ref v)) = self.action_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RateLimit_Action_oneof_action_specifier::extension(ref v)) = self.action_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::source_cluster(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::destination_cluster(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::request_headers(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::remote_address(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::generic_key(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::header_value_match(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::dynamic_metadata(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::metadata(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::extension(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.action_specifier {
            match v {
                &RateLimit_Action_oneof_action_specifier::source_cluster(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RateLimit_Action_oneof_action_specifier::destination_cluster(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RateLimit_Action_oneof_action_specifier::request_headers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RateLimit_Action_oneof_action_specifier::remote_address(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RateLimit_Action_oneof_action_specifier::generic_key(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RateLimit_Action_oneof_action_specifier::header_value_match(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RateLimit_Action_oneof_action_specifier::dynamic_metadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RateLimit_Action_oneof_action_specifier::metadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RateLimit_Action_oneof_action_specifier::extension(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.action_specifier {
            match v {
                &RateLimit_Action_oneof_action_specifier::source_cluster(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RateLimit_Action_oneof_action_specifier::destination_cluster(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RateLimit_Action_oneof_action_specifier::request_headers(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RateLimit_Action_oneof_action_specifier::remote_address(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RateLimit_Action_oneof_action_specifier::generic_key(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RateLimit_Action_oneof_action_specifier::header_value_match(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RateLimit_Action_oneof_action_specifier::dynamic_metadata(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RateLimit_Action_oneof_action_specifier::metadata(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RateLimit_Action_oneof_action_specifier::extension(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Action {
        RateLimit_Action::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RateLimit_Action_SourceCluster>(
                "source_cluster",
                RateLimit_Action::has_source_cluster,
                RateLimit_Action::get_source_cluster,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RateLimit_Action_DestinationCluster>(
                "destination_cluster",
                RateLimit_Action::has_destination_cluster,
                RateLimit_Action::get_destination_cluster,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RateLimit_Action_RequestHeaders>(
                "request_headers",
                RateLimit_Action::has_request_headers,
                RateLimit_Action::get_request_headers,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RateLimit_Action_RemoteAddress>(
                "remote_address",
                RateLimit_Action::has_remote_address,
                RateLimit_Action::get_remote_address,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RateLimit_Action_GenericKey>(
                "generic_key",
                RateLimit_Action::has_generic_key,
                RateLimit_Action::get_generic_key,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RateLimit_Action_HeaderValueMatch>(
                "header_value_match",
                RateLimit_Action::has_header_value_match,
                RateLimit_Action::get_header_value_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RateLimit_Action_DynamicMetaData>(
                "dynamic_metadata",
                RateLimit_Action::has_dynamic_metadata,
                RateLimit_Action::get_dynamic_metadata,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RateLimit_Action_MetaData>(
                "metadata",
                RateLimit_Action::has_metadata,
                RateLimit_Action::get_metadata,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::extension::TypedExtensionConfig>(
                "extension",
                RateLimit_Action::has_extension,
                RateLimit_Action::get_extension,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Action>(
                "RateLimit.Action",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Action {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Action> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Action::new)
    }
}

impl ::protobuf::Clear for RateLimit_Action {
    fn clear(&mut self) {
        self.action_specifier = ::std::option::Option::None;
        self.action_specifier = ::std::option::Option::None;
        self.action_specifier = ::std::option::Option::None;
        self.action_specifier = ::std::option::Option::None;
        self.action_specifier = ::std::option::Option::None;
        self.action_specifier = ::std::option::Option::None;
        self.action_specifier = ::std::option::Option::None;
        self.action_specifier = ::std::option::Option::None;
        self.action_specifier = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RateLimit_Action_SourceCluster {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Action_SourceCluster {
    fn default() -> &'a RateLimit_Action_SourceCluster {
        <RateLimit_Action_SourceCluster as ::protobuf::Message>::default_instance()
    }
}

impl RateLimit_Action_SourceCluster {
    pub fn new() -> RateLimit_Action_SourceCluster {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RateLimit_Action_SourceCluster {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Action_SourceCluster {
        RateLimit_Action_SourceCluster::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Action_SourceCluster>(
                "RateLimit.Action.SourceCluster",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Action_SourceCluster {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Action_SourceCluster> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Action_SourceCluster::new)
    }
}

impl ::protobuf::Clear for RateLimit_Action_SourceCluster {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Action_SourceCluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Action_SourceCluster {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RateLimit_Action_DestinationCluster {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Action_DestinationCluster {
    fn default() -> &'a RateLimit_Action_DestinationCluster {
        <RateLimit_Action_DestinationCluster as ::protobuf::Message>::default_instance()
    }
}

impl RateLimit_Action_DestinationCluster {
    pub fn new() -> RateLimit_Action_DestinationCluster {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RateLimit_Action_DestinationCluster {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Action_DestinationCluster {
        RateLimit_Action_DestinationCluster::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Action_DestinationCluster>(
                "RateLimit.Action.DestinationCluster",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Action_DestinationCluster {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Action_DestinationCluster> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Action_DestinationCluster::new)
    }
}

impl ::protobuf::Clear for RateLimit_Action_DestinationCluster {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Action_DestinationCluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Action_DestinationCluster {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RateLimit_Action_RequestHeaders {
    // message fields
    pub header_name: ::std::string::String,
    pub descriptor_key: ::std::string::String,
    pub skip_if_absent: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Action_RequestHeaders {
    fn default() -> &'a RateLimit_Action_RequestHeaders {
        <RateLimit_Action_RequestHeaders as ::protobuf::Message>::default_instance()
    }
}

impl RateLimit_Action_RequestHeaders {
    pub fn new() -> RateLimit_Action_RequestHeaders {
        ::std::default::Default::default()
    }

    // string header_name = 1;


    pub fn get_header_name(&self) -> &str {
        &self.header_name
    }
    pub fn clear_header_name(&mut self) {
        self.header_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_header_name(&mut self, v: ::std::string::String) {
        self.header_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header_name(&mut self) -> &mut ::std::string::String {
        &mut self.header_name
    }

    // Take field
    pub fn take_header_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.header_name, ::std::string::String::new())
    }

    // string descriptor_key = 2;


    pub fn get_descriptor_key(&self) -> &str {
        &self.descriptor_key
    }
    pub fn clear_descriptor_key(&mut self) {
        self.descriptor_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_descriptor_key(&mut self, v: ::std::string::String) {
        self.descriptor_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_descriptor_key(&mut self) -> &mut ::std::string::String {
        &mut self.descriptor_key
    }

    // Take field
    pub fn take_descriptor_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.descriptor_key, ::std::string::String::new())
    }

    // bool skip_if_absent = 3;


    pub fn get_skip_if_absent(&self) -> bool {
        self.skip_if_absent
    }
    pub fn clear_skip_if_absent(&mut self) {
        self.skip_if_absent = false;
    }

    // Param is passed by value, moved
    pub fn set_skip_if_absent(&mut self, v: bool) {
        self.skip_if_absent = v;
    }
}

impl ::protobuf::Message for RateLimit_Action_RequestHeaders {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.header_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.descriptor_key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.skip_if_absent = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.header_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.header_name);
        }
        if !self.descriptor_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.descriptor_key);
        }
        if self.skip_if_absent != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.header_name.is_empty() {
            os.write_string(1, &self.header_name)?;
        }
        if !self.descriptor_key.is_empty() {
            os.write_string(2, &self.descriptor_key)?;
        }
        if self.skip_if_absent != false {
            os.write_bool(3, self.skip_if_absent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Action_RequestHeaders {
        RateLimit_Action_RequestHeaders::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "header_name",
                |m: &RateLimit_Action_RequestHeaders| { &m.header_name },
                |m: &mut RateLimit_Action_RequestHeaders| { &mut m.header_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptor_key",
                |m: &RateLimit_Action_RequestHeaders| { &m.descriptor_key },
                |m: &mut RateLimit_Action_RequestHeaders| { &mut m.descriptor_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "skip_if_absent",
                |m: &RateLimit_Action_RequestHeaders| { &m.skip_if_absent },
                |m: &mut RateLimit_Action_RequestHeaders| { &mut m.skip_if_absent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Action_RequestHeaders>(
                "RateLimit.Action.RequestHeaders",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Action_RequestHeaders {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Action_RequestHeaders> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Action_RequestHeaders::new)
    }
}

impl ::protobuf::Clear for RateLimit_Action_RequestHeaders {
    fn clear(&mut self) {
        self.header_name.clear();
        self.descriptor_key.clear();
        self.skip_if_absent = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Action_RequestHeaders {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Action_RequestHeaders {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RateLimit_Action_RemoteAddress {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Action_RemoteAddress {
    fn default() -> &'a RateLimit_Action_RemoteAddress {
        <RateLimit_Action_RemoteAddress as ::protobuf::Message>::default_instance()
    }
}

impl RateLimit_Action_RemoteAddress {
    pub fn new() -> RateLimit_Action_RemoteAddress {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RateLimit_Action_RemoteAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Action_RemoteAddress {
        RateLimit_Action_RemoteAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Action_RemoteAddress>(
                "RateLimit.Action.RemoteAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Action_RemoteAddress {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Action_RemoteAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Action_RemoteAddress::new)
    }
}

impl ::protobuf::Clear for RateLimit_Action_RemoteAddress {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Action_RemoteAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Action_RemoteAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RateLimit_Action_GenericKey {
    // message fields
    pub descriptor_value: ::std::string::String,
    pub descriptor_key: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Action_GenericKey {
    fn default() -> &'a RateLimit_Action_GenericKey {
        <RateLimit_Action_GenericKey as ::protobuf::Message>::default_instance()
    }
}

impl RateLimit_Action_GenericKey {
    pub fn new() -> RateLimit_Action_GenericKey {
        ::std::default::Default::default()
    }

    // string descriptor_value = 1;


    pub fn get_descriptor_value(&self) -> &str {
        &self.descriptor_value
    }
    pub fn clear_descriptor_value(&mut self) {
        self.descriptor_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_descriptor_value(&mut self, v: ::std::string::String) {
        self.descriptor_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_descriptor_value(&mut self) -> &mut ::std::string::String {
        &mut self.descriptor_value
    }

    // Take field
    pub fn take_descriptor_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.descriptor_value, ::std::string::String::new())
    }

    // string descriptor_key = 2;


    pub fn get_descriptor_key(&self) -> &str {
        &self.descriptor_key
    }
    pub fn clear_descriptor_key(&mut self) {
        self.descriptor_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_descriptor_key(&mut self, v: ::std::string::String) {
        self.descriptor_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_descriptor_key(&mut self) -> &mut ::std::string::String {
        &mut self.descriptor_key
    }

    // Take field
    pub fn take_descriptor_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.descriptor_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RateLimit_Action_GenericKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.descriptor_value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.descriptor_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.descriptor_value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.descriptor_value);
        }
        if !self.descriptor_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.descriptor_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.descriptor_value.is_empty() {
            os.write_string(1, &self.descriptor_value)?;
        }
        if !self.descriptor_key.is_empty() {
            os.write_string(2, &self.descriptor_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Action_GenericKey {
        RateLimit_Action_GenericKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptor_value",
                |m: &RateLimit_Action_GenericKey| { &m.descriptor_value },
                |m: &mut RateLimit_Action_GenericKey| { &mut m.descriptor_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptor_key",
                |m: &RateLimit_Action_GenericKey| { &m.descriptor_key },
                |m: &mut RateLimit_Action_GenericKey| { &mut m.descriptor_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Action_GenericKey>(
                "RateLimit.Action.GenericKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Action_GenericKey {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Action_GenericKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Action_GenericKey::new)
    }
}

impl ::protobuf::Clear for RateLimit_Action_GenericKey {
    fn clear(&mut self) {
        self.descriptor_value.clear();
        self.descriptor_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Action_GenericKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Action_GenericKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RateLimit_Action_HeaderValueMatch {
    // message fields
    pub descriptor_value: ::std::string::String,
    pub expect_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub headers: ::protobuf::RepeatedField<HeaderMatcher>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Action_HeaderValueMatch {
    fn default() -> &'a RateLimit_Action_HeaderValueMatch {
        <RateLimit_Action_HeaderValueMatch as ::protobuf::Message>::default_instance()
    }
}

impl RateLimit_Action_HeaderValueMatch {
    pub fn new() -> RateLimit_Action_HeaderValueMatch {
        ::std::default::Default::default()
    }

    // string descriptor_value = 1;


    pub fn get_descriptor_value(&self) -> &str {
        &self.descriptor_value
    }
    pub fn clear_descriptor_value(&mut self) {
        self.descriptor_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_descriptor_value(&mut self, v: ::std::string::String) {
        self.descriptor_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_descriptor_value(&mut self) -> &mut ::std::string::String {
        &mut self.descriptor_value
    }

    // Take field
    pub fn take_descriptor_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.descriptor_value, ::std::string::String::new())
    }

    // .google.protobuf.BoolValue expect_match = 2;


    pub fn get_expect_match(&self) -> &::protobuf::well_known_types::BoolValue {
        self.expect_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expect_match(&mut self) {
        self.expect_match.clear();
    }

    pub fn has_expect_match(&self) -> bool {
        self.expect_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expect_match(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.expect_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expect_match(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.expect_match.is_none() {
            self.expect_match.set_default();
        }
        self.expect_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_expect_match(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.expect_match.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // repeated .envoy.config.route.v3.HeaderMatcher headers = 3;


    pub fn get_headers(&self) -> &[HeaderMatcher] {
        &self.headers
    }
    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::protobuf::RepeatedField<HeaderMatcher>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::protobuf::RepeatedField<HeaderMatcher> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::protobuf::RepeatedField<HeaderMatcher> {
        ::std::mem::replace(&mut self.headers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RateLimit_Action_HeaderValueMatch {
    fn is_initialized(&self) -> bool {
        for v in &self.expect_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.descriptor_value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expect_match)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.headers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.descriptor_value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.descriptor_value);
        }
        if let Some(ref v) = self.expect_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.descriptor_value.is_empty() {
            os.write_string(1, &self.descriptor_value)?;
        }
        if let Some(ref v) = self.expect_match.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.headers {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Action_HeaderValueMatch {
        RateLimit_Action_HeaderValueMatch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptor_value",
                |m: &RateLimit_Action_HeaderValueMatch| { &m.descriptor_value },
                |m: &mut RateLimit_Action_HeaderValueMatch| { &mut m.descriptor_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "expect_match",
                |m: &RateLimit_Action_HeaderValueMatch| { &m.expect_match },
                |m: &mut RateLimit_Action_HeaderValueMatch| { &mut m.expect_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeaderMatcher>>(
                "headers",
                |m: &RateLimit_Action_HeaderValueMatch| { &m.headers },
                |m: &mut RateLimit_Action_HeaderValueMatch| { &mut m.headers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Action_HeaderValueMatch>(
                "RateLimit.Action.HeaderValueMatch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Action_HeaderValueMatch {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Action_HeaderValueMatch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Action_HeaderValueMatch::new)
    }
}

impl ::protobuf::Clear for RateLimit_Action_HeaderValueMatch {
    fn clear(&mut self) {
        self.descriptor_value.clear();
        self.expect_match.clear();
        self.headers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Action_HeaderValueMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Action_HeaderValueMatch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RateLimit_Action_DynamicMetaData {
    // message fields
    pub descriptor_key: ::std::string::String,
    pub metadata_key: ::protobuf::SingularPtrField<super::metadata::MetadataKey>,
    pub default_value: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Action_DynamicMetaData {
    fn default() -> &'a RateLimit_Action_DynamicMetaData {
        <RateLimit_Action_DynamicMetaData as ::protobuf::Message>::default_instance()
    }
}

impl RateLimit_Action_DynamicMetaData {
    pub fn new() -> RateLimit_Action_DynamicMetaData {
        ::std::default::Default::default()
    }

    // string descriptor_key = 1;


    pub fn get_descriptor_key(&self) -> &str {
        &self.descriptor_key
    }
    pub fn clear_descriptor_key(&mut self) {
        self.descriptor_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_descriptor_key(&mut self, v: ::std::string::String) {
        self.descriptor_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_descriptor_key(&mut self) -> &mut ::std::string::String {
        &mut self.descriptor_key
    }

    // Take field
    pub fn take_descriptor_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.descriptor_key, ::std::string::String::new())
    }

    // .envoy.type.metadata.v3.MetadataKey metadata_key = 2;


    pub fn get_metadata_key(&self) -> &super::metadata::MetadataKey {
        self.metadata_key.as_ref().unwrap_or_else(|| <super::metadata::MetadataKey as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata_key(&mut self) {
        self.metadata_key.clear();
    }

    pub fn has_metadata_key(&self) -> bool {
        self.metadata_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata_key(&mut self, v: super::metadata::MetadataKey) {
        self.metadata_key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata_key(&mut self) -> &mut super::metadata::MetadataKey {
        if self.metadata_key.is_none() {
            self.metadata_key.set_default();
        }
        self.metadata_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata_key(&mut self) -> super::metadata::MetadataKey {
        self.metadata_key.take().unwrap_or_else(|| super::metadata::MetadataKey::new())
    }

    // string default_value = 3;


    pub fn get_default_value(&self) -> &str {
        &self.default_value
    }
    pub fn clear_default_value(&mut self) {
        self.default_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_value(&mut self, v: ::std::string::String) {
        self.default_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_value(&mut self) -> &mut ::std::string::String {
        &mut self.default_value
    }

    // Take field
    pub fn take_default_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RateLimit_Action_DynamicMetaData {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata_key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.descriptor_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.descriptor_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.descriptor_key);
        }
        if let Some(ref v) = self.metadata_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.default_value.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.default_value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.descriptor_key.is_empty() {
            os.write_string(1, &self.descriptor_key)?;
        }
        if let Some(ref v) = self.metadata_key.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.default_value.is_empty() {
            os.write_string(3, &self.default_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Action_DynamicMetaData {
        RateLimit_Action_DynamicMetaData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptor_key",
                |m: &RateLimit_Action_DynamicMetaData| { &m.descriptor_key },
                |m: &mut RateLimit_Action_DynamicMetaData| { &mut m.descriptor_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::metadata::MetadataKey>>(
                "metadata_key",
                |m: &RateLimit_Action_DynamicMetaData| { &m.metadata_key },
                |m: &mut RateLimit_Action_DynamicMetaData| { &mut m.metadata_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "default_value",
                |m: &RateLimit_Action_DynamicMetaData| { &m.default_value },
                |m: &mut RateLimit_Action_DynamicMetaData| { &mut m.default_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Action_DynamicMetaData>(
                "RateLimit.Action.DynamicMetaData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Action_DynamicMetaData {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Action_DynamicMetaData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Action_DynamicMetaData::new)
    }
}

impl ::protobuf::Clear for RateLimit_Action_DynamicMetaData {
    fn clear(&mut self) {
        self.descriptor_key.clear();
        self.metadata_key.clear();
        self.default_value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Action_DynamicMetaData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Action_DynamicMetaData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RateLimit_Action_MetaData {
    // message fields
    pub descriptor_key: ::std::string::String,
    pub metadata_key: ::protobuf::SingularPtrField<super::metadata::MetadataKey>,
    pub default_value: ::std::string::String,
    pub source: RateLimit_Action_MetaData_Source,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Action_MetaData {
    fn default() -> &'a RateLimit_Action_MetaData {
        <RateLimit_Action_MetaData as ::protobuf::Message>::default_instance()
    }
}

impl RateLimit_Action_MetaData {
    pub fn new() -> RateLimit_Action_MetaData {
        ::std::default::Default::default()
    }

    // string descriptor_key = 1;


    pub fn get_descriptor_key(&self) -> &str {
        &self.descriptor_key
    }
    pub fn clear_descriptor_key(&mut self) {
        self.descriptor_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_descriptor_key(&mut self, v: ::std::string::String) {
        self.descriptor_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_descriptor_key(&mut self) -> &mut ::std::string::String {
        &mut self.descriptor_key
    }

    // Take field
    pub fn take_descriptor_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.descriptor_key, ::std::string::String::new())
    }

    // .envoy.type.metadata.v3.MetadataKey metadata_key = 2;


    pub fn get_metadata_key(&self) -> &super::metadata::MetadataKey {
        self.metadata_key.as_ref().unwrap_or_else(|| <super::metadata::MetadataKey as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata_key(&mut self) {
        self.metadata_key.clear();
    }

    pub fn has_metadata_key(&self) -> bool {
        self.metadata_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata_key(&mut self, v: super::metadata::MetadataKey) {
        self.metadata_key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata_key(&mut self) -> &mut super::metadata::MetadataKey {
        if self.metadata_key.is_none() {
            self.metadata_key.set_default();
        }
        self.metadata_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata_key(&mut self) -> super::metadata::MetadataKey {
        self.metadata_key.take().unwrap_or_else(|| super::metadata::MetadataKey::new())
    }

    // string default_value = 3;


    pub fn get_default_value(&self) -> &str {
        &self.default_value
    }
    pub fn clear_default_value(&mut self) {
        self.default_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_value(&mut self, v: ::std::string::String) {
        self.default_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_value(&mut self) -> &mut ::std::string::String {
        &mut self.default_value
    }

    // Take field
    pub fn take_default_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_value, ::std::string::String::new())
    }

    // .envoy.config.route.v3.RateLimit.Action.MetaData.Source source = 4;


    pub fn get_source(&self) -> RateLimit_Action_MetaData_Source {
        self.source
    }
    pub fn clear_source(&mut self) {
        self.source = RateLimit_Action_MetaData_Source::DYNAMIC;
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: RateLimit_Action_MetaData_Source) {
        self.source = v;
    }
}

impl ::protobuf::Message for RateLimit_Action_MetaData {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata_key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.descriptor_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_value)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.source, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.descriptor_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.descriptor_key);
        }
        if let Some(ref v) = self.metadata_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.default_value.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.default_value);
        }
        if self.source != RateLimit_Action_MetaData_Source::DYNAMIC {
            my_size += ::protobuf::rt::enum_size(4, self.source);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.descriptor_key.is_empty() {
            os.write_string(1, &self.descriptor_key)?;
        }
        if let Some(ref v) = self.metadata_key.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.default_value.is_empty() {
            os.write_string(3, &self.default_value)?;
        }
        if self.source != RateLimit_Action_MetaData_Source::DYNAMIC {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.source))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Action_MetaData {
        RateLimit_Action_MetaData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptor_key",
                |m: &RateLimit_Action_MetaData| { &m.descriptor_key },
                |m: &mut RateLimit_Action_MetaData| { &mut m.descriptor_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::metadata::MetadataKey>>(
                "metadata_key",
                |m: &RateLimit_Action_MetaData| { &m.metadata_key },
                |m: &mut RateLimit_Action_MetaData| { &mut m.metadata_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "default_value",
                |m: &RateLimit_Action_MetaData| { &m.default_value },
                |m: &mut RateLimit_Action_MetaData| { &mut m.default_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RateLimit_Action_MetaData_Source>>(
                "source",
                |m: &RateLimit_Action_MetaData| { &m.source },
                |m: &mut RateLimit_Action_MetaData| { &mut m.source },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Action_MetaData>(
                "RateLimit.Action.MetaData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Action_MetaData {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Action_MetaData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Action_MetaData::new)
    }
}

impl ::protobuf::Clear for RateLimit_Action_MetaData {
    fn clear(&mut self) {
        self.descriptor_key.clear();
        self.metadata_key.clear();
        self.default_value.clear();
        self.source = RateLimit_Action_MetaData_Source::DYNAMIC;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Action_MetaData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Action_MetaData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RateLimit_Action_MetaData_Source {
    DYNAMIC = 0,
    ROUTE_ENTRY = 1,
}

impl ::protobuf::ProtobufEnum for RateLimit_Action_MetaData_Source {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RateLimit_Action_MetaData_Source> {
        match value {
            0 => ::std::option::Option::Some(RateLimit_Action_MetaData_Source::DYNAMIC),
            1 => ::std::option::Option::Some(RateLimit_Action_MetaData_Source::ROUTE_ENTRY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RateLimit_Action_MetaData_Source] = &[
            RateLimit_Action_MetaData_Source::DYNAMIC,
            RateLimit_Action_MetaData_Source::ROUTE_ENTRY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RateLimit_Action_MetaData_Source>("RateLimit.Action.MetaData.Source", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RateLimit_Action_MetaData_Source {
}

impl ::std::default::Default for RateLimit_Action_MetaData_Source {
    fn default() -> Self {
        RateLimit_Action_MetaData_Source::DYNAMIC
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Action_MetaData_Source {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RateLimit_Override {
    // message oneof groups
    pub override_specifier: ::std::option::Option<RateLimit_Override_oneof_override_specifier>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Override {
    fn default() -> &'a RateLimit_Override {
        <RateLimit_Override as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RateLimit_Override_oneof_override_specifier {
    dynamic_metadata(RateLimit_Override_DynamicMetadata),
}

impl RateLimit_Override {
    pub fn new() -> RateLimit_Override {
        ::std::default::Default::default()
    }

    // .envoy.config.route.v3.RateLimit.Override.DynamicMetadata dynamic_metadata = 1;


    pub fn get_dynamic_metadata(&self) -> &RateLimit_Override_DynamicMetadata {
        match self.override_specifier {
            ::std::option::Option::Some(RateLimit_Override_oneof_override_specifier::dynamic_metadata(ref v)) => v,
            _ => <RateLimit_Override_DynamicMetadata as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_dynamic_metadata(&mut self) {
        self.override_specifier = ::std::option::Option::None;
    }

    pub fn has_dynamic_metadata(&self) -> bool {
        match self.override_specifier {
            ::std::option::Option::Some(RateLimit_Override_oneof_override_specifier::dynamic_metadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dynamic_metadata(&mut self, v: RateLimit_Override_DynamicMetadata) {
        self.override_specifier = ::std::option::Option::Some(RateLimit_Override_oneof_override_specifier::dynamic_metadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dynamic_metadata(&mut self) -> &mut RateLimit_Override_DynamicMetadata {
        if let ::std::option::Option::Some(RateLimit_Override_oneof_override_specifier::dynamic_metadata(_)) = self.override_specifier {
        } else {
            self.override_specifier = ::std::option::Option::Some(RateLimit_Override_oneof_override_specifier::dynamic_metadata(RateLimit_Override_DynamicMetadata::new()));
        }
        match self.override_specifier {
            ::std::option::Option::Some(RateLimit_Override_oneof_override_specifier::dynamic_metadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dynamic_metadata(&mut self) -> RateLimit_Override_DynamicMetadata {
        if self.has_dynamic_metadata() {
            match self.override_specifier.take() {
                ::std::option::Option::Some(RateLimit_Override_oneof_override_specifier::dynamic_metadata(v)) => v,
                _ => panic!(),
            }
        } else {
            RateLimit_Override_DynamicMetadata::new()
        }
    }
}

impl ::protobuf::Message for RateLimit_Override {
    fn is_initialized(&self) -> bool {
        if let Some(RateLimit_Override_oneof_override_specifier::dynamic_metadata(ref v)) = self.override_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.override_specifier = ::std::option::Option::Some(RateLimit_Override_oneof_override_specifier::dynamic_metadata(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.override_specifier {
            match v {
                &RateLimit_Override_oneof_override_specifier::dynamic_metadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.override_specifier {
            match v {
                &RateLimit_Override_oneof_override_specifier::dynamic_metadata(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Override {
        RateLimit_Override::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RateLimit_Override_DynamicMetadata>(
                "dynamic_metadata",
                RateLimit_Override::has_dynamic_metadata,
                RateLimit_Override::get_dynamic_metadata,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Override>(
                "RateLimit.Override",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Override {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Override> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Override::new)
    }
}

impl ::protobuf::Clear for RateLimit_Override {
    fn clear(&mut self) {
        self.override_specifier = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Override {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Override {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RateLimit_Override_DynamicMetadata {
    // message fields
    pub metadata_key: ::protobuf::SingularPtrField<super::metadata::MetadataKey>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Override_DynamicMetadata {
    fn default() -> &'a RateLimit_Override_DynamicMetadata {
        <RateLimit_Override_DynamicMetadata as ::protobuf::Message>::default_instance()
    }
}

impl RateLimit_Override_DynamicMetadata {
    pub fn new() -> RateLimit_Override_DynamicMetadata {
        ::std::default::Default::default()
    }

    // .envoy.type.metadata.v3.MetadataKey metadata_key = 1;


    pub fn get_metadata_key(&self) -> &super::metadata::MetadataKey {
        self.metadata_key.as_ref().unwrap_or_else(|| <super::metadata::MetadataKey as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata_key(&mut self) {
        self.metadata_key.clear();
    }

    pub fn has_metadata_key(&self) -> bool {
        self.metadata_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata_key(&mut self, v: super::metadata::MetadataKey) {
        self.metadata_key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata_key(&mut self) -> &mut super::metadata::MetadataKey {
        if self.metadata_key.is_none() {
            self.metadata_key.set_default();
        }
        self.metadata_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata_key(&mut self) -> super::metadata::MetadataKey {
        self.metadata_key.take().unwrap_or_else(|| super::metadata::MetadataKey::new())
    }
}

impl ::protobuf::Message for RateLimit_Override_DynamicMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata_key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata_key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Override_DynamicMetadata {
        RateLimit_Override_DynamicMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::metadata::MetadataKey>>(
                "metadata_key",
                |m: &RateLimit_Override_DynamicMetadata| { &m.metadata_key },
                |m: &mut RateLimit_Override_DynamicMetadata| { &mut m.metadata_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Override_DynamicMetadata>(
                "RateLimit.Override.DynamicMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Override_DynamicMetadata {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Override_DynamicMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Override_DynamicMetadata::new)
    }
}

impl ::protobuf::Clear for RateLimit_Override_DynamicMetadata {
    fn clear(&mut self) {
        self.metadata_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Override_DynamicMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Override_DynamicMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct HeaderMatcher {
    // message fields
    pub name: ::std::string::String,
    pub invert_match: bool,
    // message oneof groups
    pub header_match_specifier: ::std::option::Option<HeaderMatcher_oneof_header_match_specifier>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeaderMatcher {
    fn default() -> &'a HeaderMatcher {
        <HeaderMatcher as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum HeaderMatcher_oneof_header_match_specifier {
    exact_match(::std::string::String),
    safe_regex_match(super::regex::RegexMatcher),
    range_match(super::range::Int64Range),
    present_match(bool),
    prefix_match(::std::string::String),
    suffix_match(::std::string::String),
    contains_match(::std::string::String),
    string_match(super::string::StringMatcher),
}

impl HeaderMatcher {
    pub fn new() -> HeaderMatcher {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string exact_match = 4;


    pub fn get_exact_match(&self) -> &str {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::exact_match(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_exact_match(&mut self) {
        self.header_match_specifier = ::std::option::Option::None;
    }

    pub fn has_exact_match(&self) -> bool {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::exact_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exact_match(&mut self, v: ::std::string::String) {
        self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::exact_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exact_match(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::exact_match(_)) = self.header_match_specifier {
        } else {
            self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::exact_match(::std::string::String::new()));
        }
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::exact_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exact_match(&mut self) -> ::std::string::String {
        if self.has_exact_match() {
            match self.header_match_specifier.take() {
                ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::exact_match(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .envoy.type.matcher.v3.RegexMatcher safe_regex_match = 11;


    pub fn get_safe_regex_match(&self) -> &super::regex::RegexMatcher {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(ref v)) => v,
            _ => <super::regex::RegexMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_safe_regex_match(&mut self) {
        self.header_match_specifier = ::std::option::Option::None;
    }

    pub fn has_safe_regex_match(&self) -> bool {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_safe_regex_match(&mut self, v: super::regex::RegexMatcher) {
        self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_safe_regex_match(&mut self) -> &mut super::regex::RegexMatcher {
        if let ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(_)) = self.header_match_specifier {
        } else {
            self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(super::regex::RegexMatcher::new()));
        }
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_safe_regex_match(&mut self) -> super::regex::RegexMatcher {
        if self.has_safe_regex_match() {
            match self.header_match_specifier.take() {
                ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(v)) => v,
                _ => panic!(),
            }
        } else {
            super::regex::RegexMatcher::new()
        }
    }

    // .envoy.type.v3.Int64Range range_match = 6;


    pub fn get_range_match(&self) -> &super::range::Int64Range {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::range_match(ref v)) => v,
            _ => <super::range::Int64Range as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_range_match(&mut self) {
        self.header_match_specifier = ::std::option::Option::None;
    }

    pub fn has_range_match(&self) -> bool {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::range_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_range_match(&mut self, v: super::range::Int64Range) {
        self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::range_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_range_match(&mut self) -> &mut super::range::Int64Range {
        if let ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::range_match(_)) = self.header_match_specifier {
        } else {
            self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::range_match(super::range::Int64Range::new()));
        }
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::range_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_range_match(&mut self) -> super::range::Int64Range {
        if self.has_range_match() {
            match self.header_match_specifier.take() {
                ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::range_match(v)) => v,
                _ => panic!(),
            }
        } else {
            super::range::Int64Range::new()
        }
    }

    // bool present_match = 7;


    pub fn get_present_match(&self) -> bool {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::present_match(v)) => v,
            _ => false,
        }
    }
    pub fn clear_present_match(&mut self) {
        self.header_match_specifier = ::std::option::Option::None;
    }

    pub fn has_present_match(&self) -> bool {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::present_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_present_match(&mut self, v: bool) {
        self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::present_match(v))
    }

    // string prefix_match = 9;


    pub fn get_prefix_match(&self) -> &str {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::prefix_match(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_prefix_match(&mut self) {
        self.header_match_specifier = ::std::option::Option::None;
    }

    pub fn has_prefix_match(&self) -> bool {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::prefix_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_prefix_match(&mut self, v: ::std::string::String) {
        self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::prefix_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_prefix_match(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::prefix_match(_)) = self.header_match_specifier {
        } else {
            self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::prefix_match(::std::string::String::new()));
        }
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::prefix_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_prefix_match(&mut self) -> ::std::string::String {
        if self.has_prefix_match() {
            match self.header_match_specifier.take() {
                ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::prefix_match(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string suffix_match = 10;


    pub fn get_suffix_match(&self) -> &str {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::suffix_match(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_suffix_match(&mut self) {
        self.header_match_specifier = ::std::option::Option::None;
    }

    pub fn has_suffix_match(&self) -> bool {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::suffix_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_suffix_match(&mut self, v: ::std::string::String) {
        self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::suffix_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_suffix_match(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::suffix_match(_)) = self.header_match_specifier {
        } else {
            self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::suffix_match(::std::string::String::new()));
        }
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::suffix_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_suffix_match(&mut self) -> ::std::string::String {
        if self.has_suffix_match() {
            match self.header_match_specifier.take() {
                ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::suffix_match(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string contains_match = 12;


    pub fn get_contains_match(&self) -> &str {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::contains_match(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_contains_match(&mut self) {
        self.header_match_specifier = ::std::option::Option::None;
    }

    pub fn has_contains_match(&self) -> bool {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::contains_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contains_match(&mut self, v: ::std::string::String) {
        self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::contains_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contains_match(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::contains_match(_)) = self.header_match_specifier {
        } else {
            self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::contains_match(::std::string::String::new()));
        }
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::contains_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contains_match(&mut self) -> ::std::string::String {
        if self.has_contains_match() {
            match self.header_match_specifier.take() {
                ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::contains_match(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .envoy.type.matcher.v3.StringMatcher string_match = 13;


    pub fn get_string_match(&self) -> &super::string::StringMatcher {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::string_match(ref v)) => v,
            _ => <super::string::StringMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_string_match(&mut self) {
        self.header_match_specifier = ::std::option::Option::None;
    }

    pub fn has_string_match(&self) -> bool {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::string_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_match(&mut self, v: super::string::StringMatcher) {
        self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::string_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_match(&mut self) -> &mut super::string::StringMatcher {
        if let ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::string_match(_)) = self.header_match_specifier {
        } else {
            self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::string_match(super::string::StringMatcher::new()));
        }
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::string_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_match(&mut self) -> super::string::StringMatcher {
        if self.has_string_match() {
            match self.header_match_specifier.take() {
                ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::string_match(v)) => v,
                _ => panic!(),
            }
        } else {
            super::string::StringMatcher::new()
        }
    }

    // bool invert_match = 8;


    pub fn get_invert_match(&self) -> bool {
        self.invert_match
    }
    pub fn clear_invert_match(&mut self) {
        self.invert_match = false;
    }

    // Param is passed by value, moved
    pub fn set_invert_match(&mut self, v: bool) {
        self.invert_match = v;
    }
}

impl ::protobuf::Message for HeaderMatcher {
    fn is_initialized(&self) -> bool {
        if let Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(ref v)) = self.header_match_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HeaderMatcher_oneof_header_match_specifier::range_match(ref v)) = self.header_match_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HeaderMatcher_oneof_header_match_specifier::string_match(ref v)) = self.header_match_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::exact_match(is.read_string()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::range_match(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::present_match(is.read_bool()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::prefix_match(is.read_string()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::suffix_match(is.read_string()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::contains_match(is.read_string()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::string_match(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.invert_match = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.invert_match != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.header_match_specifier {
            match v {
                &HeaderMatcher_oneof_header_match_specifier::exact_match(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
                &HeaderMatcher_oneof_header_match_specifier::safe_regex_match(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HeaderMatcher_oneof_header_match_specifier::range_match(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HeaderMatcher_oneof_header_match_specifier::present_match(v) => {
                    my_size += 2;
                },
                &HeaderMatcher_oneof_header_match_specifier::prefix_match(ref v) => {
                    my_size += ::protobuf::rt::string_size(9, &v);
                },
                &HeaderMatcher_oneof_header_match_specifier::suffix_match(ref v) => {
                    my_size += ::protobuf::rt::string_size(10, &v);
                },
                &HeaderMatcher_oneof_header_match_specifier::contains_match(ref v) => {
                    my_size += ::protobuf::rt::string_size(12, &v);
                },
                &HeaderMatcher_oneof_header_match_specifier::string_match(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.invert_match != false {
            os.write_bool(8, self.invert_match)?;
        }
        if let ::std::option::Option::Some(ref v) = self.header_match_specifier {
            match v {
                &HeaderMatcher_oneof_header_match_specifier::exact_match(ref v) => {
                    os.write_string(4, v)?;
                },
                &HeaderMatcher_oneof_header_match_specifier::safe_regex_match(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HeaderMatcher_oneof_header_match_specifier::range_match(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HeaderMatcher_oneof_header_match_specifier::present_match(v) => {
                    os.write_bool(7, v)?;
                },
                &HeaderMatcher_oneof_header_match_specifier::prefix_match(ref v) => {
                    os.write_string(9, v)?;
                },
                &HeaderMatcher_oneof_header_match_specifier::suffix_match(ref v) => {
                    os.write_string(10, v)?;
                },
                &HeaderMatcher_oneof_header_match_specifier::contains_match(ref v) => {
                    os.write_string(12, v)?;
                },
                &HeaderMatcher_oneof_header_match_specifier::string_match(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeaderMatcher {
        HeaderMatcher::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &HeaderMatcher| { &m.name },
                |m: &mut HeaderMatcher| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "exact_match",
                HeaderMatcher::has_exact_match,
                HeaderMatcher::get_exact_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::regex::RegexMatcher>(
                "safe_regex_match",
                HeaderMatcher::has_safe_regex_match,
                HeaderMatcher::get_safe_regex_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::range::Int64Range>(
                "range_match",
                HeaderMatcher::has_range_match,
                HeaderMatcher::get_range_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "present_match",
                HeaderMatcher::has_present_match,
                HeaderMatcher::get_present_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "prefix_match",
                HeaderMatcher::has_prefix_match,
                HeaderMatcher::get_prefix_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "suffix_match",
                HeaderMatcher::has_suffix_match,
                HeaderMatcher::get_suffix_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "contains_match",
                HeaderMatcher::has_contains_match,
                HeaderMatcher::get_contains_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::string::StringMatcher>(
                "string_match",
                HeaderMatcher::has_string_match,
                HeaderMatcher::get_string_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "invert_match",
                |m: &HeaderMatcher| { &m.invert_match },
                |m: &mut HeaderMatcher| { &mut m.invert_match },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeaderMatcher>(
                "HeaderMatcher",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeaderMatcher {
        static instance: ::protobuf::rt::LazyV2<HeaderMatcher> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeaderMatcher::new)
    }
}

impl ::protobuf::Clear for HeaderMatcher {
    fn clear(&mut self) {
        self.name.clear();
        self.header_match_specifier = ::std::option::Option::None;
        self.header_match_specifier = ::std::option::Option::None;
        self.header_match_specifier = ::std::option::Option::None;
        self.header_match_specifier = ::std::option::Option::None;
        self.header_match_specifier = ::std::option::Option::None;
        self.header_match_specifier = ::std::option::Option::None;
        self.header_match_specifier = ::std::option::Option::None;
        self.header_match_specifier = ::std::option::Option::None;
        self.invert_match = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeaderMatcher {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeaderMatcher {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct QueryParameterMatcher {
    // message fields
    pub name: ::std::string::String,
    // message oneof groups
    pub query_parameter_match_specifier: ::std::option::Option<QueryParameterMatcher_oneof_query_parameter_match_specifier>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryParameterMatcher {
    fn default() -> &'a QueryParameterMatcher {
        <QueryParameterMatcher as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum QueryParameterMatcher_oneof_query_parameter_match_specifier {
    string_match(super::string::StringMatcher),
    present_match(bool),
}

impl QueryParameterMatcher {
    pub fn new() -> QueryParameterMatcher {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .envoy.type.matcher.v3.StringMatcher string_match = 5;


    pub fn get_string_match(&self) -> &super::string::StringMatcher {
        match self.query_parameter_match_specifier {
            ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(ref v)) => v,
            _ => <super::string::StringMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_string_match(&mut self) {
        self.query_parameter_match_specifier = ::std::option::Option::None;
    }

    pub fn has_string_match(&self) -> bool {
        match self.query_parameter_match_specifier {
            ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_match(&mut self, v: super::string::StringMatcher) {
        self.query_parameter_match_specifier = ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_match(&mut self) -> &mut super::string::StringMatcher {
        if let ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(_)) = self.query_parameter_match_specifier {
        } else {
            self.query_parameter_match_specifier = ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(super::string::StringMatcher::new()));
        }
        match self.query_parameter_match_specifier {
            ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_match(&mut self) -> super::string::StringMatcher {
        if self.has_string_match() {
            match self.query_parameter_match_specifier.take() {
                ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(v)) => v,
                _ => panic!(),
            }
        } else {
            super::string::StringMatcher::new()
        }
    }

    // bool present_match = 6;


    pub fn get_present_match(&self) -> bool {
        match self.query_parameter_match_specifier {
            ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::present_match(v)) => v,
            _ => false,
        }
    }
    pub fn clear_present_match(&mut self) {
        self.query_parameter_match_specifier = ::std::option::Option::None;
    }

    pub fn has_present_match(&self) -> bool {
        match self.query_parameter_match_specifier {
            ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::present_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_present_match(&mut self, v: bool) {
        self.query_parameter_match_specifier = ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::present_match(v))
    }
}

impl ::protobuf::Message for QueryParameterMatcher {
    fn is_initialized(&self) -> bool {
        if let Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(ref v)) = self.query_parameter_match_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query_parameter_match_specifier = ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query_parameter_match_specifier = ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::present_match(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.query_parameter_match_specifier {
            match v {
                &QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryParameterMatcher_oneof_query_parameter_match_specifier::present_match(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.query_parameter_match_specifier {
            match v {
                &QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryParameterMatcher_oneof_query_parameter_match_specifier::present_match(v) => {
                    os.write_bool(6, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryParameterMatcher {
        QueryParameterMatcher::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &QueryParameterMatcher| { &m.name },
                |m: &mut QueryParameterMatcher| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::string::StringMatcher>(
                "string_match",
                QueryParameterMatcher::has_string_match,
                QueryParameterMatcher::get_string_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "present_match",
                QueryParameterMatcher::has_present_match,
                QueryParameterMatcher::get_present_match,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryParameterMatcher>(
                "QueryParameterMatcher",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryParameterMatcher {
        static instance: ::protobuf::rt::LazyV2<QueryParameterMatcher> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryParameterMatcher::new)
    }
}

impl ::protobuf::Clear for QueryParameterMatcher {
    fn clear(&mut self) {
        self.name.clear();
        self.query_parameter_match_specifier = ::std::option::Option::None;
        self.query_parameter_match_specifier = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryParameterMatcher {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryParameterMatcher {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct InternalRedirectPolicy {
    // message fields
    pub max_internal_redirects: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub redirect_response_codes: ::std::vec::Vec<u32>,
    pub predicates: ::protobuf::RepeatedField<super::extension::TypedExtensionConfig>,
    pub allow_cross_scheme_redirect: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InternalRedirectPolicy {
    fn default() -> &'a InternalRedirectPolicy {
        <InternalRedirectPolicy as ::protobuf::Message>::default_instance()
    }
}

impl InternalRedirectPolicy {
    pub fn new() -> InternalRedirectPolicy {
        ::std::default::Default::default()
    }

    // .google.protobuf.UInt32Value max_internal_redirects = 1;


    pub fn get_max_internal_redirects(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.max_internal_redirects.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_max_internal_redirects(&mut self) {
        self.max_internal_redirects.clear();
    }

    pub fn has_max_internal_redirects(&self) -> bool {
        self.max_internal_redirects.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_internal_redirects(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.max_internal_redirects = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_internal_redirects(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.max_internal_redirects.is_none() {
            self.max_internal_redirects.set_default();
        }
        self.max_internal_redirects.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_internal_redirects(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.max_internal_redirects.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // repeated uint32 redirect_response_codes = 2;


    pub fn get_redirect_response_codes(&self) -> &[u32] {
        &self.redirect_response_codes
    }
    pub fn clear_redirect_response_codes(&mut self) {
        self.redirect_response_codes.clear();
    }

    // Param is passed by value, moved
    pub fn set_redirect_response_codes(&mut self, v: ::std::vec::Vec<u32>) {
        self.redirect_response_codes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_redirect_response_codes(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.redirect_response_codes
    }

    // Take field
    pub fn take_redirect_response_codes(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.redirect_response_codes, ::std::vec::Vec::new())
    }

    // repeated .envoy.config.core.v3.TypedExtensionConfig predicates = 3;


    pub fn get_predicates(&self) -> &[super::extension::TypedExtensionConfig] {
        &self.predicates
    }
    pub fn clear_predicates(&mut self) {
        self.predicates.clear();
    }

    // Param is passed by value, moved
    pub fn set_predicates(&mut self, v: ::protobuf::RepeatedField<super::extension::TypedExtensionConfig>) {
        self.predicates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_predicates(&mut self) -> &mut ::protobuf::RepeatedField<super::extension::TypedExtensionConfig> {
        &mut self.predicates
    }

    // Take field
    pub fn take_predicates(&mut self) -> ::protobuf::RepeatedField<super::extension::TypedExtensionConfig> {
        ::std::mem::replace(&mut self.predicates, ::protobuf::RepeatedField::new())
    }

    // bool allow_cross_scheme_redirect = 4;


    pub fn get_allow_cross_scheme_redirect(&self) -> bool {
        self.allow_cross_scheme_redirect
    }
    pub fn clear_allow_cross_scheme_redirect(&mut self) {
        self.allow_cross_scheme_redirect = false;
    }

    // Param is passed by value, moved
    pub fn set_allow_cross_scheme_redirect(&mut self, v: bool) {
        self.allow_cross_scheme_redirect = v;
    }
}

impl ::protobuf::Message for InternalRedirectPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.max_internal_redirects {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.predicates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_internal_redirects)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.redirect_response_codes)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.predicates)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_cross_scheme_redirect = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.max_internal_redirects.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.redirect_response_codes {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.predicates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.allow_cross_scheme_redirect != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.max_internal_redirects.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.redirect_response_codes {
            os.write_uint32(2, *v)?;
        };
        for v in &self.predicates {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.allow_cross_scheme_redirect != false {
            os.write_bool(4, self.allow_cross_scheme_redirect)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InternalRedirectPolicy {
        InternalRedirectPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "max_internal_redirects",
                |m: &InternalRedirectPolicy| { &m.max_internal_redirects },
                |m: &mut InternalRedirectPolicy| { &mut m.max_internal_redirects },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "redirect_response_codes",
                |m: &InternalRedirectPolicy| { &m.redirect_response_codes },
                |m: &mut InternalRedirectPolicy| { &mut m.redirect_response_codes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::extension::TypedExtensionConfig>>(
                "predicates",
                |m: &InternalRedirectPolicy| { &m.predicates },
                |m: &mut InternalRedirectPolicy| { &mut m.predicates },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_cross_scheme_redirect",
                |m: &InternalRedirectPolicy| { &m.allow_cross_scheme_redirect },
                |m: &mut InternalRedirectPolicy| { &mut m.allow_cross_scheme_redirect },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InternalRedirectPolicy>(
                "InternalRedirectPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InternalRedirectPolicy {
        static instance: ::protobuf::rt::LazyV2<InternalRedirectPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InternalRedirectPolicy::new)
    }
}

impl ::protobuf::Clear for InternalRedirectPolicy {
    fn clear(&mut self) {
        self.max_internal_redirects.clear();
        self.redirect_response_codes.clear();
        self.predicates.clear();
        self.allow_cross_scheme_redirect = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InternalRedirectPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InternalRedirectPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct FilterConfig {
    // message fields
    pub config: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub is_optional: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilterConfig {
    fn default() -> &'a FilterConfig {
        <FilterConfig as ::protobuf::Message>::default_instance()
    }
}

impl FilterConfig {
    pub fn new() -> FilterConfig {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any config = 1;


    pub fn get_config(&self) -> &::protobuf::well_known_types::Any {
        self.config.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> ::protobuf::well_known_types::Any {
        self.config.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // bool is_optional = 2;


    pub fn get_is_optional(&self) -> bool {
        self.is_optional
    }
    pub fn clear_is_optional(&mut self) {
        self.is_optional = false;
    }

    // Param is passed by value, moved
    pub fn set_is_optional(&mut self, v: bool) {
        self.is_optional = v;
    }
}

impl ::protobuf::Message for FilterConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_optional = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_optional != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_optional != false {
            os.write_bool(2, self.is_optional)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilterConfig {
        FilterConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "config",
                |m: &FilterConfig| { &m.config },
                |m: &mut FilterConfig| { &mut m.config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_optional",
                |m: &FilterConfig| { &m.is_optional },
                |m: &mut FilterConfig| { &mut m.is_optional },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FilterConfig>(
                "FilterConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FilterConfig {
        static instance: ::protobuf::rt::LazyV2<FilterConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FilterConfig::new)
    }
}

impl ::protobuf::Clear for FilterConfig {
    fn clear(&mut self) {
        self.config.clear();
        self.is_optional = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilterConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilterConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n,envoy/config/route/v3/route_components.proto\x12\x15envoy.config.rout\
    e.v3\x1a\x1fenvoy/config/core/v3/base.proto\x1a$envoy/config/core/v3/ext\
    ension.proto\x1a)envoy/config/core/v3/proxy_protocol.proto\x1a$envoy/typ\
    e/matcher/v3/metadata.proto\x1a!envoy/type/matcher/v3/regex.proto\x1a\"e\
    nvoy/type/matcher/v3/string.proto\x1a%envoy/type/metadata/v3/metadata.pr\
    oto\x1a&envoy/type/tracing/v3/custom_tag.proto\x1a\x1benvoy/type/v3/perc\
    ent.proto\x1a\x19envoy/type/v3/range.proto\x1a\x19google/protobuf/any.pr\
    oto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1egoogle/protobuf/wrapper\
    s.proto\x1a\x1fxds/annotations/v3/status.proto\x1a!xds/type/matcher/v3/m\
    atcher.proto\x1a#envoy/annotations/deprecation.proto\x1a\x1eudpa/annotat\
    ions/migrate.proto\x1a\x1dudpa/annotations/status.proto\x1a!udpa/annotat\
    ions/versioning.proto\x1a\x17validate/validate.proto\"\x96\r\n\x0bVirtua\
    lHost\x12\x1b\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x07\xfaB\x04r\x02\
    \x10\x01\x12,\n\x07domains\x18\x02\x20\x03(\tR\x07domainsB\x12\xfaB\x0f\
    \x92\x01\x0c\x08\x01\"\x08r\x06\xc0\x01\x02\xc8\x01\0\x124\n\x06routes\
    \x18\x03\x20\x03(\x0b2\x1c.envoy.config.route.v3.RouteR\x06routes\x12@\n\
    \x07matcher\x18\x15\x20\x01(\x0b2\x1c.xds.type.matcher.v3.MatcherR\x07ma\
    tcherB\x08\xd2\xc6\xa4\xe1\x06\x02\x08\x01\x12`\n\x0brequire_tls\x18\x04\
    \x20\x01(\x0e25.envoy.config.route.v3.VirtualHost.TlsRequirementTypeR\nr\
    equireTlsB\x08\xfaB\x05\x82\x01\x02\x10\x01\x12P\n\x10virtual_clusters\
    \x18\x05\x20\x03(\x0b2%.envoy.config.route.v3.VirtualClusterR\x0fvirtual\
    Clusters\x12A\n\x0brate_limits\x18\x06\x20\x03(\x0b2\x20.envoy.config.ro\
    ute.v3.RateLimitR\nrateLimits\x12g\n\x16request_headers_to_add\x18\x07\
    \x20\x03(\x0b2'.envoy.config.core.v3.HeaderValueOptionR\x13requestHeader\
    sToAddB\t\xfaB\x06\x92\x01\x03\x10\xe8\x07\x12M\n\x19request_headers_to_\
    remove\x18\r\x20\x03(\tR\x16requestHeadersToRemoveB\x12\xfaB\x0f\x92\x01\
    \x0c\"\nr\x08\x10\x01\xc0\x01\x01\xc8\x01\0\x12i\n\x17response_headers_t\
    o_add\x18\n\x20\x03(\x0b2'.envoy.config.core.v3.HeaderValueOptionR\x14re\
    sponseHeadersToAddB\t\xfaB\x06\x92\x01\x03\x10\xe8\x07\x12O\n\x1arespons\
    e_headers_to_remove\x18\x0b\x20\x03(\tR\x17responseHeadersToRemoveB\x12\
    \xfaB\x0f\x92\x01\x0c\"\nr\x08\x10\x01\xc0\x01\x01\xc8\x01\0\x125\n\x04c\
    ors\x18\x08\x20\x01(\x0b2!.envoy.config.route.v3.CorsPolicyR\x04cors\x12\
    s\n\x17typed_per_filter_config\x18\x0f\x20\x03(\x0b2<.envoy.config.route\
    .v3.VirtualHost.TypedPerFilterConfigEntryR\x14typedPerFilterConfig\x12A\
    \n\x1dinclude_request_attempt_count\x18\x0e\x20\x01(\x08R\x1aincludeRequ\
    estAttemptCount\x12H\n!include_attempt_count_in_response\x18\x13\x20\x01\
    (\x08R\x1dincludeAttemptCountInResponse\x12E\n\x0cretry_policy\x18\x10\
    \x20\x01(\x0b2\".envoy.config.route.v3.RetryPolicyR\x0bretryPolicy\x12O\
    \n\x19retry_policy_typed_config\x18\x14\x20\x01(\x0b2\x14.google.protobu\
    f.AnyR\x16retryPolicyTypedConfig\x12E\n\x0chedge_policy\x18\x11\x20\x01(\
    \x0b2\".envoy.config.route.v3.HedgePolicyR\x0bhedgePolicy\x12`\n\x1eper_\
    request_buffer_limit_bytes\x18\x12\x20\x01(\x0b2\x1c.google.protobuf.UIn\
    t32ValueR\x1aperRequestBufferLimitBytes\x1a]\n\x19TypedPerFilterConfigEn\
    try\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12*\n\x05value\x18\x02\
    \x20\x01(\x0b2\x14.google.protobuf.AnyR\x05value:\x028\x01\":\n\x12TlsRe\
    quirementType\x12\x08\n\x04NONE\x10\0\x12\x11\n\rEXTERNAL_ONLY\x10\x01\
    \x12\x07\n\x03ALL\x10\x02:%\x9a\xc5\x88\x1e\x20\n\x1eenvoy.api.v2.route.\
    VirtualHostJ\x04\x08\t\x10\nJ\x04\x08\x0c\x10\rR\x11per_filter_config\"d\
    \n\x0cFilterAction\x12,\n\x06action\x18\x01\x20\x01(\x0b2\x14.google.pro\
    tobuf.AnyR\x06action:&\x9a\xc5\x88\x1e!\n\x1fenvoy.api.v2.route.FilterAc\
    tion\"\x8e\x0b\n\x05Route\x12\x12\n\x04name\x18\x0e\x20\x01(\tR\x04name\
    \x12A\n\x05match\x18\x01\x20\x01(\x0b2!.envoy.config.route.v3.RouteMatch\
    R\x05matchB\x08\xfaB\x05\x8a\x01\x02\x10\x01\x12:\n\x05route\x18\x02\x20\
    \x01(\x0b2\".envoy.config.route.v3.RouteActionH\0R\x05route\x12C\n\x08re\
    direct\x18\x03\x20\x01(\x0b2%.envoy.config.route.v3.RedirectActionH\0R\
    \x08redirect\x12V\n\x0fdirect_response\x18\x07\x20\x01(\x0b2+.envoy.conf\
    ig.route.v3.DirectResponseActionH\0R\x0edirectResponse\x12J\n\rfilter_ac\
    tion\x18\x11\x20\x01(\x0b2#.envoy.config.route.v3.FilterActionH\0R\x0cfi\
    lterAction\x12`\n\x15non_forwarding_action\x18\x12\x20\x01(\x0b2*.envoy.\
    config.route.v3.NonForwardingActionH\0R\x13nonForwardingAction\x12:\n\
    \x08metadata\x18\x04\x20\x01(\x0b2\x1e.envoy.config.core.v3.MetadataR\
    \x08metadata\x12>\n\tdecorator\x18\x05\x20\x01(\x0b2\x20.envoy.config.ro\
    ute.v3.DecoratorR\tdecorator\x12m\n\x17typed_per_filter_config\x18\r\x20\
    \x03(\x0b26.envoy.config.route.v3.Route.TypedPerFilterConfigEntryR\x14ty\
    pedPerFilterConfig\x12g\n\x16request_headers_to_add\x18\t\x20\x03(\x0b2'\
    .envoy.config.core.v3.HeaderValueOptionR\x13requestHeadersToAddB\t\xfaB\
    \x06\x92\x01\x03\x10\xe8\x07\x12M\n\x19request_headers_to_remove\x18\x0c\
    \x20\x03(\tR\x16requestHeadersToRemoveB\x12\xfaB\x0f\x92\x01\x0c\"\nr\
    \x08\x10\x01\xc0\x01\x01\xc8\x01\0\x12i\n\x17response_headers_to_add\x18\
    \n\x20\x03(\x0b2'.envoy.config.core.v3.HeaderValueOptionR\x14responseHea\
    dersToAddB\t\xfaB\x06\x92\x01\x03\x10\xe8\x07\x12O\n\x1aresponse_headers\
    _to_remove\x18\x0b\x20\x03(\tR\x17responseHeadersToRemoveB\x12\xfaB\x0f\
    \x92\x01\x0c\"\nr\x08\x10\x01\xc0\x01\x01\xc8\x01\0\x128\n\x07tracing\
    \x18\x0f\x20\x01(\x0b2\x1e.envoy.config.route.v3.TracingR\x07tracing\x12\
    `\n\x1eper_request_buffer_limit_bytes\x18\x10\x20\x01(\x0b2\x1c.google.p\
    rotobuf.UInt32ValueR\x1aperRequestBufferLimitBytes\x1a]\n\x19TypedPerFil\
    terConfigEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12*\n\x05val\
    ue\x18\x02\x20\x01(\x0b2\x14.google.protobuf.AnyR\x05value:\x028\x01B\r\
    \n\x06action\x12\x03\xf8B\x01:\x1f\x9a\xc5\x88\x1e\x1a\n\x18envoy.api.v2\
    .route.RouteJ\x04\x08\x06\x10\x07J\x04\x08\x08\x10\tR\x11per_filter_conf\
    ig\"\xa5\n\n\x0fWeightedCluster\x12Z\n\x08clusters\x18\x01\x20\x03(\x0b2\
    4.envoy.config.route.v3.WeightedCluster.ClusterWeightR\x08clustersB\x08\
    \xfaB\x05\x92\x01\x02\x08\x01\x12H\n\x0ctotal_weight\x18\x03\x20\x01(\
    \x0b2\x1c.google.protobuf.UInt32ValueR\x0btotalWeightB\x07\xfaB\x04*\x02\
    (\x01\x12,\n\x12runtime_key_prefix\x18\x02\x20\x01(\tR\x10runtimeKeyPref\
    ix\x1a\x92\x08\n\rClusterWeight\x12-\n\x04name\x18\x01\x20\x01(\tR\x04na\
    meB\x19\xf2\x98\xfe\x8f\x05\x13\x12\x11cluster_specifier\x12K\n\x0eclust\
    er_header\x18\x0c\x20\x01(\tR\rclusterHeaderB$\xfaB\x08r\x06\xc0\x01\x01\
    \xc8\x01\0\xf2\x98\xfe\x8f\x05\x13\x12\x11cluster_specifier\x124\n\x06we\
    ight\x18\x02\x20\x01(\x0b2\x1c.google.protobuf.UInt32ValueR\x06weight\
    \x12E\n\x0emetadata_match\x18\x03\x20\x01(\x0b2\x1e.envoy.config.core.v3\
    .MetadataR\rmetadataMatch\x12g\n\x16request_headers_to_add\x18\x04\x20\
    \x03(\x0b2'.envoy.config.core.v3.HeaderValueOptionR\x13requestHeadersToA\
    ddB\t\xfaB\x06\x92\x01\x03\x10\xe8\x07\x12K\n\x19request_headers_to_remo\
    ve\x18\t\x20\x03(\tR\x16requestHeadersToRemoveB\x10\xfaB\r\x92\x01\n\"\
    \x08r\x06\xc0\x01\x01\xc8\x01\0\x12i\n\x17response_headers_to_add\x18\
    \x05\x20\x03(\x0b2'.envoy.config.core.v3.HeaderValueOptionR\x14responseH\
    eadersToAddB\t\xfaB\x06\x92\x01\x03\x10\xe8\x07\x12M\n\x1aresponse_heade\
    rs_to_remove\x18\x06\x20\x03(\tR\x17responseHeadersToRemoveB\x10\xfaB\r\
    \x92\x01\n\"\x08r\x06\xc0\x01\x01\xc8\x01\0\x12\x85\x01\n\x17typed_per_f\
    ilter_config\x18\n\x20\x03(\x0b2N.envoy.config.route.v3.WeightedCluster.\
    ClusterWeight.TypedPerFilterConfigEntryR\x14typedPerFilterConfig\x12?\n\
    \x14host_rewrite_literal\x18\x0b\x20\x01(\tH\0R\x12hostRewriteLiteralB\
    \x0b\xfaB\x08r\x06\xc0\x01\x02\xc8\x01\0\x1a]\n\x19TypedPerFilterConfigE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12*\n\x05value\x18\x02\
    \x20\x01(\x0b2\x14.google.protobuf.AnyR\x05value:\x028\x01B\x18\n\x16hos\
    t_rewrite_specifier:7\x9a\xc5\x88\x1e2\n0envoy.api.v2.route.WeightedClus\
    ter.ClusterWeightJ\x04\x08\x07\x10\x08J\x04\x08\x08\x10\tR\x11per_filter\
    _config:)\x9a\xc5\x88\x1e$\n\"envoy.api.v2.route.WeightedCluster\"\x9e\t\
    \n\nRouteMatch\x12\x18\n\x06prefix\x18\x01\x20\x01(\tH\0R\x06prefix\x12\
    \x14\n\x04path\x18\x02\x20\x01(\tH\0R\x04path\x12N\n\nsafe_regex\x18\n\
    \x20\x01(\x0b2#.envoy.type.matcher.v3.RegexMatcherH\0R\tsafeRegexB\x08\
    \xfaB\x05\x8a\x01\x02\x10\x01\x12[\n\x0fconnect_matcher\x18\x0c\x20\x01(\
    \x0b20.envoy.config.route.v3.RouteMatch.ConnectMatcherH\0R\x0econnectMat\
    cher\x12A\n\x0ecase_sensitive\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.\
    BoolValueR\rcaseSensitive\x12Y\n\x10runtime_fraction\x18\t\x20\x01(\x0b2\
    ..envoy.config.core.v3.RuntimeFractionalPercentR\x0fruntimeFraction\x12>\
    \n\x07headers\x18\x06\x20\x03(\x0b2$.envoy.config.route.v3.HeaderMatcher\
    R\x07headers\x12W\n\x10query_parameters\x18\x07\x20\x03(\x0b2,.envoy.con\
    fig.route.v3.QueryParameterMatcherR\x0fqueryParameters\x12K\n\x04grpc\
    \x18\x08\x20\x01(\x0b27.envoy.config.route.v3.RouteMatch.GrpcRouteMatchO\
    ptionsR\x04grpc\x12Y\n\x0btls_context\x18\x0b\x20\x01(\x0b28.envoy.confi\
    g.route.v3.RouteMatch.TlsContextMatchOptionsR\ntlsContext\x12Q\n\x10dyna\
    mic_metadata\x18\r\x20\x03(\x0b2&.envoy.type.matcher.v3.MetadataMatcherR\
    \x0fdynamicMetadata\x1aS\n\x15GrpcRouteMatchOptions::\x9a\xc5\x88\x1e5\n\
    3envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions\x1a\xc9\x01\n\x16Tl\
    sContextMatchOptions\x128\n\tpresented\x18\x01\x20\x01(\x0b2\x1a.google.\
    protobuf.BoolValueR\tpresented\x128\n\tvalidated\x18\x02\x20\x01(\x0b2\
    \x1a.google.protobuf.BoolValueR\tvalidated:;\x9a\xc5\x88\x1e6\n4envoy.ap\
    i.v2.route.RouteMatch.TlsContextMatchOptions\x1a\x10\n\x0eConnectMatcher\
    B\x15\n\x0epath_specifier\x12\x03\xf8B\x01:$\x9a\xc5\x88\x1e\x1f\n\x1den\
    voy.api.v2.route.RouteMatchJ\x04\x08\x05\x10\x06J\x04\x08\x03\x10\x04R\
    \x05regex\"\xe8\x04\n\nCorsPolicy\x12_\n\x19allow_origin_string_match\
    \x18\x0b\x20\x03(\x0b2$.envoy.type.matcher.v3.StringMatcherR\x16allowOri\
    ginStringMatch\x12#\n\rallow_methods\x18\x02\x20\x01(\tR\x0callowMethods\
    \x12#\n\rallow_headers\x18\x03\x20\x01(\tR\x0callowHeaders\x12%\n\x0eexp\
    ose_headers\x18\x04\x20\x01(\tR\rexposeHeaders\x12\x17\n\x07max_age\x18\
    \x05\x20\x01(\tR\x06maxAge\x12G\n\x11allow_credentials\x18\x06\x20\x01(\
    \x0b2\x1a.google.protobuf.BoolValueR\x10allowCredentials\x12W\n\x0efilte\
    r_enabled\x18\t\x20\x01(\x0b2..envoy.config.core.v3.RuntimeFractionalPer\
    centH\0R\rfilterEnabled\x12U\n\x0eshadow_enabled\x18\n\x20\x01(\x0b2..en\
    voy.config.core.v3.RuntimeFractionalPercentR\rshadowEnabledB\x13\n\x11en\
    abled_specifier:$\x9a\xc5\x88\x1e\x1f\n\x1denvoy.api.v2.route.CorsPolicy\
    J\x04\x08\x01\x10\x02J\x04\x08\x08\x10\tJ\x04\x08\x07\x10\x08R\x0callow_\
    originR\x12allow_origin_regexR\x07enabled\"\xe9'\n\x0bRouteAction\x12#\n\
    \x07cluster\x18\x01\x20\x01(\tH\0R\x07clusterB\x07\xfaB\x04r\x02\x10\x01\
    \x126\n\x0ecluster_header\x18\x02\x20\x01(\tH\0R\rclusterHeaderB\r\xfaB\
    \nr\x08\x10\x01\xc0\x01\x01\xc8\x01\0\x12U\n\x11weighted_clusters\x18\
    \x03\x20\x01(\x0b2&.envoy.config.route.v3.WeightedClusterH\0R\x10weighte\
    dClusters\x12:\n\x18cluster_specifier_plugin\x18%\x20\x01(\tH\0R\x16clus\
    terSpecifierPlugin\x12\x8e\x01\n\x1fcluster_not_found_response_code\x18\
    \x14\x20\x01(\x0e2>.envoy.config.route.v3.RouteAction.ClusterNotFoundRes\
    ponseCodeR\x1bclusterNotFoundResponseCodeB\x08\xfaB\x05\x82\x01\x02\x10\
    \x01\x12E\n\x0emetadata_match\x18\x04\x20\x01(\x0b2\x1e.envoy.config.cor\
    e.v3.MetadataR\rmetadataMatch\x122\n\x0eprefix_rewrite\x18\x05\x20\x01(\
    \tR\rprefixRewriteB\x0b\xfaB\x08r\x06\xc0\x01\x02\xc8\x01\0\x12S\n\rrege\
    x_rewrite\x18\x20\x20\x01(\x0b2..envoy.type.matcher.v3.RegexMatchAndSubs\
    tituteR\x0cregexRewrite\x12?\n\x14host_rewrite_literal\x18\x06\x20\x01(\
    \tH\x01R\x12hostRewriteLiteralB\x0b\xfaB\x08r\x06\xc0\x01\x02\xc8\x01\0\
    \x12H\n\x11auto_host_rewrite\x18\x07\x20\x01(\x0b2\x1a.google.protobuf.B\
    oolValueH\x01R\x0fautoHostRewrite\x12=\n\x13host_rewrite_header\x18\x1d\
    \x20\x01(\tH\x01R\x11hostRewriteHeaderB\x0b\xfaB\x08r\x06\xc0\x01\x01\
    \xc8\x01\0\x12g\n\x17host_rewrite_path_regex\x18#\x20\x01(\x0b2..envoy.t\
    ype.matcher.v3.RegexMatchAndSubstituteH\x01R\x14hostRewritePathRegex\x12\
    5\n\x17append_x_forwarded_host\x18&\x20\x01(\x08R\x14appendXForwardedHos\
    t\x123\n\x07timeout\x18\x08\x20\x01(\x0b2\x19.google.protobuf.DurationR\
    \x07timeout\x12<\n\x0cidle_timeout\x18\x18\x20\x01(\x0b2\x19.google.prot\
    obuf.DurationR\x0bidleTimeout\x12E\n\x0cretry_policy\x18\t\x20\x01(\x0b2\
    \".envoy.config.route.v3.RetryPolicyR\x0bretryPolicy\x12O\n\x19retry_pol\
    icy_typed_config\x18!\x20\x01(\x0b2\x14.google.protobuf.AnyR\x16retryPol\
    icyTypedConfig\x12n\n\x17request_mirror_policies\x18\x1e\x20\x03(\x0b26.\
    envoy.config.route.v3.RouteAction.RequestMirrorPolicyR\x15requestMirrorP\
    olicies\x12K\n\x08priority\x18\x0b\x20\x01(\x0e2%.envoy.config.core.v3.R\
    outingPriorityR\x08priorityB\x08\xfaB\x05\x82\x01\x02\x10\x01\x12A\n\x0b\
    rate_limits\x18\r\x20\x03(\x0b2\x20.envoy.config.route.v3.RateLimitR\nra\
    teLimits\x12\\\n\x16include_vh_rate_limits\x18\x0e\x20\x01(\x0b2\x1a.goo\
    gle.protobuf.BoolValueR\x13includeVhRateLimitsB\x0b\x18\x01\x92\xc7\x86\
    \xd8\x04\x033.0\x12N\n\x0bhash_policy\x18\x0f\x20\x03(\x0b2-.envoy.confi\
    g.route.v3.RouteAction.HashPolicyR\nhashPolicy\x125\n\x04cors\x18\x11\
    \x20\x01(\x0b2!.envoy.config.route.v3.CorsPolicyR\x04cors\x12P\n\x10max_\
    grpc_timeout\x18\x17\x20\x01(\x0b2\x19.google.protobuf.DurationR\x0emaxG\
    rpcTimeoutB\x0b\x18\x01\x92\xc7\x86\xd8\x04\x033.0\x12V\n\x13grpc_timeou\
    t_offset\x18\x1c\x20\x01(\x0b2\x19.google.protobuf.DurationR\x11grpcTime\
    outOffsetB\x0b\x18\x01\x92\xc7\x86\xd8\x04\x033.0\x12Y\n\x0fupgrade_conf\
    igs\x18\x19\x20\x03(\x0b20.envoy.config.route.v3.RouteAction.UpgradeConf\
    igR\x0eupgradeConfigs\x12g\n\x18internal_redirect_policy\x18\"\x20\x01(\
    \x0b2-.envoy.config.route.v3.InternalRedirectPolicyR\x16internalRedirect\
    Policy\x12\x80\x01\n\x18internal_redirect_action\x18\x1a\x20\x01(\x0e29.\
    envoy.config.route.v3.RouteAction.InternalRedirectActionR\x16internalRed\
    irectActionB\x0b\x18\x01\x92\xc7\x86\xd8\x04\x033.0\x12_\n\x16max_intern\
    al_redirects\x18\x1f\x20\x01(\x0b2\x1c.google.protobuf.UInt32ValueR\x14m\
    axInternalRedirectsB\x0b\x18\x01\x92\xc7\x86\xd8\x04\x033.0\x12E\n\x0che\
    dge_policy\x18\x1b\x20\x01(\x0b2\".envoy.config.route.v3.HedgePolicyR\
    \x0bhedgePolicy\x12d\n\x13max_stream_duration\x18$\x20\x01(\x0b24.envoy.\
    config.route.v3.RouteAction.MaxStreamDurationR\x11maxStreamDuration\x1a\
    \xa2\x02\n\x13RequestMirrorPolicy\x12!\n\x07cluster\x18\x01\x20\x01(\tR\
    \x07clusterB\x07\xfaB\x04r\x02\x10\x01\x12Y\n\x10runtime_fraction\x18\
    \x03\x20\x01(\x0b2..envoy.config.core.v3.RuntimeFractionalPercentR\x0fru\
    ntimeFraction\x12?\n\rtrace_sampled\x18\x04\x20\x01(\x0b2\x1a.google.pro\
    tobuf.BoolValueR\x0ctraceSampled:9\x9a\xc5\x88\x1e4\n2envoy.api.v2.route\
    .RouteAction.RequestMirrorPolicyJ\x04\x08\x02\x10\x03R\x0bruntime_key\
    \x1a\x96\n\n\nHashPolicy\x12N\n\x06header\x18\x01\x20\x01(\x0b24.envoy.c\
    onfig.route.v3.RouteAction.HashPolicy.HeaderH\0R\x06header\x12N\n\x06coo\
    kie\x18\x02\x20\x01(\x0b24.envoy.config.route.v3.RouteAction.HashPolicy.\
    CookieH\0R\x06cookie\x12y\n\x15connection_properties\x18\x03\x20\x01(\
    \x0b2B.envoy.config.route.v3.RouteAction.HashPolicy.ConnectionProperties\
    H\0R\x14connectionProperties\x12g\n\x0fquery_parameter\x18\x05\x20\x01(\
    \x0b2<.envoy.config.route.v3.RouteAction.HashPolicy.QueryParameterH\0R\
    \x0equeryParameter\x12^\n\x0cfilter_state\x18\x06\x20\x01(\x0b29.envoy.c\
    onfig.route.v3.RouteAction.HashPolicy.FilterStateH\0R\x0bfilterState\x12\
    \x1a\n\x08terminal\x18\x04\x20\x01(\x08R\x08terminal\x1a\xc6\x01\n\x06He\
    ader\x12.\n\x0bheader_name\x18\x01\x20\x01(\tR\nheaderNameB\r\xfaB\nr\
    \x08\x10\x01\xc0\x01\x01\xc8\x01\0\x12S\n\rregex_rewrite\x18\x02\x20\x01\
    (\x0b2..envoy.type.matcher.v3.RegexMatchAndSubstituteR\x0cregexRewrite:7\
    \x9a\xc5\x88\x1e2\n0envoy.api.v2.route.RouteAction.HashPolicy.Header\x1a\
    \x9f\x01\n\x06Cookie\x12\x1b\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x07\
    \xfaB\x04r\x02\x10\x01\x12+\n\x03ttl\x18\x02\x20\x01(\x0b2\x19.google.pr\
    otobuf.DurationR\x03ttl\x12\x12\n\x04path\x18\x03\x20\x01(\tR\x04path:7\
    \x9a\xc5\x88\x1e2\n0envoy.api.v2.route.RouteAction.HashPolicy.Cookie\x1a\
    z\n\x14ConnectionProperties\x12\x1b\n\tsource_ip\x18\x01\x20\x01(\x08R\
    \x08sourceIp:E\x9a\xc5\x88\x1e@\n>envoy.api.v2.route.RouteAction.HashPol\
    icy.ConnectionProperties\x1an\n\x0eQueryParameter\x12\x1b\n\x04name\x18\
    \x01\x20\x01(\tR\x04nameB\x07\xfaB\x04r\x02\x10\x01:?\x9a\xc5\x88\x1e:\n\
    8envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter\x1af\n\x0bFilt\
    erState\x12\x19\n\x03key\x18\x01\x20\x01(\tR\x03keyB\x07\xfaB\x04r\x02\
    \x10\x01:<\x9a\xc5\x88\x1e7\n5envoy.api.v2.route.RouteAction.HashPolicy.\
    FilterStateB\x17\n\x10policy_specifier\x12\x03\xf8B\x01:0\x9a\xc5\x88\
    \x1e+\n)envoy.api.v2.route.RouteAction.HashPolicy\x1a\xa3\x03\n\rUpgrade\
    Config\x120\n\x0cupgrade_type\x18\x01\x20\x01(\tR\x0bupgradeTypeB\r\xfaB\
    \nr\x08\x10\x01\xc0\x01\x02\xc8\x01\0\x124\n\x07enabled\x18\x02\x20\x01(\
    \x0b2\x1a.google.protobuf.BoolValueR\x07enabled\x12e\n\x0econnect_config\
    \x18\x03\x20\x01(\x0b2>.envoy.config.route.v3.RouteAction.UpgradeConfig.\
    ConnectConfigR\rconnectConfig\x1a\x8d\x01\n\rConnectConfig\x12]\n\x15pro\
    xy_protocol_config\x18\x01\x20\x01(\x0b2).envoy.config.core.v3.ProxyProt\
    ocolConfigR\x13proxyProtocolConfig\x12\x1d\n\nallow_post\x18\x02\x20\x01\
    (\x08R\tallowPost:3\x9a\xc5\x88\x1e.\n,envoy.api.v2.route.RouteAction.Up\
    gradeConfig\x1a\x88\x02\n\x11MaxStreamDuration\x12I\n\x13max_stream_dura\
    tion\x18\x01\x20\x01(\x0b2\x19.google.protobuf.DurationR\x11maxStreamDur\
    ation\x12P\n\x17grpc_timeout_header_max\x18\x02\x20\x01(\x0b2\x19.google\
    .protobuf.DurationR\x14grpcTimeoutHeaderMax\x12V\n\x1agrpc_timeout_heade\
    r_offset\x18\x03\x20\x01(\x0b2\x19.google.protobuf.DurationR\x17grpcTime\
    outHeaderOffset\"E\n\x1bClusterNotFoundResponseCode\x12\x17\n\x13SERVICE\
    _UNAVAILABLE\x10\0\x12\r\n\tNOT_FOUND\x10\x01\"^\n\x16InternalRedirectAc\
    tion\x12\"\n\x1ePASS_THROUGH_INTERNAL_REDIRECT\x10\0\x12\x1c\n\x18HANDLE\
    _INTERNAL_REDIRECT\x10\x01\x1a\x02\x18\x01B\x18\n\x11cluster_specifier\
    \x12\x03\xf8B\x01B\x18\n\x16host_rewrite_specifier:%\x9a\xc5\x88\x1e\x20\
    \n\x1eenvoy.api.v2.route.RouteActionJ\x04\x08\x0c\x10\rJ\x04\x08\x12\x10\
    \x13J\x04\x08\x13\x10\x14J\x04\x08\x10\x10\x11J\x04\x08\x16\x10\x17J\x04\
    \x08\x15\x10\x16J\x04\x08\n\x10\x0bR\x15request_mirror_policy\"\xbf\x10\
    \n\x0bRetryPolicy\x12\x19\n\x08retry_on\x18\x01\x20\x01(\tR\x07retryOn\
    \x12R\n\x0bnum_retries\x18\x02\x20\x01(\x0b2\x1c.google.protobuf.UInt32V\
    alueR\nnumRetriesB\x13\xf2\x98\xfe\x8f\x05\r\n\x0bmax_retries\x12A\n\x0f\
    per_try_timeout\x18\x03\x20\x01(\x0b2\x19.google.protobuf.DurationR\rper\
    TryTimeout\x12J\n\x14per_try_idle_timeout\x18\r\x20\x01(\x0b2\x19.google\
    .protobuf.DurationR\x11perTryIdleTimeout\x12W\n\x0eretry_priority\x18\
    \x04\x20\x01(\x0b20.envoy.config.route.v3.RetryPolicy.RetryPriorityR\rre\
    tryPriority\x12g\n\x14retry_host_predicate\x18\x05\x20\x03(\x0b25.envoy.\
    config.route.v3.RetryPolicy.RetryHostPredicateR\x12retryHostPredicate\
    \x12d\n\x18retry_options_predicates\x18\x0c\x20\x03(\x0b2*.envoy.config.\
    core.v3.TypedExtensionConfigR\x16retryOptionsPredicates\x12H\n!host_sele\
    ction_retry_max_attempts\x18\x06\x20\x01(\x03R\x1dhostSelectionRetryMaxA\
    ttempts\x124\n\x16retriable_status_codes\x18\x07\x20\x03(\rR\x14retriabl\
    eStatusCodes\x12U\n\x0eretry_back_off\x18\x08\x20\x01(\x0b2/.envoy.confi\
    g.route.v3.RetryPolicy.RetryBackOffR\x0cretryBackOff\x12x\n\x1brate_limi\
    ted_retry_back_off\x18\x0b\x20\x01(\x0b2:.envoy.config.route.v3.RetryPol\
    icy.RateLimitedRetryBackOffR\x17rateLimitedRetryBackOff\x12Q\n\x11retria\
    ble_headers\x18\t\x20\x03(\x0b2$.envoy.config.route.v3.HeaderMatcherR\
    \x10retriableHeaders\x12`\n\x19retriable_request_headers\x18\n\x20\x03(\
    \x0b2$.envoy.config.route.v3.HeaderMatcherR\x17retriableRequestHeaders\
    \x1a\xb9\x01\n\rRetryPriority\x12\x1b\n\x04name\x18\x01\x20\x01(\tR\x04n\
    ameB\x07\xfaB\x04r\x02\x10\x01\x129\n\x0ctyped_config\x18\x03\x20\x01(\
    \x0b2\x14.google.protobuf.AnyH\0R\x0btypedConfigB\r\n\x0bconfig_type:3\
    \x9a\xc5\x88\x1e.\n,envoy.api.v2.route.RetryPolicy.RetryPriorityJ\x04\
    \x08\x02\x10\x03R\x06config\x1a\xc3\x01\n\x12RetryHostPredicate\x12\x1b\
    \n\x04name\x18\x01\x20\x01(\tR\x04nameB\x07\xfaB\x04r\x02\x10\x01\x129\n\
    \x0ctyped_config\x18\x03\x20\x01(\x0b2\x14.google.protobuf.AnyH\0R\x0bty\
    pedConfigB\r\n\x0bconfig_type:8\x9a\xc5\x88\x1e3\n1envoy.api.v2.route.Re\
    tryPolicy.RetryHostPredicateJ\x04\x08\x02\x10\x03R\x06config\x1a\xd6\x01\
    \n\x0cRetryBackOff\x12J\n\rbase_interval\x18\x01\x20\x01(\x0b2\x19.googl\
    e.protobuf.DurationR\x0cbaseIntervalB\n\xfaB\x07\xaa\x01\x04\x08\x01*\0\
    \x12F\n\x0cmax_interval\x18\x02\x20\x01(\x0b2\x19.google.protobuf.Durati\
    onR\x0bmaxIntervalB\x08\xfaB\x05\xaa\x01\x02*\0:2\x9a\xc5\x88\x1e-\n+env\
    oy.api.v2.route.RetryPolicy.RetryBackOff\x1a\x88\x01\n\x0bResetHeader\
    \x12!\n\x04name\x18\x01\x20\x01(\tR\x04nameB\r\xfaB\nr\x08\x10\x01\xc0\
    \x01\x01\xc8\x01\0\x12V\n\x06format\x18\x02\x20\x01(\x0e24.envoy.config.\
    route.v3.RetryPolicy.ResetHeaderFormatR\x06formatB\x08\xfaB\x05\x82\x01\
    \x02\x10\x01\x1a\xc0\x01\n\x17RateLimitedRetryBackOff\x12]\n\rreset_head\
    ers\x18\x01\x20\x03(\x0b2..envoy.config.route.v3.RetryPolicy.ResetHeader\
    R\x0cresetHeadersB\x08\xfaB\x05\x92\x01\x02\x08\x01\x12F\n\x0cmax_interv\
    al\x18\x02\x20\x01(\x0b2\x19.google.protobuf.DurationR\x0bmaxIntervalB\
    \x08\xfaB\x05\xaa\x01\x02*\0\"4\n\x11ResetHeaderFormat\x12\x0b\n\x07SECO\
    NDS\x10\0\x12\x12\n\x0eUNIX_TIMESTAMP\x10\x01:%\x9a\xc5\x88\x1e\x20\n\
    \x1eenvoy.api.v2.route.RetryPolicy\"\x9c\x02\n\x0bHedgePolicy\x12P\n\x10\
    initial_requests\x18\x01\x20\x01(\x0b2\x1c.google.protobuf.UInt32ValueR\
    \x0finitialRequestsB\x07\xfaB\x04*\x02(\x01\x12\\\n\x19additional_reques\
    t_chance\x18\x02\x20\x01(\x0b2\x20.envoy.type.v3.FractionalPercentR\x17a\
    dditionalRequestChance\x126\n\x18hedge_on_per_try_timeout\x18\x03\x20\
    \x01(\x08R\x14hedgeOnPerTryTimeout:%\x9a\xc5\x88\x1e\x20\n\x1eenvoy.api.\
    v2.route.HedgePolicy\"\xe1\x05\n\x0eRedirectAction\x12'\n\x0ehttps_redir\
    ect\x18\x04\x20\x01(\x08H\0R\rhttpsRedirect\x12)\n\x0fscheme_redirect\
    \x18\x07\x20\x01(\tH\0R\x0eschemeRedirect\x120\n\rhost_redirect\x18\x01\
    \x20\x01(\tR\x0chostRedirectB\x0b\xfaB\x08r\x06\xc0\x01\x02\xc8\x01\0\
    \x12#\n\rport_redirect\x18\x08\x20\x01(\rR\x0cportRedirect\x122\n\rpath_\
    redirect\x18\x02\x20\x01(\tH\x01R\x0cpathRedirectB\x0b\xfaB\x08r\x06\xc0\
    \x01\x02\xc8\x01\0\x124\n\x0eprefix_rewrite\x18\x05\x20\x01(\tH\x01R\rpr\
    efixRewriteB\x0b\xfaB\x08r\x06\xc0\x01\x02\xc8\x01\0\x12U\n\rregex_rewri\
    te\x18\t\x20\x01(\x0b2..envoy.type.matcher.v3.RegexMatchAndSubstituteH\
    \x01R\x0cregexRewrite\x12i\n\rresponse_code\x18\x03\x20\x01(\x0e2:.envoy\
    .config.route.v3.RedirectAction.RedirectResponseCodeR\x0cresponseCodeB\
    \x08\xfaB\x05\x82\x01\x02\x10\x01\x12\x1f\n\x0bstrip_query\x18\x06\x20\
    \x01(\x08R\nstripQuery\"w\n\x14RedirectResponseCode\x12\x15\n\x11MOVED_P\
    ERMANENTLY\x10\0\x12\t\n\x05FOUND\x10\x01\x12\r\n\tSEE_OTHER\x10\x02\x12\
    \x16\n\x12TEMPORARY_REDIRECT\x10\x03\x12\x16\n\x12PERMANENT_REDIRECT\x10\
    \x04B\x1a\n\x18scheme_rewrite_specifierB\x18\n\x16path_rewrite_specifier\
    :(\x9a\xc5\x88\x1e#\n!envoy.api.v2.route.RedirectAction\"\xa0\x01\n\x14D\
    irectResponseAction\x12\"\n\x06status\x18\x01\x20\x01(\rR\x06statusB\n\
    \xfaB\x07*\x05\x10\xd8\x04(d\x124\n\x04body\x18\x02\x20\x01(\x0b2\x20.en\
    voy.config.core.v3.DataSourceR\x04body:.\x9a\xc5\x88\x1e)\n'envoy.api.v2\
    .route.DirectResponseAction\"\x15\n\x13NonForwardingAction\"\x91\x01\n\t\
    Decorator\x12%\n\toperation\x18\x01\x20\x01(\tR\toperationB\x07\xfaB\x04\
    r\x02\x10\x01\x128\n\tpropagate\x18\x02\x20\x01(\x0b2\x1a.google.protobu\
    f.BoolValueR\tpropagate:#\x9a\xc5\x88\x1e\x1e\n\x1cenvoy.api.v2.route.De\
    corator\"\xd2\x02\n\x07Tracing\x12I\n\x0fclient_sampling\x18\x01\x20\x01\
    (\x0b2\x20.envoy.type.v3.FractionalPercentR\x0eclientSampling\x12I\n\x0f\
    random_sampling\x18\x02\x20\x01(\x0b2\x20.envoy.type.v3.FractionalPercen\
    tR\x0erandomSampling\x12K\n\x10overall_sampling\x18\x03\x20\x01(\x0b2\
    \x20.envoy.type.v3.FractionalPercentR\x0foverallSampling\x12A\n\x0bcusto\
    m_tags\x18\x04\x20\x03(\x0b2\x20.envoy.type.tracing.v3.CustomTagR\ncusto\
    mTags:!\x9a\xc5\x88\x1e\x1c\n\x1aenvoy.api.v2.route.Tracing\"\xb4\x01\n\
    \x0eVirtualCluster\x12>\n\x07headers\x18\x04\x20\x03(\x0b2$.envoy.config\
    .route.v3.HeaderMatcherR\x07headers\x12\x1b\n\x04name\x18\x02\x20\x01(\t\
    R\x04nameB\x07\xfaB\x04r\x02\x10\x01:(\x9a\xc5\x88\x1e#\n!envoy.api.v2.r\
    oute.VirtualClusterJ\x04\x08\x01\x10\x02J\x04\x08\x03\x10\x04R\x07patter\
    nR\x06method\"\xaa\x16\n\tRateLimit\x12;\n\x05stage\x18\x01\x20\x01(\x0b\
    2\x1c.google.protobuf.UInt32ValueR\x05stageB\x07\xfaB\x04*\x02\x18\n\x12\
    \x1f\n\x0bdisable_key\x18\x02\x20\x01(\tR\ndisableKey\x12K\n\x07actions\
    \x18\x03\x20\x03(\x0b2'.envoy.config.route.v3.RateLimit.ActionR\x07actio\
    nsB\x08\xfaB\x05\x92\x01\x02\x08\x01\x12?\n\x05limit\x18\x04\x20\x01(\
    \x0b2).envoy.config.route.v3.RateLimit.OverrideR\x05limit\x1a\x96\x12\n\
    \x06Action\x12^\n\x0esource_cluster\x18\x01\x20\x01(\x0b25.envoy.config.\
    route.v3.RateLimit.Action.SourceClusterH\0R\rsourceCluster\x12m\n\x13des\
    tination_cluster\x18\x02\x20\x01(\x0b2:.envoy.config.route.v3.RateLimit.\
    Action.DestinationClusterH\0R\x12destinationCluster\x12a\n\x0frequest_he\
    aders\x18\x03\x20\x01(\x0b26.envoy.config.route.v3.RateLimit.Action.Requ\
    estHeadersH\0R\x0erequestHeaders\x12^\n\x0eremote_address\x18\x04\x20\
    \x01(\x0b25.envoy.config.route.v3.RateLimit.Action.RemoteAddressH\0R\rre\
    moteAddress\x12U\n\x0bgeneric_key\x18\x05\x20\x01(\x0b22.envoy.config.ro\
    ute.v3.RateLimit.Action.GenericKeyH\0R\ngenericKey\x12h\n\x12header_valu\
    e_match\x18\x06\x20\x01(\x0b28.envoy.config.route.v3.RateLimit.Action.He\
    aderValueMatchH\0R\x10headerValueMatch\x12w\n\x10dynamic_metadata\x18\
    \x07\x20\x01(\x0b27.envoy.config.route.v3.RateLimit.Action.DynamicMetaDa\
    taH\0R\x0fdynamicMetadataB\x11\x18\x01\x92\xc7\x86\xd8\x04\x033.0\xb8\
    \xee\xf2\xd2\x05\x01\x12N\n\x08metadata\x18\x08\x20\x01(\x0b20.envoy.con\
    fig.route.v3.RateLimit.Action.MetaDataH\0R\x08metadata\x12J\n\textension\
    \x18\t\x20\x01(\x0b2*.envoy.config.core.v3.TypedExtensionConfigH\0R\text\
    ension\x1aI\n\rSourceCluster:8\x9a\xc5\x88\x1e3\n1envoy.api.v2.route.Rat\
    eLimit.Action.SourceCluster\x1aS\n\x12DestinationCluster:=\x9a\xc5\x88\
    \x1e8\n6envoy.api.v2.route.RateLimit.Action.DestinationCluster\x1a\xd1\
    \x01\n\x0eRequestHeaders\x12.\n\x0bheader_name\x18\x01\x20\x01(\tR\nhead\
    erNameB\r\xfaB\nr\x08\x10\x01\xc0\x01\x01\xc8\x01\0\x12.\n\x0edescriptor\
    _key\x18\x02\x20\x01(\tR\rdescriptorKeyB\x07\xfaB\x04r\x02\x10\x01\x12$\
    \n\x0eskip_if_absent\x18\x03\x20\x01(\x08R\x0cskipIfAbsent:9\x9a\xc5\x88\
    \x1e4\n2envoy.api.v2.route.RateLimit.Action.RequestHeaders\x1aI\n\rRemot\
    eAddress:8\x9a\xc5\x88\x1e3\n1envoy.api.v2.route.RateLimit.Action.Remote\
    Address\x1a\x9e\x01\n\nGenericKey\x122\n\x10descriptor_value\x18\x01\x20\
    \x01(\tR\x0fdescriptorValueB\x07\xfaB\x04r\x02\x10\x01\x12%\n\x0edescrip\
    tor_key\x18\x02\x20\x01(\tR\rdescriptorKey:5\x9a\xc5\x88\x1e0\n.envoy.ap\
    i.v2.route.RateLimit.Action.GenericKey\x1a\x8c\x02\n\x10HeaderValueMatch\
    \x122\n\x10descriptor_value\x18\x01\x20\x01(\tR\x0fdescriptorValueB\x07\
    \xfaB\x04r\x02\x10\x01\x12=\n\x0cexpect_match\x18\x02\x20\x01(\x0b2\x1a.\
    google.protobuf.BoolValueR\x0bexpectMatch\x12H\n\x07headers\x18\x03\x20\
    \x03(\x0b2$.envoy.config.route.v3.HeaderMatcherR\x07headersB\x08\xfaB\
    \x05\x92\x01\x02\x08\x01:;\x9a\xc5\x88\x1e6\n4envoy.api.v2.route.RateLim\
    it.Action.HeaderValueMatch\x1a\xb8\x01\n\x0fDynamicMetaData\x12.\n\x0ede\
    scriptor_key\x18\x01\x20\x01(\tR\rdescriptorKeyB\x07\xfaB\x04r\x02\x10\
    \x01\x12P\n\x0cmetadata_key\x18\x02\x20\x01(\x0b2#.envoy.type.metadata.v\
    3.MetadataKeyR\x0bmetadataKeyB\x08\xfaB\x05\x8a\x01\x02\x10\x01\x12#\n\r\
    default_value\x18\x03\x20\x01(\tR\x0cdefaultValue\x1a\xb4\x02\n\x08MetaD\
    ata\x12.\n\x0edescriptor_key\x18\x01\x20\x01(\tR\rdescriptorKeyB\x07\xfa\
    B\x04r\x02\x10\x01\x12P\n\x0cmetadata_key\x18\x02\x20\x01(\x0b2#.envoy.t\
    ype.metadata.v3.MetadataKeyR\x0bmetadataKeyB\x08\xfaB\x05\x8a\x01\x02\
    \x10\x01\x12#\n\rdefault_value\x18\x03\x20\x01(\tR\x0cdefaultValue\x12Y\
    \n\x06source\x18\x04\x20\x01(\x0e27.envoy.config.route.v3.RateLimit.Acti\
    on.MetaData.SourceR\x06sourceB\x08\xfaB\x05\x82\x01\x02\x10\x01\"&\n\x06\
    Source\x12\x0b\n\x07DYNAMIC\x10\0\x12\x0f\n\x0bROUTE_ENTRY\x10\x01B\x17\
    \n\x10action_specifier\x12\x03\xf8B\x01:*\x9a\xc5\x88\x1e%\n#envoy.api.v\
    2.route.RateLimit.Action\x1a\xf2\x01\n\x08Override\x12f\n\x10dynamic_met\
    adata\x18\x01\x20\x01(\x0b29.envoy.config.route.v3.RateLimit.Override.Dy\
    namicMetadataH\0R\x0fdynamicMetadata\x1ac\n\x0fDynamicMetadata\x12P\n\
    \x0cmetadata_key\x18\x01\x20\x01(\x0b2#.envoy.type.metadata.v3.MetadataK\
    eyR\x0bmetadataKeyB\x08\xfaB\x05\x8a\x01\x02\x10\x01B\x19\n\x12override_\
    specifier\x12\x03\xf8B\x01:#\x9a\xc5\x88\x1e\x1e\n\x1cenvoy.api.v2.route\
    .RateLimit\"\xa4\x05\n\rHeaderMatcher\x12!\n\x04name\x18\x01\x20\x01(\tR\
    \x04nameB\r\xfaB\nr\x08\x10\x01\xc0\x01\x01\xc8\x01\0\x12.\n\x0bexact_ma\
    tch\x18\x04\x20\x01(\tH\0R\nexactMatchB\x0b\x18\x01\x92\xc7\x86\xd8\x04\
    \x033.0\x12\\\n\x10safe_regex_match\x18\x0b\x20\x01(\x0b2#.envoy.type.ma\
    tcher.v3.RegexMatcherH\0R\x0esafeRegexMatchB\x0b\x18\x01\x92\xc7\x86\xd8\
    \x04\x033.0\x12<\n\x0brange_match\x18\x06\x20\x01(\x0b2\x19.envoy.type.v\
    3.Int64RangeH\0R\nrangeMatch\x12%\n\rpresent_match\x18\x07\x20\x01(\x08H\
    \0R\x0cpresentMatch\x127\n\x0cprefix_match\x18\t\x20\x01(\tH\0R\x0bprefi\
    xMatchB\x12\x18\x01\x92\xc7\x86\xd8\x04\x033.0\xfaB\x04r\x02\x10\x01\x12\
    7\n\x0csuffix_match\x18\n\x20\x01(\tH\0R\x0bsuffixMatchB\x12\x18\x01\x92\
    \xc7\x86\xd8\x04\x033.0\xfaB\x04r\x02\x10\x01\x12;\n\x0econtains_match\
    \x18\x0c\x20\x01(\tH\0R\rcontainsMatchB\x12\x18\x01\x92\xc7\x86\xd8\x04\
    \x033.0\xfaB\x04r\x02\x10\x01\x12I\n\x0cstring_match\x18\r\x20\x01(\x0b2\
    $.envoy.type.matcher.v3.StringMatcherH\0R\x0bstringMatch\x12!\n\x0cinver\
    t_match\x18\x08\x20\x01(\x08R\x0binvertMatchB\x18\n\x16header_match_spec\
    ifier:'\x9a\xc5\x88\x1e\"\n\x20envoy.api.v2.route.HeaderMatcherJ\x04\x08\
    \x02\x10\x03J\x04\x08\x03\x10\x04J\x04\x08\x05\x10\x06R\x0bregex_match\"\
    \xa1\x02\n\x15QueryParameterMatcher\x12\x1e\n\x04name\x18\x01\x20\x01(\t\
    R\x04nameB\n\xfaB\x07r\x05\x10\x01(\x80\x08\x12S\n\x0cstring_match\x18\
    \x05\x20\x01(\x0b2$.envoy.type.matcher.v3.StringMatcherH\0R\x0bstringMat\
    chB\x08\xfaB\x05\x8a\x01\x02\x10\x01\x12%\n\rpresent_match\x18\x06\x20\
    \x01(\x08H\0R\x0cpresentMatchB!\n\x1fquery_parameter_match_specifier:/\
    \x9a\xc5\x88\x1e*\n(envoy.api.v2.route.QueryParameterMatcherJ\x04\x08\
    \x03\x10\x04J\x04\x08\x04\x10\x05R\x05valueR\x05regex\"\xb9\x02\n\x16Int\
    ernalRedirectPolicy\x12R\n\x16max_internal_redirects\x18\x01\x20\x01(\
    \x0b2\x1c.google.protobuf.UInt32ValueR\x14maxInternalRedirects\x12@\n\
    \x17redirect_response_codes\x18\x02\x20\x03(\rR\x15redirectResponseCodes\
    B\x08\xfaB\x05\x92\x01\x02\x10\x05\x12J\n\npredicates\x18\x03\x20\x03(\
    \x0b2*.envoy.config.core.v3.TypedExtensionConfigR\npredicates\x12=\n\x1b\
    allow_cross_scheme_redirect\x18\x04\x20\x01(\x08R\x18allowCrossSchemeRed\
    irect\"]\n\x0cFilterConfig\x12,\n\x06config\x18\x01\x20\x01(\x0b2\x14.go\
    ogle.protobuf.AnyR\x06config\x12\x1f\n\x0bis_optional\x18\x02\x20\x01(\
    \x08R\nisOptionalBE\n#io.envoyproxy.envoy.config.route.v3B\x14RouteCompo\
    nentsProtoP\x01\xba\x80\xc8\xd1\x06\x02\x10\x02b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
