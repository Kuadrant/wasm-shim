// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `envoy/config/core/v3/base.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Locality {
    // message fields
    pub region: ::std::string::String,
    pub zone: ::std::string::String,
    pub sub_zone: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Locality {
    fn default() -> &'a Locality {
        <Locality as ::protobuf::Message>::default_instance()
    }
}

impl Locality {
    pub fn new() -> Locality {
        ::std::default::Default::default()
    }

    // string region = 1;


    pub fn get_region(&self) -> &str {
        &self.region
    }
    pub fn clear_region(&mut self) {
        self.region.clear();
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: ::std::string::String) {
        self.region = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region(&mut self) -> &mut ::std::string::String {
        &mut self.region
    }

    // Take field
    pub fn take_region(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.region, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string sub_zone = 3;


    pub fn get_sub_zone(&self) -> &str {
        &self.sub_zone
    }
    pub fn clear_sub_zone(&mut self) {
        self.sub_zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_sub_zone(&mut self, v: ::std::string::String) {
        self.sub_zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sub_zone(&mut self) -> &mut ::std::string::String {
        &mut self.sub_zone
    }

    // Take field
    pub fn take_sub_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sub_zone, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Locality {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.region)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sub_zone)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.region.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.region);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.sub_zone.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.sub_zone);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.region.is_empty() {
            os.write_string(1, &self.region)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.sub_zone.is_empty() {
            os.write_string(3, &self.sub_zone)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Locality {
        Locality::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "region",
                |m: &Locality| { &m.region },
                |m: &mut Locality| { &mut m.region },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &Locality| { &m.zone },
                |m: &mut Locality| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sub_zone",
                |m: &Locality| { &m.sub_zone },
                |m: &mut Locality| { &mut m.sub_zone },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Locality>(
                "Locality",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Locality {
        static instance: ::protobuf::rt::LazyV2<Locality> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Locality::new)
    }
}

impl ::protobuf::Clear for Locality {
    fn clear(&mut self) {
        self.region.clear();
        self.zone.clear();
        self.sub_zone.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Locality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Locality {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct BuildVersion {
    // message fields
    pub version: ::protobuf::SingularPtrField<super::semantic_version::SemanticVersion>,
    pub metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuildVersion {
    fn default() -> &'a BuildVersion {
        <BuildVersion as ::protobuf::Message>::default_instance()
    }
}

impl BuildVersion {
    pub fn new() -> BuildVersion {
        ::std::default::Default::default()
    }

    // .envoy.type.v3.SemanticVersion version = 1;


    pub fn get_version(&self) -> &super::semantic_version::SemanticVersion {
        self.version.as_ref().unwrap_or_else(|| <super::semantic_version::SemanticVersion as ::protobuf::Message>::default_instance())
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: super::semantic_version::SemanticVersion) {
        self.version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut super::semantic_version::SemanticVersion {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> super::semantic_version::SemanticVersion {
        self.version.take().unwrap_or_else(|| super::semantic_version::SemanticVersion::new())
    }

    // .google.protobuf.Struct metadata = 2;


    pub fn get_metadata(&self) -> &::protobuf::well_known_types::Struct {
        self.metadata.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::well_known_types::Struct {
        self.metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }
}

impl ::protobuf::Message for BuildVersion {
    fn is_initialized(&self) -> bool {
        for v in &self.version {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.version.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuildVersion {
        BuildVersion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::semantic_version::SemanticVersion>>(
                "version",
                |m: &BuildVersion| { &m.version },
                |m: &mut BuildVersion| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "metadata",
                |m: &BuildVersion| { &m.metadata },
                |m: &mut BuildVersion| { &mut m.metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuildVersion>(
                "BuildVersion",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuildVersion {
        static instance: ::protobuf::rt::LazyV2<BuildVersion> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuildVersion::new)
    }
}

impl ::protobuf::Clear for BuildVersion {
    fn clear(&mut self) {
        self.version.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuildVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Extension {
    // message fields
    pub name: ::std::string::String,
    pub category: ::std::string::String,
    pub type_descriptor: ::std::string::String,
    pub version: ::protobuf::SingularPtrField<BuildVersion>,
    pub disabled: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Extension {
    fn default() -> &'a Extension {
        <Extension as ::protobuf::Message>::default_instance()
    }
}

impl Extension {
    pub fn new() -> Extension {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string category = 2;


    pub fn get_category(&self) -> &str {
        &self.category
    }
    pub fn clear_category(&mut self) {
        self.category.clear();
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: ::std::string::String) {
        self.category = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_category(&mut self) -> &mut ::std::string::String {
        &mut self.category
    }

    // Take field
    pub fn take_category(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.category, ::std::string::String::new())
    }

    // string type_descriptor = 3;


    pub fn get_type_descriptor(&self) -> &str {
        &self.type_descriptor
    }
    pub fn clear_type_descriptor(&mut self) {
        self.type_descriptor.clear();
    }

    // Param is passed by value, moved
    pub fn set_type_descriptor(&mut self, v: ::std::string::String) {
        self.type_descriptor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_descriptor(&mut self) -> &mut ::std::string::String {
        &mut self.type_descriptor
    }

    // Take field
    pub fn take_type_descriptor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.type_descriptor, ::std::string::String::new())
    }

    // .envoy.config.core.v3.BuildVersion version = 4;


    pub fn get_version(&self) -> &BuildVersion {
        self.version.as_ref().unwrap_or_else(|| <BuildVersion as ::protobuf::Message>::default_instance())
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: BuildVersion) {
        self.version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut BuildVersion {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> BuildVersion {
        self.version.take().unwrap_or_else(|| BuildVersion::new())
    }

    // bool disabled = 5;


    pub fn get_disabled(&self) -> bool {
        self.disabled
    }
    pub fn clear_disabled(&mut self) {
        self.disabled = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = v;
    }
}

impl ::protobuf::Message for Extension {
    fn is_initialized(&self) -> bool {
        for v in &self.version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.category)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.type_descriptor)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.category.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.category);
        }
        if !self.type_descriptor.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.type_descriptor);
        }
        if let Some(ref v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.disabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.category.is_empty() {
            os.write_string(2, &self.category)?;
        }
        if !self.type_descriptor.is_empty() {
            os.write_string(3, &self.type_descriptor)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.disabled != false {
            os.write_bool(5, self.disabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Extension {
        Extension::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Extension| { &m.name },
                |m: &mut Extension| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "category",
                |m: &Extension| { &m.category },
                |m: &mut Extension| { &mut m.category },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type_descriptor",
                |m: &Extension| { &m.type_descriptor },
                |m: &mut Extension| { &mut m.type_descriptor },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BuildVersion>>(
                "version",
                |m: &Extension| { &m.version },
                |m: &mut Extension| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled",
                |m: &Extension| { &m.disabled },
                |m: &mut Extension| { &mut m.disabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Extension>(
                "Extension",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Extension {
        static instance: ::protobuf::rt::LazyV2<Extension> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Extension::new)
    }
}

impl ::protobuf::Clear for Extension {
    fn clear(&mut self) {
        self.name.clear();
        self.category.clear();
        self.type_descriptor.clear();
        self.version.clear();
        self.disabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Extension {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Extension {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Node {
    // message fields
    pub id: ::std::string::String,
    pub cluster: ::std::string::String,
    pub metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub dynamic_parameters: ::std::collections::HashMap<::std::string::String, super::context_params::ContextParams>,
    pub locality: ::protobuf::SingularPtrField<Locality>,
    pub user_agent_name: ::std::string::String,
    pub extensions: ::protobuf::RepeatedField<Extension>,
    pub client_features: ::protobuf::RepeatedField<::std::string::String>,
    pub listening_addresses: ::protobuf::RepeatedField<super::address::Address>,
    // message oneof groups
    pub user_agent_version_type: ::std::option::Option<Node_oneof_user_agent_version_type>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Node {
    fn default() -> &'a Node {
        <Node as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum Node_oneof_user_agent_version_type {
    user_agent_version(::std::string::String),
    user_agent_build_version(BuildVersion),
}

impl Node {
    pub fn new() -> Node {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string cluster = 2;


    pub fn get_cluster(&self) -> &str {
        &self.cluster
    }
    pub fn clear_cluster(&mut self) {
        self.cluster.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: ::std::string::String) {
        self.cluster = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster(&mut self) -> &mut ::std::string::String {
        &mut self.cluster
    }

    // Take field
    pub fn take_cluster(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster, ::std::string::String::new())
    }

    // .google.protobuf.Struct metadata = 3;


    pub fn get_metadata(&self) -> &::protobuf::well_known_types::Struct {
        self.metadata.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::well_known_types::Struct {
        self.metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // repeated .envoy.config.core.v3.Node.DynamicParametersEntry dynamic_parameters = 12;


    pub fn get_dynamic_parameters(&self) -> &::std::collections::HashMap<::std::string::String, super::context_params::ContextParams> {
        &self.dynamic_parameters
    }
    pub fn clear_dynamic_parameters(&mut self) {
        self.dynamic_parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_dynamic_parameters(&mut self, v: ::std::collections::HashMap<::std::string::String, super::context_params::ContextParams>) {
        self.dynamic_parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dynamic_parameters(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::context_params::ContextParams> {
        &mut self.dynamic_parameters
    }

    // Take field
    pub fn take_dynamic_parameters(&mut self) -> ::std::collections::HashMap<::std::string::String, super::context_params::ContextParams> {
        ::std::mem::replace(&mut self.dynamic_parameters, ::std::collections::HashMap::new())
    }

    // .envoy.config.core.v3.Locality locality = 4;


    pub fn get_locality(&self) -> &Locality {
        self.locality.as_ref().unwrap_or_else(|| <Locality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_locality(&mut self) {
        self.locality.clear();
    }

    pub fn has_locality(&self) -> bool {
        self.locality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locality(&mut self, v: Locality) {
        self.locality = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locality(&mut self) -> &mut Locality {
        if self.locality.is_none() {
            self.locality.set_default();
        }
        self.locality.as_mut().unwrap()
    }

    // Take field
    pub fn take_locality(&mut self) -> Locality {
        self.locality.take().unwrap_or_else(|| Locality::new())
    }

    // string user_agent_name = 6;


    pub fn get_user_agent_name(&self) -> &str {
        &self.user_agent_name
    }
    pub fn clear_user_agent_name(&mut self) {
        self.user_agent_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_agent_name(&mut self, v: ::std::string::String) {
        self.user_agent_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_agent_name(&mut self) -> &mut ::std::string::String {
        &mut self.user_agent_name
    }

    // Take field
    pub fn take_user_agent_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_agent_name, ::std::string::String::new())
    }

    // string user_agent_version = 7;


    pub fn get_user_agent_version(&self) -> &str {
        match self.user_agent_version_type {
            ::std::option::Option::Some(Node_oneof_user_agent_version_type::user_agent_version(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_user_agent_version(&mut self) {
        self.user_agent_version_type = ::std::option::Option::None;
    }

    pub fn has_user_agent_version(&self) -> bool {
        match self.user_agent_version_type {
            ::std::option::Option::Some(Node_oneof_user_agent_version_type::user_agent_version(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_user_agent_version(&mut self, v: ::std::string::String) {
        self.user_agent_version_type = ::std::option::Option::Some(Node_oneof_user_agent_version_type::user_agent_version(v))
    }

    // Mutable pointer to the field.
    pub fn mut_user_agent_version(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Node_oneof_user_agent_version_type::user_agent_version(_)) = self.user_agent_version_type {
        } else {
            self.user_agent_version_type = ::std::option::Option::Some(Node_oneof_user_agent_version_type::user_agent_version(::std::string::String::new()));
        }
        match self.user_agent_version_type {
            ::std::option::Option::Some(Node_oneof_user_agent_version_type::user_agent_version(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_user_agent_version(&mut self) -> ::std::string::String {
        if self.has_user_agent_version() {
            match self.user_agent_version_type.take() {
                ::std::option::Option::Some(Node_oneof_user_agent_version_type::user_agent_version(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .envoy.config.core.v3.BuildVersion user_agent_build_version = 8;


    pub fn get_user_agent_build_version(&self) -> &BuildVersion {
        match self.user_agent_version_type {
            ::std::option::Option::Some(Node_oneof_user_agent_version_type::user_agent_build_version(ref v)) => v,
            _ => <BuildVersion as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_user_agent_build_version(&mut self) {
        self.user_agent_version_type = ::std::option::Option::None;
    }

    pub fn has_user_agent_build_version(&self) -> bool {
        match self.user_agent_version_type {
            ::std::option::Option::Some(Node_oneof_user_agent_version_type::user_agent_build_version(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_user_agent_build_version(&mut self, v: BuildVersion) {
        self.user_agent_version_type = ::std::option::Option::Some(Node_oneof_user_agent_version_type::user_agent_build_version(v))
    }

    // Mutable pointer to the field.
    pub fn mut_user_agent_build_version(&mut self) -> &mut BuildVersion {
        if let ::std::option::Option::Some(Node_oneof_user_agent_version_type::user_agent_build_version(_)) = self.user_agent_version_type {
        } else {
            self.user_agent_version_type = ::std::option::Option::Some(Node_oneof_user_agent_version_type::user_agent_build_version(BuildVersion::new()));
        }
        match self.user_agent_version_type {
            ::std::option::Option::Some(Node_oneof_user_agent_version_type::user_agent_build_version(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_user_agent_build_version(&mut self) -> BuildVersion {
        if self.has_user_agent_build_version() {
            match self.user_agent_version_type.take() {
                ::std::option::Option::Some(Node_oneof_user_agent_version_type::user_agent_build_version(v)) => v,
                _ => panic!(),
            }
        } else {
            BuildVersion::new()
        }
    }

    // repeated .envoy.config.core.v3.Extension extensions = 9;


    pub fn get_extensions(&self) -> &[Extension] {
        &self.extensions
    }
    pub fn clear_extensions(&mut self) {
        self.extensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_extensions(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extensions(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extensions
    }

    // Take field
    pub fn take_extensions(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extensions, ::protobuf::RepeatedField::new())
    }

    // repeated string client_features = 10;


    pub fn get_client_features(&self) -> &[::std::string::String] {
        &self.client_features
    }
    pub fn clear_client_features(&mut self) {
        self.client_features.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_features(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.client_features = v;
    }

    // Mutable pointer to the field.
    pub fn mut_client_features(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.client_features
    }

    // Take field
    pub fn take_client_features(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.client_features, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.config.core.v3.Address listening_addresses = 11;


    pub fn get_listening_addresses(&self) -> &[super::address::Address] {
        &self.listening_addresses
    }
    pub fn clear_listening_addresses(&mut self) {
        self.listening_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_listening_addresses(&mut self, v: ::protobuf::RepeatedField<super::address::Address>) {
        self.listening_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_listening_addresses(&mut self) -> &mut ::protobuf::RepeatedField<super::address::Address> {
        &mut self.listening_addresses
    }

    // Take field
    pub fn take_listening_addresses(&mut self) -> ::protobuf::RepeatedField<super::address::Address> {
        ::std::mem::replace(&mut self.listening_addresses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Node {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.locality {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Node_oneof_user_agent_version_type::user_agent_build_version(ref v)) = self.user_agent_version_type {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.extensions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.listening_addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                12 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::context_params::ContextParams>>(wire_type, is, &mut self.dynamic_parameters)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.locality)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_agent_name)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.user_agent_version_type = ::std::option::Option::Some(Node_oneof_user_agent_version_type::user_agent_version(is.read_string()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.user_agent_version_type = ::std::option::Option::Some(Node_oneof_user_agent_version_type::user_agent_build_version(is.read_message()?));
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extensions)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.client_features)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.listening_addresses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.cluster.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cluster);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::context_params::ContextParams>>(12, &self.dynamic_parameters);
        if let Some(ref v) = self.locality.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.user_agent_name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.user_agent_name);
        }
        for value in &self.extensions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.client_features {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.listening_addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.user_agent_version_type {
            match v {
                &Node_oneof_user_agent_version_type::user_agent_version(ref v) => {
                    my_size += ::protobuf::rt::string_size(7, &v);
                },
                &Node_oneof_user_agent_version_type::user_agent_build_version(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.cluster.is_empty() {
            os.write_string(2, &self.cluster)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::context_params::ContextParams>>(12, &self.dynamic_parameters, os)?;
        if let Some(ref v) = self.locality.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.user_agent_name.is_empty() {
            os.write_string(6, &self.user_agent_name)?;
        }
        for v in &self.extensions {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.client_features {
            os.write_string(10, &v)?;
        };
        for v in &self.listening_addresses {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.user_agent_version_type {
            match v {
                &Node_oneof_user_agent_version_type::user_agent_version(ref v) => {
                    os.write_string(7, v)?;
                },
                &Node_oneof_user_agent_version_type::user_agent_build_version(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Node {
        Node::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Node| { &m.id },
                |m: &mut Node| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster",
                |m: &Node| { &m.cluster },
                |m: &mut Node| { &mut m.cluster },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "metadata",
                |m: &Node| { &m.metadata },
                |m: &mut Node| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::context_params::ContextParams>>(
                "dynamic_parameters",
                |m: &Node| { &m.dynamic_parameters },
                |m: &mut Node| { &mut m.dynamic_parameters },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Locality>>(
                "locality",
                |m: &Node| { &m.locality },
                |m: &mut Node| { &mut m.locality },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_agent_name",
                |m: &Node| { &m.user_agent_name },
                |m: &mut Node| { &mut m.user_agent_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "user_agent_version",
                Node::has_user_agent_version,
                Node::get_user_agent_version,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BuildVersion>(
                "user_agent_build_version",
                Node::has_user_agent_build_version,
                Node::get_user_agent_build_version,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                "extensions",
                |m: &Node| { &m.extensions },
                |m: &mut Node| { &mut m.extensions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_features",
                |m: &Node| { &m.client_features },
                |m: &mut Node| { &mut m.client_features },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::address::Address>>(
                "listening_addresses",
                |m: &Node| { &m.listening_addresses },
                |m: &mut Node| { &mut m.listening_addresses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Node>(
                "Node",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Node {
        static instance: ::protobuf::rt::LazyV2<Node> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Node::new)
    }
}

impl ::protobuf::Clear for Node {
    fn clear(&mut self) {
        self.id.clear();
        self.cluster.clear();
        self.metadata.clear();
        self.dynamic_parameters.clear();
        self.locality.clear();
        self.user_agent_name.clear();
        self.user_agent_version_type = ::std::option::Option::None;
        self.user_agent_version_type = ::std::option::Option::None;
        self.extensions.clear();
        self.client_features.clear();
        self.listening_addresses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Node {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct Metadata {
    // message fields
    pub filter_metadata: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct>,
    pub typed_filter_metadata: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Metadata {
    fn default() -> &'a Metadata {
        <Metadata as ::protobuf::Message>::default_instance()
    }
}

impl Metadata {
    pub fn new() -> Metadata {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.core.v3.Metadata.FilterMetadataEntry filter_metadata = 1;


    pub fn get_filter_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct> {
        &self.filter_metadata
    }
    pub fn clear_filter_metadata(&mut self) {
        self.filter_metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct>) {
        self.filter_metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filter_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct> {
        &mut self.filter_metadata
    }

    // Take field
    pub fn take_filter_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct> {
        ::std::mem::replace(&mut self.filter_metadata, ::std::collections::HashMap::new())
    }

    // repeated .envoy.config.core.v3.Metadata.TypedFilterMetadataEntry typed_filter_metadata = 2;


    pub fn get_typed_filter_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &self.typed_filter_metadata
    }
    pub fn clear_typed_filter_metadata(&mut self) {
        self.typed_filter_metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_typed_filter_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>) {
        self.typed_filter_metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_typed_filter_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &mut self.typed_filter_metadata
    }

    // Take field
    pub fn take_typed_filter_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.typed_filter_metadata, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Metadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(wire_type, is, &mut self.filter_metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(wire_type, is, &mut self.typed_filter_metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(1, &self.filter_metadata);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(2, &self.typed_filter_metadata);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(1, &self.filter_metadata, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(2, &self.typed_filter_metadata, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Metadata {
        Metadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "filter_metadata",
                |m: &Metadata| { &m.filter_metadata },
                |m: &mut Metadata| { &mut m.filter_metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "typed_filter_metadata",
                |m: &Metadata| { &m.typed_filter_metadata },
                |m: &mut Metadata| { &mut m.typed_filter_metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Metadata>(
                "Metadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Metadata {
        static instance: ::protobuf::rt::LazyV2<Metadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Metadata::new)
    }
}

impl ::protobuf::Clear for Metadata {
    fn clear(&mut self) {
        self.filter_metadata.clear();
        self.typed_filter_metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Metadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Metadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RuntimeUInt32 {
    // message fields
    pub default_value: u32,
    pub runtime_key: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeUInt32 {
    fn default() -> &'a RuntimeUInt32 {
        <RuntimeUInt32 as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeUInt32 {
    pub fn new() -> RuntimeUInt32 {
        ::std::default::Default::default()
    }

    // uint32 default_value = 2;


    pub fn get_default_value(&self) -> u32 {
        self.default_value
    }
    pub fn clear_default_value(&mut self) {
        self.default_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_default_value(&mut self, v: u32) {
        self.default_value = v;
    }

    // string runtime_key = 3;


    pub fn get_runtime_key(&self) -> &str {
        &self.runtime_key
    }
    pub fn clear_runtime_key(&mut self) {
        self.runtime_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_runtime_key(&mut self, v: ::std::string::String) {
        self.runtime_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_key(&mut self) -> &mut ::std::string::String {
        &mut self.runtime_key
    }

    // Take field
    pub fn take_runtime_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.runtime_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RuntimeUInt32 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.default_value = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.runtime_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.default_value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.default_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.runtime_key.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.runtime_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.default_value != 0 {
            os.write_uint32(2, self.default_value)?;
        }
        if !self.runtime_key.is_empty() {
            os.write_string(3, &self.runtime_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeUInt32 {
        RuntimeUInt32::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "default_value",
                |m: &RuntimeUInt32| { &m.default_value },
                |m: &mut RuntimeUInt32| { &mut m.default_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "runtime_key",
                |m: &RuntimeUInt32| { &m.runtime_key },
                |m: &mut RuntimeUInt32| { &mut m.runtime_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeUInt32>(
                "RuntimeUInt32",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeUInt32 {
        static instance: ::protobuf::rt::LazyV2<RuntimeUInt32> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeUInt32::new)
    }
}

impl ::protobuf::Clear for RuntimeUInt32 {
    fn clear(&mut self) {
        self.default_value = 0;
        self.runtime_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeUInt32 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeUInt32 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RuntimePercent {
    // message fields
    pub default_value: ::protobuf::SingularPtrField<super::percent::Percent>,
    pub runtime_key: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimePercent {
    fn default() -> &'a RuntimePercent {
        <RuntimePercent as ::protobuf::Message>::default_instance()
    }
}

impl RuntimePercent {
    pub fn new() -> RuntimePercent {
        ::std::default::Default::default()
    }

    // .envoy.type.v3.Percent default_value = 1;


    pub fn get_default_value(&self) -> &super::percent::Percent {
        self.default_value.as_ref().unwrap_or_else(|| <super::percent::Percent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_default_value(&mut self) {
        self.default_value.clear();
    }

    pub fn has_default_value(&self) -> bool {
        self.default_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_value(&mut self, v: super::percent::Percent) {
        self.default_value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_value(&mut self) -> &mut super::percent::Percent {
        if self.default_value.is_none() {
            self.default_value.set_default();
        }
        self.default_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_value(&mut self) -> super::percent::Percent {
        self.default_value.take().unwrap_or_else(|| super::percent::Percent::new())
    }

    // string runtime_key = 2;


    pub fn get_runtime_key(&self) -> &str {
        &self.runtime_key
    }
    pub fn clear_runtime_key(&mut self) {
        self.runtime_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_runtime_key(&mut self, v: ::std::string::String) {
        self.runtime_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_key(&mut self) -> &mut ::std::string::String {
        &mut self.runtime_key
    }

    // Take field
    pub fn take_runtime_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.runtime_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RuntimePercent {
    fn is_initialized(&self) -> bool {
        for v in &self.default_value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.default_value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.runtime_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.default_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.runtime_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runtime_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.default_value.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.runtime_key.is_empty() {
            os.write_string(2, &self.runtime_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimePercent {
        RuntimePercent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::percent::Percent>>(
                "default_value",
                |m: &RuntimePercent| { &m.default_value },
                |m: &mut RuntimePercent| { &mut m.default_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "runtime_key",
                |m: &RuntimePercent| { &m.runtime_key },
                |m: &mut RuntimePercent| { &mut m.runtime_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimePercent>(
                "RuntimePercent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimePercent {
        static instance: ::protobuf::rt::LazyV2<RuntimePercent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimePercent::new)
    }
}

impl ::protobuf::Clear for RuntimePercent {
    fn clear(&mut self) {
        self.default_value.clear();
        self.runtime_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimePercent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimePercent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RuntimeDouble {
    // message fields
    pub default_value: f64,
    pub runtime_key: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeDouble {
    fn default() -> &'a RuntimeDouble {
        <RuntimeDouble as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeDouble {
    pub fn new() -> RuntimeDouble {
        ::std::default::Default::default()
    }

    // double default_value = 1;


    pub fn get_default_value(&self) -> f64 {
        self.default_value
    }
    pub fn clear_default_value(&mut self) {
        self.default_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_default_value(&mut self, v: f64) {
        self.default_value = v;
    }

    // string runtime_key = 2;


    pub fn get_runtime_key(&self) -> &str {
        &self.runtime_key
    }
    pub fn clear_runtime_key(&mut self) {
        self.runtime_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_runtime_key(&mut self, v: ::std::string::String) {
        self.runtime_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_key(&mut self) -> &mut ::std::string::String {
        &mut self.runtime_key
    }

    // Take field
    pub fn take_runtime_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.runtime_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RuntimeDouble {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.default_value = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.runtime_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.default_value != 0. {
            my_size += 9;
        }
        if !self.runtime_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runtime_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.default_value != 0. {
            os.write_double(1, self.default_value)?;
        }
        if !self.runtime_key.is_empty() {
            os.write_string(2, &self.runtime_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeDouble {
        RuntimeDouble::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "default_value",
                |m: &RuntimeDouble| { &m.default_value },
                |m: &mut RuntimeDouble| { &mut m.default_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "runtime_key",
                |m: &RuntimeDouble| { &m.runtime_key },
                |m: &mut RuntimeDouble| { &mut m.runtime_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeDouble>(
                "RuntimeDouble",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeDouble {
        static instance: ::protobuf::rt::LazyV2<RuntimeDouble> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeDouble::new)
    }
}

impl ::protobuf::Clear for RuntimeDouble {
    fn clear(&mut self) {
        self.default_value = 0.;
        self.runtime_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeDouble {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeDouble {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RuntimeFeatureFlag {
    // message fields
    pub default_value: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub runtime_key: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeFeatureFlag {
    fn default() -> &'a RuntimeFeatureFlag {
        <RuntimeFeatureFlag as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeFeatureFlag {
    pub fn new() -> RuntimeFeatureFlag {
        ::std::default::Default::default()
    }

    // .google.protobuf.BoolValue default_value = 1;


    pub fn get_default_value(&self) -> &::protobuf::well_known_types::BoolValue {
        self.default_value.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_default_value(&mut self) {
        self.default_value.clear();
    }

    pub fn has_default_value(&self) -> bool {
        self.default_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_value(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.default_value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_value(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.default_value.is_none() {
            self.default_value.set_default();
        }
        self.default_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_value(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.default_value.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // string runtime_key = 2;


    pub fn get_runtime_key(&self) -> &str {
        &self.runtime_key
    }
    pub fn clear_runtime_key(&mut self) {
        self.runtime_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_runtime_key(&mut self, v: ::std::string::String) {
        self.runtime_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_key(&mut self) -> &mut ::std::string::String {
        &mut self.runtime_key
    }

    // Take field
    pub fn take_runtime_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.runtime_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RuntimeFeatureFlag {
    fn is_initialized(&self) -> bool {
        for v in &self.default_value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.default_value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.runtime_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.default_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.runtime_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runtime_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.default_value.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.runtime_key.is_empty() {
            os.write_string(2, &self.runtime_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeFeatureFlag {
        RuntimeFeatureFlag::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "default_value",
                |m: &RuntimeFeatureFlag| { &m.default_value },
                |m: &mut RuntimeFeatureFlag| { &mut m.default_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "runtime_key",
                |m: &RuntimeFeatureFlag| { &m.runtime_key },
                |m: &mut RuntimeFeatureFlag| { &mut m.runtime_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeFeatureFlag>(
                "RuntimeFeatureFlag",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeFeatureFlag {
        static instance: ::protobuf::rt::LazyV2<RuntimeFeatureFlag> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeFeatureFlag::new)
    }
}

impl ::protobuf::Clear for RuntimeFeatureFlag {
    fn clear(&mut self) {
        self.default_value.clear();
        self.runtime_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeFeatureFlag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeFeatureFlag {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct QueryParameter {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryParameter {
    fn default() -> &'a QueryParameter {
        <QueryParameter as ::protobuf::Message>::default_instance()
    }
}

impl QueryParameter {
    pub fn new() -> QueryParameter {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QueryParameter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryParameter {
        QueryParameter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &QueryParameter| { &m.key },
                |m: &mut QueryParameter| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &QueryParameter| { &m.value },
                |m: &mut QueryParameter| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryParameter>(
                "QueryParameter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryParameter {
        static instance: ::protobuf::rt::LazyV2<QueryParameter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryParameter::new)
    }
}

impl ::protobuf::Clear for QueryParameter {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryParameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryParameter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct HeaderValue {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeaderValue {
    fn default() -> &'a HeaderValue {
        <HeaderValue as ::protobuf::Message>::default_instance()
    }
}

impl HeaderValue {
    pub fn new() -> HeaderValue {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HeaderValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeaderValue {
        HeaderValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &HeaderValue| { &m.key },
                |m: &mut HeaderValue| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &HeaderValue| { &m.value },
                |m: &mut HeaderValue| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeaderValue>(
                "HeaderValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeaderValue {
        static instance: ::protobuf::rt::LazyV2<HeaderValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeaderValue::new)
    }
}

impl ::protobuf::Clear for HeaderValue {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeaderValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeaderValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct HeaderValueOption {
    // message fields
    pub header: ::protobuf::SingularPtrField<HeaderValue>,
    pub append: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub append_action: HeaderValueOption_HeaderAppendAction,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeaderValueOption {
    fn default() -> &'a HeaderValueOption {
        <HeaderValueOption as ::protobuf::Message>::default_instance()
    }
}

impl HeaderValueOption {
    pub fn new() -> HeaderValueOption {
        ::std::default::Default::default()
    }

    // .envoy.config.core.v3.HeaderValue header = 1;


    pub fn get_header(&self) -> &HeaderValue {
        self.header.as_ref().unwrap_or_else(|| <HeaderValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: HeaderValue) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut HeaderValue {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> HeaderValue {
        self.header.take().unwrap_or_else(|| HeaderValue::new())
    }

    // .google.protobuf.BoolValue append = 2;


    pub fn get_append(&self) -> &::protobuf::well_known_types::BoolValue {
        self.append.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_append(&mut self) {
        self.append.clear();
    }

    pub fn has_append(&self) -> bool {
        self.append.is_some()
    }

    // Param is passed by value, moved
    pub fn set_append(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.append = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_append(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.append.is_none() {
            self.append.set_default();
        }
        self.append.as_mut().unwrap()
    }

    // Take field
    pub fn take_append(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.append.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .envoy.config.core.v3.HeaderValueOption.HeaderAppendAction append_action = 3;


    pub fn get_append_action(&self) -> HeaderValueOption_HeaderAppendAction {
        self.append_action
    }
    pub fn clear_append_action(&mut self) {
        self.append_action = HeaderValueOption_HeaderAppendAction::APPEND_IF_EXISTS_OR_ADD;
    }

    // Param is passed by value, moved
    pub fn set_append_action(&mut self, v: HeaderValueOption_HeaderAppendAction) {
        self.append_action = v;
    }
}

impl ::protobuf::Message for HeaderValueOption {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.append {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.append)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.append_action, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.append.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.append_action != HeaderValueOption_HeaderAppendAction::APPEND_IF_EXISTS_OR_ADD {
            my_size += ::protobuf::rt::enum_size(3, self.append_action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.append.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.append_action != HeaderValueOption_HeaderAppendAction::APPEND_IF_EXISTS_OR_ADD {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.append_action))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeaderValueOption {
        HeaderValueOption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeaderValue>>(
                "header",
                |m: &HeaderValueOption| { &m.header },
                |m: &mut HeaderValueOption| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "append",
                |m: &HeaderValueOption| { &m.append },
                |m: &mut HeaderValueOption| { &mut m.append },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HeaderValueOption_HeaderAppendAction>>(
                "append_action",
                |m: &HeaderValueOption| { &m.append_action },
                |m: &mut HeaderValueOption| { &mut m.append_action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeaderValueOption>(
                "HeaderValueOption",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeaderValueOption {
        static instance: ::protobuf::rt::LazyV2<HeaderValueOption> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeaderValueOption::new)
    }
}

impl ::protobuf::Clear for HeaderValueOption {
    fn clear(&mut self) {
        self.header.clear();
        self.append.clear();
        self.append_action = HeaderValueOption_HeaderAppendAction::APPEND_IF_EXISTS_OR_ADD;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeaderValueOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeaderValueOption {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum HeaderValueOption_HeaderAppendAction {
    APPEND_IF_EXISTS_OR_ADD = 0,
    ADD_IF_ABSENT = 1,
    OVERWRITE_IF_EXISTS_OR_ADD = 2,
}

impl ::protobuf::ProtobufEnum for HeaderValueOption_HeaderAppendAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HeaderValueOption_HeaderAppendAction> {
        match value {
            0 => ::std::option::Option::Some(HeaderValueOption_HeaderAppendAction::APPEND_IF_EXISTS_OR_ADD),
            1 => ::std::option::Option::Some(HeaderValueOption_HeaderAppendAction::ADD_IF_ABSENT),
            2 => ::std::option::Option::Some(HeaderValueOption_HeaderAppendAction::OVERWRITE_IF_EXISTS_OR_ADD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HeaderValueOption_HeaderAppendAction] = &[
            HeaderValueOption_HeaderAppendAction::APPEND_IF_EXISTS_OR_ADD,
            HeaderValueOption_HeaderAppendAction::ADD_IF_ABSENT,
            HeaderValueOption_HeaderAppendAction::OVERWRITE_IF_EXISTS_OR_ADD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<HeaderValueOption_HeaderAppendAction>("HeaderValueOption.HeaderAppendAction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for HeaderValueOption_HeaderAppendAction {
}

impl ::std::default::Default for HeaderValueOption_HeaderAppendAction {
    fn default() -> Self {
        HeaderValueOption_HeaderAppendAction::APPEND_IF_EXISTS_OR_ADD
    }
}

impl ::protobuf::reflect::ProtobufValue for HeaderValueOption_HeaderAppendAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct HeaderMap {
    // message fields
    pub headers: ::protobuf::RepeatedField<HeaderValue>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeaderMap {
    fn default() -> &'a HeaderMap {
        <HeaderMap as ::protobuf::Message>::default_instance()
    }
}

impl HeaderMap {
    pub fn new() -> HeaderMap {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.core.v3.HeaderValue headers = 1;


    pub fn get_headers(&self) -> &[HeaderValue] {
        &self.headers
    }
    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::protobuf::RepeatedField<HeaderValue>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::protobuf::RepeatedField<HeaderValue> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::protobuf::RepeatedField<HeaderValue> {
        ::std::mem::replace(&mut self.headers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for HeaderMap {
    fn is_initialized(&self) -> bool {
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.headers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.headers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeaderMap {
        HeaderMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeaderValue>>(
                "headers",
                |m: &HeaderMap| { &m.headers },
                |m: &mut HeaderMap| { &mut m.headers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeaderMap>(
                "HeaderMap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeaderMap {
        static instance: ::protobuf::rt::LazyV2<HeaderMap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeaderMap::new)
    }
}

impl ::protobuf::Clear for HeaderMap {
    fn clear(&mut self) {
        self.headers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeaderMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeaderMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct WatchedDirectory {
    // message fields
    pub path: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WatchedDirectory {
    fn default() -> &'a WatchedDirectory {
        <WatchedDirectory as ::protobuf::Message>::default_instance()
    }
}

impl WatchedDirectory {
    pub fn new() -> WatchedDirectory {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for WatchedDirectory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WatchedDirectory {
        WatchedDirectory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &WatchedDirectory| { &m.path },
                |m: &mut WatchedDirectory| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WatchedDirectory>(
                "WatchedDirectory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WatchedDirectory {
        static instance: ::protobuf::rt::LazyV2<WatchedDirectory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WatchedDirectory::new)
    }
}

impl ::protobuf::Clear for WatchedDirectory {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WatchedDirectory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchedDirectory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct DataSource {
    // message oneof groups
    pub specifier: ::std::option::Option<DataSource_oneof_specifier>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataSource {
    fn default() -> &'a DataSource {
        <DataSource as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum DataSource_oneof_specifier {
    filename(::std::string::String),
    inline_bytes(::std::vec::Vec<u8>),
    inline_string(::std::string::String),
    environment_variable(::std::string::String),
}

impl DataSource {
    pub fn new() -> DataSource {
        ::std::default::Default::default()
    }

    // string filename = 1;


    pub fn get_filename(&self) -> &str {
        match self.specifier {
            ::std::option::Option::Some(DataSource_oneof_specifier::filename(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.specifier = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        match self.specifier {
            ::std::option::Option::Some(DataSource_oneof_specifier::filename(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.specifier = ::std::option::Option::Some(DataSource_oneof_specifier::filename(v))
    }

    // Mutable pointer to the field.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(DataSource_oneof_specifier::filename(_)) = self.specifier {
        } else {
            self.specifier = ::std::option::Option::Some(DataSource_oneof_specifier::filename(::std::string::String::new()));
        }
        match self.specifier {
            ::std::option::Option::Some(DataSource_oneof_specifier::filename(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        if self.has_filename() {
            match self.specifier.take() {
                ::std::option::Option::Some(DataSource_oneof_specifier::filename(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bytes inline_bytes = 2;


    pub fn get_inline_bytes(&self) -> &[u8] {
        match self.specifier {
            ::std::option::Option::Some(DataSource_oneof_specifier::inline_bytes(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_inline_bytes(&mut self) {
        self.specifier = ::std::option::Option::None;
    }

    pub fn has_inline_bytes(&self) -> bool {
        match self.specifier {
            ::std::option::Option::Some(DataSource_oneof_specifier::inline_bytes(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_inline_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.specifier = ::std::option::Option::Some(DataSource_oneof_specifier::inline_bytes(v))
    }

    // Mutable pointer to the field.
    pub fn mut_inline_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(DataSource_oneof_specifier::inline_bytes(_)) = self.specifier {
        } else {
            self.specifier = ::std::option::Option::Some(DataSource_oneof_specifier::inline_bytes(::std::vec::Vec::new()));
        }
        match self.specifier {
            ::std::option::Option::Some(DataSource_oneof_specifier::inline_bytes(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_inline_bytes(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_inline_bytes() {
            match self.specifier.take() {
                ::std::option::Option::Some(DataSource_oneof_specifier::inline_bytes(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // string inline_string = 3;


    pub fn get_inline_string(&self) -> &str {
        match self.specifier {
            ::std::option::Option::Some(DataSource_oneof_specifier::inline_string(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_inline_string(&mut self) {
        self.specifier = ::std::option::Option::None;
    }

    pub fn has_inline_string(&self) -> bool {
        match self.specifier {
            ::std::option::Option::Some(DataSource_oneof_specifier::inline_string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_inline_string(&mut self, v: ::std::string::String) {
        self.specifier = ::std::option::Option::Some(DataSource_oneof_specifier::inline_string(v))
    }

    // Mutable pointer to the field.
    pub fn mut_inline_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(DataSource_oneof_specifier::inline_string(_)) = self.specifier {
        } else {
            self.specifier = ::std::option::Option::Some(DataSource_oneof_specifier::inline_string(::std::string::String::new()));
        }
        match self.specifier {
            ::std::option::Option::Some(DataSource_oneof_specifier::inline_string(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_inline_string(&mut self) -> ::std::string::String {
        if self.has_inline_string() {
            match self.specifier.take() {
                ::std::option::Option::Some(DataSource_oneof_specifier::inline_string(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string environment_variable = 4;


    pub fn get_environment_variable(&self) -> &str {
        match self.specifier {
            ::std::option::Option::Some(DataSource_oneof_specifier::environment_variable(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_environment_variable(&mut self) {
        self.specifier = ::std::option::Option::None;
    }

    pub fn has_environment_variable(&self) -> bool {
        match self.specifier {
            ::std::option::Option::Some(DataSource_oneof_specifier::environment_variable(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_environment_variable(&mut self, v: ::std::string::String) {
        self.specifier = ::std::option::Option::Some(DataSource_oneof_specifier::environment_variable(v))
    }

    // Mutable pointer to the field.
    pub fn mut_environment_variable(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(DataSource_oneof_specifier::environment_variable(_)) = self.specifier {
        } else {
            self.specifier = ::std::option::Option::Some(DataSource_oneof_specifier::environment_variable(::std::string::String::new()));
        }
        match self.specifier {
            ::std::option::Option::Some(DataSource_oneof_specifier::environment_variable(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_environment_variable(&mut self) -> ::std::string::String {
        if self.has_environment_variable() {
            match self.specifier.take() {
                ::std::option::Option::Some(DataSource_oneof_specifier::environment_variable(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for DataSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.specifier = ::std::option::Option::Some(DataSource_oneof_specifier::filename(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.specifier = ::std::option::Option::Some(DataSource_oneof_specifier::inline_bytes(is.read_bytes()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.specifier = ::std::option::Option::Some(DataSource_oneof_specifier::inline_string(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.specifier = ::std::option::Option::Some(DataSource_oneof_specifier::environment_variable(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.specifier {
            match v {
                &DataSource_oneof_specifier::filename(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &DataSource_oneof_specifier::inline_bytes(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &DataSource_oneof_specifier::inline_string(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
                &DataSource_oneof_specifier::environment_variable(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.specifier {
            match v {
                &DataSource_oneof_specifier::filename(ref v) => {
                    os.write_string(1, v)?;
                },
                &DataSource_oneof_specifier::inline_bytes(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &DataSource_oneof_specifier::inline_string(ref v) => {
                    os.write_string(3, v)?;
                },
                &DataSource_oneof_specifier::environment_variable(ref v) => {
                    os.write_string(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataSource {
        DataSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "filename",
                DataSource::has_filename,
                DataSource::get_filename,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "inline_bytes",
                DataSource::has_inline_bytes,
                DataSource::get_inline_bytes,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "inline_string",
                DataSource::has_inline_string,
                DataSource::get_inline_string,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "environment_variable",
                DataSource::has_environment_variable,
                DataSource::get_environment_variable,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataSource>(
                "DataSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataSource {
        static instance: ::protobuf::rt::LazyV2<DataSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataSource::new)
    }
}

impl ::protobuf::Clear for DataSource {
    fn clear(&mut self) {
        self.specifier = ::std::option::Option::None;
        self.specifier = ::std::option::Option::None;
        self.specifier = ::std::option::Option::None;
        self.specifier = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RetryPolicy {
    // message fields
    pub retry_back_off: ::protobuf::SingularPtrField<super::backoff::BackoffStrategy>,
    pub num_retries: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RetryPolicy {
    fn default() -> &'a RetryPolicy {
        <RetryPolicy as ::protobuf::Message>::default_instance()
    }
}

impl RetryPolicy {
    pub fn new() -> RetryPolicy {
        ::std::default::Default::default()
    }

    // .envoy.config.core.v3.BackoffStrategy retry_back_off = 1;


    pub fn get_retry_back_off(&self) -> &super::backoff::BackoffStrategy {
        self.retry_back_off.as_ref().unwrap_or_else(|| <super::backoff::BackoffStrategy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_back_off(&mut self) {
        self.retry_back_off.clear();
    }

    pub fn has_retry_back_off(&self) -> bool {
        self.retry_back_off.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_back_off(&mut self, v: super::backoff::BackoffStrategy) {
        self.retry_back_off = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_back_off(&mut self) -> &mut super::backoff::BackoffStrategy {
        if self.retry_back_off.is_none() {
            self.retry_back_off.set_default();
        }
        self.retry_back_off.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_back_off(&mut self) -> super::backoff::BackoffStrategy {
        self.retry_back_off.take().unwrap_or_else(|| super::backoff::BackoffStrategy::new())
    }

    // .google.protobuf.UInt32Value num_retries = 2;


    pub fn get_num_retries(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.num_retries.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_num_retries(&mut self) {
        self.num_retries.clear();
    }

    pub fn has_num_retries(&self) -> bool {
        self.num_retries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_retries(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.num_retries = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_num_retries(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.num_retries.is_none() {
            self.num_retries.set_default();
        }
        self.num_retries.as_mut().unwrap()
    }

    // Take field
    pub fn take_num_retries(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.num_retries.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }
}

impl ::protobuf::Message for RetryPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.retry_back_off {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.num_retries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_back_off)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.num_retries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.retry_back_off.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.num_retries.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.retry_back_off.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.num_retries.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RetryPolicy {
        RetryPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::backoff::BackoffStrategy>>(
                "retry_back_off",
                |m: &RetryPolicy| { &m.retry_back_off },
                |m: &mut RetryPolicy| { &mut m.retry_back_off },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "num_retries",
                |m: &RetryPolicy| { &m.num_retries },
                |m: &mut RetryPolicy| { &mut m.num_retries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RetryPolicy>(
                "RetryPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RetryPolicy {
        static instance: ::protobuf::rt::LazyV2<RetryPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RetryPolicy::new)
    }
}

impl ::protobuf::Clear for RetryPolicy {
    fn clear(&mut self) {
        self.retry_back_off.clear();
        self.num_retries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RetryPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RetryPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RemoteDataSource {
    // message fields
    pub http_uri: ::protobuf::SingularPtrField<super::http_uri::HttpUri>,
    pub sha256: ::std::string::String,
    pub retry_policy: ::protobuf::SingularPtrField<RetryPolicy>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoteDataSource {
    fn default() -> &'a RemoteDataSource {
        <RemoteDataSource as ::protobuf::Message>::default_instance()
    }
}

impl RemoteDataSource {
    pub fn new() -> RemoteDataSource {
        ::std::default::Default::default()
    }

    // .envoy.config.core.v3.HttpUri http_uri = 1;


    pub fn get_http_uri(&self) -> &super::http_uri::HttpUri {
        self.http_uri.as_ref().unwrap_or_else(|| <super::http_uri::HttpUri as ::protobuf::Message>::default_instance())
    }
    pub fn clear_http_uri(&mut self) {
        self.http_uri.clear();
    }

    pub fn has_http_uri(&self) -> bool {
        self.http_uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_uri(&mut self, v: super::http_uri::HttpUri) {
        self.http_uri = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_uri(&mut self) -> &mut super::http_uri::HttpUri {
        if self.http_uri.is_none() {
            self.http_uri.set_default();
        }
        self.http_uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_uri(&mut self) -> super::http_uri::HttpUri {
        self.http_uri.take().unwrap_or_else(|| super::http_uri::HttpUri::new())
    }

    // string sha256 = 2;


    pub fn get_sha256(&self) -> &str {
        &self.sha256
    }
    pub fn clear_sha256(&mut self) {
        self.sha256.clear();
    }

    // Param is passed by value, moved
    pub fn set_sha256(&mut self, v: ::std::string::String) {
        self.sha256 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha256(&mut self) -> &mut ::std::string::String {
        &mut self.sha256
    }

    // Take field
    pub fn take_sha256(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sha256, ::std::string::String::new())
    }

    // .envoy.config.core.v3.RetryPolicy retry_policy = 3;


    pub fn get_retry_policy(&self) -> &RetryPolicy {
        self.retry_policy.as_ref().unwrap_or_else(|| <RetryPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_policy(&mut self) {
        self.retry_policy.clear();
    }

    pub fn has_retry_policy(&self) -> bool {
        self.retry_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_policy(&mut self, v: RetryPolicy) {
        self.retry_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_policy(&mut self) -> &mut RetryPolicy {
        if self.retry_policy.is_none() {
            self.retry_policy.set_default();
        }
        self.retry_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_policy(&mut self) -> RetryPolicy {
        self.retry_policy.take().unwrap_or_else(|| RetryPolicy::new())
    }
}

impl ::protobuf::Message for RemoteDataSource {
    fn is_initialized(&self) -> bool {
        for v in &self.http_uri {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.http_uri)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sha256)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_policy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.http_uri.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.sha256.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sha256);
        }
        if let Some(ref v) = self.retry_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.http_uri.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.sha256.is_empty() {
            os.write_string(2, &self.sha256)?;
        }
        if let Some(ref v) = self.retry_policy.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoteDataSource {
        RemoteDataSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::http_uri::HttpUri>>(
                "http_uri",
                |m: &RemoteDataSource| { &m.http_uri },
                |m: &mut RemoteDataSource| { &mut m.http_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sha256",
                |m: &RemoteDataSource| { &m.sha256 },
                |m: &mut RemoteDataSource| { &mut m.sha256 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RetryPolicy>>(
                "retry_policy",
                |m: &RemoteDataSource| { &m.retry_policy },
                |m: &mut RemoteDataSource| { &mut m.retry_policy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoteDataSource>(
                "RemoteDataSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoteDataSource {
        static instance: ::protobuf::rt::LazyV2<RemoteDataSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoteDataSource::new)
    }
}

impl ::protobuf::Clear for RemoteDataSource {
    fn clear(&mut self) {
        self.http_uri.clear();
        self.sha256.clear();
        self.retry_policy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoteDataSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoteDataSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct AsyncDataSource {
    // message oneof groups
    pub specifier: ::std::option::Option<AsyncDataSource_oneof_specifier>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AsyncDataSource {
    fn default() -> &'a AsyncDataSource {
        <AsyncDataSource as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum AsyncDataSource_oneof_specifier {
    local(DataSource),
    remote(RemoteDataSource),
}

impl AsyncDataSource {
    pub fn new() -> AsyncDataSource {
        ::std::default::Default::default()
    }

    // .envoy.config.core.v3.DataSource local = 1;


    pub fn get_local(&self) -> &DataSource {
        match self.specifier {
            ::std::option::Option::Some(AsyncDataSource_oneof_specifier::local(ref v)) => v,
            _ => <DataSource as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_local(&mut self) {
        self.specifier = ::std::option::Option::None;
    }

    pub fn has_local(&self) -> bool {
        match self.specifier {
            ::std::option::Option::Some(AsyncDataSource_oneof_specifier::local(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: DataSource) {
        self.specifier = ::std::option::Option::Some(AsyncDataSource_oneof_specifier::local(v))
    }

    // Mutable pointer to the field.
    pub fn mut_local(&mut self) -> &mut DataSource {
        if let ::std::option::Option::Some(AsyncDataSource_oneof_specifier::local(_)) = self.specifier {
        } else {
            self.specifier = ::std::option::Option::Some(AsyncDataSource_oneof_specifier::local(DataSource::new()));
        }
        match self.specifier {
            ::std::option::Option::Some(AsyncDataSource_oneof_specifier::local(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_local(&mut self) -> DataSource {
        if self.has_local() {
            match self.specifier.take() {
                ::std::option::Option::Some(AsyncDataSource_oneof_specifier::local(v)) => v,
                _ => panic!(),
            }
        } else {
            DataSource::new()
        }
    }

    // .envoy.config.core.v3.RemoteDataSource remote = 2;


    pub fn get_remote(&self) -> &RemoteDataSource {
        match self.specifier {
            ::std::option::Option::Some(AsyncDataSource_oneof_specifier::remote(ref v)) => v,
            _ => <RemoteDataSource as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_remote(&mut self) {
        self.specifier = ::std::option::Option::None;
    }

    pub fn has_remote(&self) -> bool {
        match self.specifier {
            ::std::option::Option::Some(AsyncDataSource_oneof_specifier::remote(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remote(&mut self, v: RemoteDataSource) {
        self.specifier = ::std::option::Option::Some(AsyncDataSource_oneof_specifier::remote(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remote(&mut self) -> &mut RemoteDataSource {
        if let ::std::option::Option::Some(AsyncDataSource_oneof_specifier::remote(_)) = self.specifier {
        } else {
            self.specifier = ::std::option::Option::Some(AsyncDataSource_oneof_specifier::remote(RemoteDataSource::new()));
        }
        match self.specifier {
            ::std::option::Option::Some(AsyncDataSource_oneof_specifier::remote(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remote(&mut self) -> RemoteDataSource {
        if self.has_remote() {
            match self.specifier.take() {
                ::std::option::Option::Some(AsyncDataSource_oneof_specifier::remote(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoteDataSource::new()
        }
    }
}

impl ::protobuf::Message for AsyncDataSource {
    fn is_initialized(&self) -> bool {
        if let Some(AsyncDataSource_oneof_specifier::local(ref v)) = self.specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(AsyncDataSource_oneof_specifier::remote(ref v)) = self.specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.specifier = ::std::option::Option::Some(AsyncDataSource_oneof_specifier::local(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.specifier = ::std::option::Option::Some(AsyncDataSource_oneof_specifier::remote(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.specifier {
            match v {
                &AsyncDataSource_oneof_specifier::local(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &AsyncDataSource_oneof_specifier::remote(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.specifier {
            match v {
                &AsyncDataSource_oneof_specifier::local(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &AsyncDataSource_oneof_specifier::remote(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AsyncDataSource {
        AsyncDataSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DataSource>(
                "local",
                AsyncDataSource::has_local,
                AsyncDataSource::get_local,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoteDataSource>(
                "remote",
                AsyncDataSource::has_remote,
                AsyncDataSource::get_remote,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AsyncDataSource>(
                "AsyncDataSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AsyncDataSource {
        static instance: ::protobuf::rt::LazyV2<AsyncDataSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AsyncDataSource::new)
    }
}

impl ::protobuf::Clear for AsyncDataSource {
    fn clear(&mut self) {
        self.specifier = ::std::option::Option::None;
        self.specifier = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AsyncDataSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AsyncDataSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct TransportSocket {
    // message fields
    pub name: ::std::string::String,
    // message oneof groups
    pub config_type: ::std::option::Option<TransportSocket_oneof_config_type>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransportSocket {
    fn default() -> &'a TransportSocket {
        <TransportSocket as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum TransportSocket_oneof_config_type {
    typed_config(::protobuf::well_known_types::Any),
}

impl TransportSocket {
    pub fn new() -> TransportSocket {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Any typed_config = 3;


    pub fn get_typed_config(&self) -> &::protobuf::well_known_types::Any {
        match self.config_type {
            ::std::option::Option::Some(TransportSocket_oneof_config_type::typed_config(ref v)) => v,
            _ => <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_typed_config(&mut self) {
        self.config_type = ::std::option::Option::None;
    }

    pub fn has_typed_config(&self) -> bool {
        match self.config_type {
            ::std::option::Option::Some(TransportSocket_oneof_config_type::typed_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_typed_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.config_type = ::std::option::Option::Some(TransportSocket_oneof_config_type::typed_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_typed_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if let ::std::option::Option::Some(TransportSocket_oneof_config_type::typed_config(_)) = self.config_type {
        } else {
            self.config_type = ::std::option::Option::Some(TransportSocket_oneof_config_type::typed_config(::protobuf::well_known_types::Any::new()));
        }
        match self.config_type {
            ::std::option::Option::Some(TransportSocket_oneof_config_type::typed_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_typed_config(&mut self) -> ::protobuf::well_known_types::Any {
        if self.has_typed_config() {
            match self.config_type.take() {
                ::std::option::Option::Some(TransportSocket_oneof_config_type::typed_config(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Any::new()
        }
    }
}

impl ::protobuf::Message for TransportSocket {
    fn is_initialized(&self) -> bool {
        if let Some(TransportSocket_oneof_config_type::typed_config(ref v)) = self.config_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.config_type = ::std::option::Option::Some(TransportSocket_oneof_config_type::typed_config(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.config_type {
            match v {
                &TransportSocket_oneof_config_type::typed_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.config_type {
            match v {
                &TransportSocket_oneof_config_type::typed_config(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransportSocket {
        TransportSocket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &TransportSocket| { &m.name },
                |m: &mut TransportSocket| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Any>(
                "typed_config",
                TransportSocket::has_typed_config,
                TransportSocket::get_typed_config,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransportSocket>(
                "TransportSocket",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransportSocket {
        static instance: ::protobuf::rt::LazyV2<TransportSocket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransportSocket::new)
    }
}

impl ::protobuf::Clear for TransportSocket {
    fn clear(&mut self) {
        self.name.clear();
        self.config_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransportSocket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransportSocket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct RuntimeFractionalPercent {
    // message fields
    pub default_value: ::protobuf::SingularPtrField<super::percent::FractionalPercent>,
    pub runtime_key: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeFractionalPercent {
    fn default() -> &'a RuntimeFractionalPercent {
        <RuntimeFractionalPercent as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeFractionalPercent {
    pub fn new() -> RuntimeFractionalPercent {
        ::std::default::Default::default()
    }

    // .envoy.type.v3.FractionalPercent default_value = 1;


    pub fn get_default_value(&self) -> &super::percent::FractionalPercent {
        self.default_value.as_ref().unwrap_or_else(|| <super::percent::FractionalPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_default_value(&mut self) {
        self.default_value.clear();
    }

    pub fn has_default_value(&self) -> bool {
        self.default_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_value(&mut self, v: super::percent::FractionalPercent) {
        self.default_value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_value(&mut self) -> &mut super::percent::FractionalPercent {
        if self.default_value.is_none() {
            self.default_value.set_default();
        }
        self.default_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_value(&mut self) -> super::percent::FractionalPercent {
        self.default_value.take().unwrap_or_else(|| super::percent::FractionalPercent::new())
    }

    // string runtime_key = 2;


    pub fn get_runtime_key(&self) -> &str {
        &self.runtime_key
    }
    pub fn clear_runtime_key(&mut self) {
        self.runtime_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_runtime_key(&mut self, v: ::std::string::String) {
        self.runtime_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_key(&mut self) -> &mut ::std::string::String {
        &mut self.runtime_key
    }

    // Take field
    pub fn take_runtime_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.runtime_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RuntimeFractionalPercent {
    fn is_initialized(&self) -> bool {
        for v in &self.default_value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.default_value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.runtime_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.default_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.runtime_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runtime_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.default_value.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.runtime_key.is_empty() {
            os.write_string(2, &self.runtime_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeFractionalPercent {
        RuntimeFractionalPercent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::percent::FractionalPercent>>(
                "default_value",
                |m: &RuntimeFractionalPercent| { &m.default_value },
                |m: &mut RuntimeFractionalPercent| { &mut m.default_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "runtime_key",
                |m: &RuntimeFractionalPercent| { &m.runtime_key },
                |m: &mut RuntimeFractionalPercent| { &mut m.runtime_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeFractionalPercent>(
                "RuntimeFractionalPercent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeFractionalPercent {
        static instance: ::protobuf::rt::LazyV2<RuntimeFractionalPercent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeFractionalPercent::new)
    }
}

impl ::protobuf::Clear for RuntimeFractionalPercent {
    fn clear(&mut self) {
        self.default_value.clear();
        self.runtime_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeFractionalPercent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeFractionalPercent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub struct ControlPlane {
    // message fields
    pub identifier: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ControlPlane {
    fn default() -> &'a ControlPlane {
        <ControlPlane as ::protobuf::Message>::default_instance()
    }
}

impl ControlPlane {
    pub fn new() -> ControlPlane {
        ::std::default::Default::default()
    }

    // string identifier = 1;


    pub fn get_identifier(&self) -> &str {
        &self.identifier
    }
    pub fn clear_identifier(&mut self) {
        self.identifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::string::String) {
        self.identifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
        &mut self.identifier
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identifier, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ControlPlane {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identifier)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identifier.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identifier);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identifier.is_empty() {
            os.write_string(1, &self.identifier)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ControlPlane {
        ControlPlane::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identifier",
                |m: &ControlPlane| { &m.identifier },
                |m: &mut ControlPlane| { &mut m.identifier },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ControlPlane>(
                "ControlPlane",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ControlPlane {
        static instance: ::protobuf::rt::LazyV2<ControlPlane> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ControlPlane::new)
    }
}

impl ::protobuf::Clear for ControlPlane {
    fn clear(&mut self) {
        self.identifier.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ControlPlane {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlPlane {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RoutingPriority {
    DEFAULT = 0,
    HIGH = 1,
}

impl ::protobuf::ProtobufEnum for RoutingPriority {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RoutingPriority> {
        match value {
            0 => ::std::option::Option::Some(RoutingPriority::DEFAULT),
            1 => ::std::option::Option::Some(RoutingPriority::HIGH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RoutingPriority] = &[
            RoutingPriority::DEFAULT,
            RoutingPriority::HIGH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RoutingPriority>("RoutingPriority", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RoutingPriority {
}

impl ::std::default::Default for RoutingPriority {
    fn default() -> Self {
        RoutingPriority::DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingPriority {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum RequestMethod {
    METHOD_UNSPECIFIED = 0,
    GET = 1,
    HEAD = 2,
    POST = 3,
    PUT = 4,
    DELETE = 5,
    CONNECT = 6,
    OPTIONS = 7,
    TRACE = 8,
    PATCH = 9,
}

impl ::protobuf::ProtobufEnum for RequestMethod {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RequestMethod> {
        match value {
            0 => ::std::option::Option::Some(RequestMethod::METHOD_UNSPECIFIED),
            1 => ::std::option::Option::Some(RequestMethod::GET),
            2 => ::std::option::Option::Some(RequestMethod::HEAD),
            3 => ::std::option::Option::Some(RequestMethod::POST),
            4 => ::std::option::Option::Some(RequestMethod::PUT),
            5 => ::std::option::Option::Some(RequestMethod::DELETE),
            6 => ::std::option::Option::Some(RequestMethod::CONNECT),
            7 => ::std::option::Option::Some(RequestMethod::OPTIONS),
            8 => ::std::option::Option::Some(RequestMethod::TRACE),
            9 => ::std::option::Option::Some(RequestMethod::PATCH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RequestMethod] = &[
            RequestMethod::METHOD_UNSPECIFIED,
            RequestMethod::GET,
            RequestMethod::HEAD,
            RequestMethod::POST,
            RequestMethod::PUT,
            RequestMethod::DELETE,
            RequestMethod::CONNECT,
            RequestMethod::OPTIONS,
            RequestMethod::TRACE,
            RequestMethod::PATCH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RequestMethod>("RequestMethod", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RequestMethod {
}

impl ::std::default::Default for RequestMethod {
    fn default() -> Self {
        RequestMethod::METHOD_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestMethod {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(::serde::Serialize, ::serde::Deserialize))]
pub enum TrafficDirection {
    UNSPECIFIED = 0,
    INBOUND = 1,
    OUTBOUND = 2,
}

impl ::protobuf::ProtobufEnum for TrafficDirection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TrafficDirection> {
        match value {
            0 => ::std::option::Option::Some(TrafficDirection::UNSPECIFIED),
            1 => ::std::option::Option::Some(TrafficDirection::INBOUND),
            2 => ::std::option::Option::Some(TrafficDirection::OUTBOUND),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TrafficDirection] = &[
            TrafficDirection::UNSPECIFIED,
            TrafficDirection::INBOUND,
            TrafficDirection::OUTBOUND,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TrafficDirection>("TrafficDirection", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TrafficDirection {
}

impl ::std::default::Default for TrafficDirection {
    fn default() -> Self {
        TrafficDirection::UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for TrafficDirection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1fenvoy/config/core/v3/base.proto\x12\x14envoy.config.core.v3\x1a\"e\
    nvoy/config/core/v3/address.proto\x1a\"envoy/config/core/v3/backoff.prot\
    o\x1a#envoy/config/core/v3/http_uri.proto\x1a\x1benvoy/type/v3/percent.p\
    roto\x1a$envoy/type/v3/semantic_version.proto\x1a\x19google/protobuf/any\
    .proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1egoogle/protobuf/wrappe\
    rs.proto\x1a\x20xds/core/v3/context_params.proto\x1a#envoy/annotations/d\
    eprecation.proto\x1a\x1eudpa/annotations/migrate.proto\x1a\x1dudpa/annot\
    ations/status.proto\x1a!udpa/annotations/versioning.proto\x1a\x17validat\
    e/validate.proto\"t\n\x08Locality\x12\x16\n\x06region\x18\x01\x20\x01(\t\
    R\x06region\x12\x12\n\x04zone\x18\x02\x20\x01(\tR\x04zone\x12\x19\n\x08s\
    ub_zone\x18\x03\x20\x01(\tR\x07subZone:!\x9a\xc5\x88\x1e\x1c\n\x1aenvoy.\
    api.v2.core.Locality\"\xa4\x01\n\x0cBuildVersion\x128\n\x07version\x18\
    \x01\x20\x01(\x0b2\x1e.envoy.type.v3.SemanticVersionR\x07version\x123\n\
    \x08metadata\x18\x02\x20\x01(\x0b2\x17.google.protobuf.StructR\x08metada\
    ta:%\x9a\xc5\x88\x1e\x20\n\x1eenvoy.api.v2.core.BuildVersion\"\xe2\x01\n\
    \tExtension\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1a\n\x08c\
    ategory\x18\x02\x20\x01(\tR\x08category\x12'\n\x0ftype_descriptor\x18\
    \x03\x20\x01(\tR\x0etypeDescriptor\x12<\n\x07version\x18\x04\x20\x01(\
    \x0b2\".envoy.config.core.v3.BuildVersionR\x07version\x12\x1a\n\x08disab\
    led\x18\x05\x20\x01(\x08R\x08disabled:\"\x9a\xc5\x88\x1e\x1d\n\x1benvoy.\
    api.v2.core.Extension\"\xb2\x06\n\x04Node\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\x12\x18\n\x07cluster\x18\x02\x20\x01(\tR\x07cluster\x123\
    \n\x08metadata\x18\x03\x20\x01(\x0b2\x17.google.protobuf.StructR\x08meta\
    data\x12`\n\x12dynamic_parameters\x18\x0c\x20\x03(\x0b21.envoy.config.co\
    re.v3.Node.DynamicParametersEntryR\x11dynamicParameters\x12:\n\x08locali\
    ty\x18\x04\x20\x01(\x0b2\x1e.envoy.config.core.v3.LocalityR\x08locality\
    \x12&\n\x0fuser_agent_name\x18\x06\x20\x01(\tR\ruserAgentName\x12.\n\x12\
    user_agent_version\x18\x07\x20\x01(\tH\0R\x10userAgentVersion\x12]\n\x18\
    user_agent_build_version\x18\x08\x20\x01(\x0b2\".envoy.config.core.v3.Bu\
    ildVersionH\0R\x15userAgentBuildVersion\x12?\n\nextensions\x18\t\x20\x03\
    (\x0b2\x1f.envoy.config.core.v3.ExtensionR\nextensions\x12'\n\x0fclient_\
    features\x18\n\x20\x03(\tR\x0eclientFeatures\x12[\n\x13listening_address\
    es\x18\x0b\x20\x03(\x0b2\x1d.envoy.config.core.v3.AddressR\x12listeningA\
    ddressesB\x0b\x18\x01\x92\xc7\x86\xd8\x04\x033.0\x1a`\n\x16DynamicParame\
    tersEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x120\n\x05value\
    \x18\x02\x20\x01(\x0b2\x1a.xds.core.v3.ContextParamsR\x05value:\x028\x01\
    B\x19\n\x17user_agent_version_type:\x1d\x9a\xc5\x88\x1e\x18\n\x16envoy.a\
    pi.v2.core.NodeJ\x04\x08\x05\x10\x06R\rbuild_version\"\xb1\x03\n\x08Meta\
    data\x12[\n\x0ffilter_metadata\x18\x01\x20\x03(\x0b22.envoy.config.core.\
    v3.Metadata.FilterMetadataEntryR\x0efilterMetadata\x12k\n\x15typed_filte\
    r_metadata\x18\x02\x20\x03(\x0b27.envoy.config.core.v3.Metadata.TypedFil\
    terMetadataEntryR\x13typedFilterMetadata\x1aZ\n\x13FilterMetadataEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12-\n\x05value\x18\x02\x20\
    \x01(\x0b2\x17.google.protobuf.StructR\x05value:\x028\x01\x1a\\\n\x18Typ\
    edFilterMetadataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12*\n\
    \x05value\x18\x02\x20\x01(\x0b2\x14.google.protobuf.AnyR\x05value:\x028\
    \x01:!\x9a\xc5\x88\x1e\x1c\n\x1aenvoy.api.v2.core.Metadata\"\x86\x01\n\r\
    RuntimeUInt32\x12#\n\rdefault_value\x18\x02\x20\x01(\rR\x0cdefaultValue\
    \x12(\n\x0bruntime_key\x18\x03\x20\x01(\tR\nruntimeKeyB\x07\xfaB\x04r\
    \x02\x10\x01:&\x9a\xc5\x88\x1e!\n\x1fenvoy.api.v2.core.RuntimeUInt32\"w\
    \n\x0eRuntimePercent\x12;\n\rdefault_value\x18\x01\x20\x01(\x0b2\x16.env\
    oy.type.v3.PercentR\x0cdefaultValue\x12(\n\x0bruntime_key\x18\x02\x20\
    \x01(\tR\nruntimeKeyB\x07\xfaB\x04r\x02\x10\x01\"\x86\x01\n\rRuntimeDoub\
    le\x12#\n\rdefault_value\x18\x01\x20\x01(\x01R\x0cdefaultValue\x12(\n\
    \x0bruntime_key\x18\x02\x20\x01(\tR\nruntimeKeyB\x07\xfaB\x04r\x02\x10\
    \x01:&\x9a\xc5\x88\x1e!\n\x1fenvoy.api.v2.core.RuntimeDouble\"\xb6\x01\n\
    \x12RuntimeFeatureFlag\x12I\n\rdefault_value\x18\x01\x20\x01(\x0b2\x1a.g\
    oogle.protobuf.BoolValueR\x0cdefaultValueB\x08\xfaB\x05\x8a\x01\x02\x10\
    \x01\x12(\n\x0bruntime_key\x18\x02\x20\x01(\tR\nruntimeKeyB\x07\xfaB\x04\
    r\x02\x10\x01:+\x9a\xc5\x88\x1e&\n$envoy.api.v2.core.RuntimeFeatureFlag\
    \"A\n\x0eQueryParameter\x12\x19\n\x03key\x18\x01\x20\x01(\tR\x03keyB\x07\
    \xfaB\x04r\x02\x10\x01\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\
    \x7f\n\x0bHeaderValue\x12#\n\x03key\x18\x01\x20\x01(\tR\x03keyB\x11\xfaB\
    \x0er\x0c\x10\x01(\x80\x80\x01\xc0\x01\x01\xc8\x01\0\x12%\n\x05value\x18\
    \x02\x20\x01(\tR\x05valueB\x0f\xfaB\x0cr\n(\x80\x80\x01\xc0\x01\x02\xc8\
    \x01\0:$\x9a\xc5\x88\x1e\x1f\n\x1denvoy.api.v2.core.HeaderValue\"\x89\
    \x03\n\x11HeaderValueOption\x12C\n\x06header\x18\x01\x20\x01(\x0b2!.envo\
    y.config.core.v3.HeaderValueR\x06headerB\x08\xfaB\x05\x8a\x01\x02\x10\
    \x01\x122\n\x06append\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.BoolValu\
    eR\x06append\x12i\n\rappend_action\x18\x03\x20\x01(\x0e2:.envoy.config.c\
    ore.v3.HeaderValueOption.HeaderAppendActionR\x0cappendActionB\x08\xfaB\
    \x05\x82\x01\x02\x10\x01\"d\n\x12HeaderAppendAction\x12\x1b\n\x17APPEND_\
    IF_EXISTS_OR_ADD\x10\0\x12\x11\n\rADD_IF_ABSENT\x10\x01\x12\x1e\n\x1aOVE\
    RWRITE_IF_EXISTS_OR_ADD\x10\x02:*\x9a\xc5\x88\x1e%\n#envoy.api.v2.core.H\
    eaderValueOption\"l\n\tHeaderMap\x12;\n\x07headers\x18\x01\x20\x03(\x0b2\
    !.envoy.config.core.v3.HeaderValueR\x07headers:\"\x9a\xc5\x88\x1e\x1d\n\
    \x1benvoy.api.v2.core.HeaderMap\"/\n\x10WatchedDirectory\x12\x1b\n\x04pa\
    th\x18\x01\x20\x01(\tR\x04pathB\x07\xfaB\x04r\x02\x10\x01\"\xf4\x01\n\nD\
    ataSource\x12%\n\x08filename\x18\x01\x20\x01(\tH\0R\x08filenameB\x07\xfa\
    B\x04r\x02\x10\x01\x12#\n\x0cinline_bytes\x18\x02\x20\x01(\x0cH\0R\x0bin\
    lineBytes\x12%\n\rinline_string\x18\x03\x20\x01(\tH\0R\x0cinlineString\
    \x12<\n\x14environment_variable\x18\x04\x20\x01(\tH\0R\x13environmentVar\
    iableB\x07\xfaB\x04r\x02\x10\x01B\x10\n\tspecifier\x12\x03\xf8B\x01:#\
    \x9a\xc5\x88\x1e\x1e\n\x1cenvoy.api.v2.core.DataSource\"\xd4\x01\n\x0bRe\
    tryPolicy\x12K\n\x0eretry_back_off\x18\x01\x20\x01(\x0b2%.envoy.config.c\
    ore.v3.BackoffStrategyR\x0cretryBackOff\x12R\n\x0bnum_retries\x18\x02\
    \x20\x01(\x0b2\x1c.google.protobuf.UInt32ValueR\nnumRetriesB\x13\xf2\x98\
    \xfe\x8f\x05\r\n\x0bmax_retries:$\x9a\xc5\x88\x1e\x1f\n\x1denvoy.api.v2.\
    core.RetryPolicy\"\xe8\x01\n\x10RemoteDataSource\x12B\n\x08http_uri\x18\
    \x01\x20\x01(\x0b2\x1d.envoy.config.core.v3.HttpUriR\x07httpUriB\x08\xfa\
    B\x05\x8a\x01\x02\x10\x01\x12\x1f\n\x06sha256\x18\x02\x20\x01(\tR\x06sha\
    256B\x07\xfaB\x04r\x02\x10\x01\x12D\n\x0cretry_policy\x18\x03\x20\x01(\
    \x0b2!.envoy.config.core.v3.RetryPolicyR\x0bretryPolicy:)\x9a\xc5\x88\
    \x1e$\n\"envoy.api.v2.core.RemoteDataSource\"\xc9\x01\n\x0fAsyncDataSour\
    ce\x128\n\x05local\x18\x01\x20\x01(\x0b2\x20.envoy.config.core.v3.DataSo\
    urceH\0R\x05local\x12@\n\x06remote\x18\x02\x20\x01(\x0b2&.envoy.config.c\
    ore.v3.RemoteDataSourceH\0R\x06remoteB\x10\n\tspecifier\x12\x03\xf8B\x01\
    :(\x9a\xc5\x88\x1e#\n!envoy.api.v2.core.AsyncDataSource\"\xb0\x01\n\x0fT\
    ransportSocket\x12\x1b\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x07\xfaB\
    \x04r\x02\x10\x01\x129\n\x0ctyped_config\x18\x03\x20\x01(\x0b2\x14.googl\
    e.protobuf.AnyH\0R\x0btypedConfigB\r\n\x0bconfig_type:(\x9a\xc5\x88\x1e#\
    \n!envoy.api.v2.core.TransportSocketJ\x04\x08\x02\x10\x03R\x06config\"\
    \xbf\x01\n\x18RuntimeFractionalPercent\x12O\n\rdefault_value\x18\x01\x20\
    \x01(\x0b2\x20.envoy.type.v3.FractionalPercentR\x0cdefaultValueB\x08\xfa\
    B\x05\x8a\x01\x02\x10\x01\x12\x1f\n\x0bruntime_key\x18\x02\x20\x01(\tR\n\
    runtimeKey:1\x9a\xc5\x88\x1e,\n*envoy.api.v2.core.RuntimeFractionalPerce\
    nt\"U\n\x0cControlPlane\x12\x1e\n\nidentifier\x18\x01\x20\x01(\tR\nident\
    ifier:%\x9a\xc5\x88\x1e\x20\n\x1eenvoy.api.v2.core.ControlPlane*(\n\x0fR\
    outingPriority\x12\x0b\n\x07DEFAULT\x10\0\x12\x08\n\x04HIGH\x10\x01*\x89\
    \x01\n\rRequestMethod\x12\x16\n\x12METHOD_UNSPECIFIED\x10\0\x12\x07\n\
    \x03GET\x10\x01\x12\x08\n\x04HEAD\x10\x02\x12\x08\n\x04POST\x10\x03\x12\
    \x07\n\x03PUT\x10\x04\x12\n\n\x06DELETE\x10\x05\x12\x0b\n\x07CONNECT\x10\
    \x06\x12\x0b\n\x07OPTIONS\x10\x07\x12\t\n\x05TRACE\x10\x08\x12\t\n\x05PA\
    TCH\x10\t*>\n\x10TrafficDirection\x12\x0f\n\x0bUNSPECIFIED\x10\0\x12\x0b\
    \n\x07INBOUND\x10\x01\x12\x0c\n\x08OUTBOUND\x10\x02B9\n\"io.envoyproxy.e\
    nvoy.config.core.v3B\tBaseProtoP\x01\xba\x80\xc8\xd1\x06\x02\x10\x02b\
    \x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
